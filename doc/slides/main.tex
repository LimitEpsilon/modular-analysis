%! TEX program = xelatex
% \PassOptionsToPackage{draft}{graphicx}
\documentclass{beamer}

\usepackage{kotex}
\usepackage{xcolor}
\usepackage{tcolorbox}

\usepackage{setspace} % setstretch

\usepackage{tabularray}
\UseTblrLibrary{booktabs}
\UseTblrLibrary{counter}

%%% Math settings
\usepackage{amsmath,amsthm,amssymb,mathtools} % Before unicode-math
\usepackage[math-style=TeX,bold-style=TeX]{unicode-math}
\theoremstyle{definition}
\newtheorem*{definition*}{Definition}
\newtheorem*{lemma*}{Lemma}
\newtheorem*{theorem*}{Theorem}
\newtheorem*{corollary*}{Corollary}
\newtheorem*{notation*}{Notation}

%%% Font settings
\setmainfont{Libertinus Serif}
\setmathfont{Libertinus Math} % Before set*hangulfont
\setmathfont{TeX Gyre Pagella Math}[range={\lbrace,\rbrace,\checkmark},Scale=1.1]
\setmainhangulfont{Noto Serif CJK KR}
\setsanshangulfont[BoldFont={* Bold}]{KoPubWorld Dotum.ttf}

%%% PL constructs
\usepackage{galois}
\usepackage{ebproof}
\ebproofset{left label template=\textsc{[\inserttext]}}
\ebproofset{center=false}

% For simplebnf
\newfontfamily{\fallbackfont}{EB Garamond}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\usepackage{newunicodechar}
\newunicodechar{⩴}{\textfallback{⩴}}

%%% Custom commands
\newcommand*{\vbar}{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{⩴}}
\newcommand*{\ortype}{\mathrel{|}}
\newcommand*{\cons}{:{\hspace{-0.7em}}:}
\newcommand*{\pset}{\mathcal{P}}
\newcommand*{\preall}[2][black]{\prescript{\textcolor{#1}{\forall}}{}{#2}}
\newcommand*{\prexists}[2][black]{\prescript{\textcolor{#1}{\exists}}{}{#2}}

\def\ovbarw{1.2mu}
\def\ovbarh{1}
\def\equivadjust{-1em}
\newcommand*{\ovbar}[1]{\mkern \ovbarw\overline{\mkern-\ovbarw{\smash{#1}\scalebox{1}[\ovbarh]{\vphantom{i}}}\mkern-\ovbarw}\mkern \ovbarw}
\newcommand*{\A}[1]{\overset{\,_{\mbox{\Large .}}}{#1}}
\newcommand*{\Abs}[1]{{#1}^{\#}}
\newcommand*{\Expr}{\mathsf{Expr}}
\newcommand*{\ExprVar}{\mathsf{Var}}
\newcommand*{\Module}{\mathsf{Module}}
\newcommand*{\ModVar}{\mathsf{ModVar}}
\newcommand*{\modid}{d}
\newcommand*{\Time}{\mathbb{T}}
\newcommand*{\ATime}{\A{\Time}}
\newcommand*{\ctx}{\sigma}
\newcommand*{\Ctx}{\mathsf{Ctx}}
\newcommand*{\Value}{\mathsf{Val}}
\newcommand*{\Mem}{\mathsf{Mem}}
\newcommand*{\Sig}{\mathsf{Sig}}
\newcommand*{\mem}{m}
\newcommand*{\Trace}{\mathsf{Trace}}
\newcommand*{\AMem}{\A{\mathsf{Mem}}}
\newcommand*{\Config}{\mathsf{Config}}
\newcommand*{\config}{c}
\newcommand*{\Right}{\mathsf{Right}}
\newcommand*{\rightst}{r}
\newcommand*{\texteq}[1]{\stackrel{\mathclap{\tiny\normalfont\mbox{#1}}}{=}}
\newcommand*{\State}{\mathsf{State}}
\newcommand*{\AState}{\A{\mathsf{State}}}
\newcommand*{\Outcome}{\mathsf{Outcome}}
\newcommand*{\Tick}{\mathsf{Tick}}
\newcommand*{\lfp}{\mathsf{lfp}}
\newcommand*{\Step}{\mathsf{Step}}
\newcommand*{\semarrow}{\hookrightarrow}
\newcommand*{\asemarrow}{\A{\hookrightarrow}}
\newcommand*{\synlink}{\rtimes}
\newcommand*{\semlink}{\mathbin{\rotatebox[origin=c]{180}{$\propto$}}}
\newcommand*{\link}[2]{{#1}\rtimes{#2}}
\newcommand*{\mt}{\mathsf{emp}}
\newcommand*{\valid}{\checkmark}
\newcommand*{\Path}{\mathsf{Path}}
\newcommand*{\equivalent}{\cong}

\newcommand*{\doubleplus}{\ensuremath{\mathbin{+\mkern-3mu+}}}
\newcommand*{\project}{\text{\texttt{:>} }}
\newcommand*{\sembracket}[1]{\lBrack{#1}\rBrack}
\newcommand*{\fin}[2]{{#1}\xrightarrow{\text{fin}}{#2}}
\newcommand*{\addr}{\mathsf{addr}}
\newcommand*{\tick}{\mathsf{tick}}
\newcommand*{\modctx}{\mathsf{ctx}}
\newcommand*{\inject}[2]{{#2}\langle{#1}\rangle}
\newcommand*{\delete}[2]{{#2}{\langle{#1}\rangle}^{-1}}
\newcommand*{\filter}{\mathsf{filter}}
\newcommand*{\Let}{\mathtt{let}}

%%%%%%%%%%%%%%%%%%%%%
%  Beamer Settings  %
%%%%%%%%%%%%%%%%%%%%%
\usetheme[numbering=fraction,progressbar=none]{metropolis}
\useoutertheme[subsection=false]{miniframes}
\usecolortheme{rose}

\setbeamertemplate{itemize item}[square]
\setbeamertemplate{itemize subitem}[triangle]
\setbeamertemplate{itemize subsubitem}[circle]
\setbeamertemplate{headline}{}

\usepackage{listings}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}

%%% lstlisting coq style (inspired from a file of Assia Mahboubi)
\lstdefinelanguage{Coq}{
    % To insert blank lines, write %
    escapechar=\%,
    % Anything betweeen $ becomes LaTeX math mode
    mathescape=true,
    % Comments may or not include Latex commands
    texcl=false, 
    % Vernacular commands
    morekeywords=[1]{Section, Module, End, Require, Import, Export, Include,
        Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
        Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
        Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
        Morphism, Relation, Implicit, Arguments, Unset, Contextual,
        Strict, Prenex, Implicits, Inductive, CoInductive, Record,
        Structure, Canonical, Coercion, Context, Class, Global, Instance,
        Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
        Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
        Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
        Projections, inside, outside, Def},
    % Gallina
    morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
        match, with, end, as, in, return, let, if, is, then, else, for, of,
        nosimpl, when},
    % Sorts
    morekeywords=[3]{Type, Prop, Set, true, false, option},
    % Various tactics, some are std Coq subsumed by ssr, for the manual purpose
    morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
        intro, intros, generalize, rename, pattern, after, destruct,
        induction, using, refine, inversion, injection, rewrite, congr,
        unlock, compute, ring, field, fourier, replace, fold, unfold,
        change, cutrewrite, simpl, have, suff, wlog, suffices, without,
        loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
        symmetry, transitivity, auto, split, left, right, autorewrite},
    % Terminators
    morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
        assumption, solve, contradiction, discriminate},
    % Control
    morekeywords=[6]{do, last, first, try, idtac, repeat},
    % Comments delimiters, we do turn this off for the manual
    morecomment=[s]{(*}{*)},
    % Spaces are not displayed as a special character
    showstringspaces=false,
    % String delimiters
    morestring=[b]",
    morestring=[d],
    % Size of tabulations
    tabsize=3,
    % Enables ASCII chars 128 to 255
    extendedchars=false,
    % Case sensitivity
    sensitive=true,
    % Automatic breaking of long lines
    breaklines=false,
    % Default style fors listings
    basicstyle=\footnotesize,
    % Position of captions is bottom
    captionpos=b,
    % flexible columns
    columns=[l]flexible,
    % Style for (listings') identifiers
    identifierstyle={\ttfamily\color{black}},
    % Style for declaration keywords
    keywordstyle=[1]{\ttfamily\color{dkviolet}},
    % Style for gallina keywords
    keywordstyle=[2]{\ttfamily\color{dkgreen}},
    % Style for sorts keywords
    keywordstyle=[3]{\ttfamily\color{ltblue}},
    % Style for tactics keywords
    keywordstyle=[4]{\ttfamily\color{dkblue}},
    % Style for terminators keywords
    keywordstyle=[5]{\ttfamily\color{dkred}},
    %Style for iterators
    %keywordstyle=[6]{\ttfamily\color{dkpink}},
    % Style for strings
    stringstyle=\ttfamily,
    % Style for comments
    commentstyle={\ttfamily\color{dkgreen}},
    %moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
    literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
    %    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
    %
}[keywords,comments,strings]

\usepackage{pgfplots}
\usetikzlibrary{shapes,arrows}

\usepackage{adjustbox}
\newcommand{\cfbox}[1]{\adjustbox{cfbox=#1}}

\title{A Simple Abstract Interpretation Framework for Modular Analysis}
\author{Joonhyup Lee, Kwangkeun Yi}
\date{Nov. 16, 2023}
\institute{ROPAS{@}SNU}

\titlegraphic{%
  \begin{tikzpicture}[overlay,remember picture]
    \node at (current page.145) [xshift=3em, yshift=-1.3em] {
      \includegraphics[width=3em]{snu-symbol.png}
    };
    \node at (current page.35) [xshift=-3em, yshift=-1.3em] {
      \includegraphics[width=2.5em]{ropas-symbol.png}
    };
  \end{tikzpicture}%
}

\begin{document}
\maketitle
\begin{frame}[c,fragile]
  \frametitle{Problem Formulation}
  How do we formalize analyzing program fragments (exporting modules \& the main expression) \emph{in advance}?

  \begin{tabular}{ccc}
    \begin{minipage}{0.3\linewidth}
      \begin{lstlisting}[language=Coq]
(* Module M *)
let x = 1
%
%
%
      \end{lstlisting}
    \end{minipage} &
    \begin{minipage}{0.3\linewidth}
      \begin{lstlisting}[language=Coq]
(* Module F *)
let fix fact n =
  if n $<$ 1 then 1
  else n * fact (n - 1)
      \end{lstlisting}
    \end{minipage}  &
    \begin{minipage}{0.3\linewidth}
      \begin{lstlisting}[language=Coq]
(* Client code *)
Include M
Include F
(F.fact 100) + M.x
      \end{lstlisting}
    \end{minipage}
  \end{tabular}

  \begin{itemize}
    \item Analyze with only \texttt{F} assumed ($100!+$?)
    \item Then link \texttt{M} afterwards.
  \end{itemize}

  \pause
  \begin{center}
    \fbox{How to design separate, modular analysis, then link?}
  \end{center}
\end{frame}
\begin{frame}{Table of Contents}
  \tableofcontents
\end{frame}
\section{A model language :\\Call-by-Value \texorpdfstring{$\lambda$}{a} Calculus with Modules}
\begin{frame}[c]
  \frametitle{Syntax}
  \begin{figure}[h!]
    \centering
    \begin{tabular}{rrcll}
      Identifiers & $x,\modid$ & $\in$         & $\ExprVar$                                                             \\
      Expression  & $e$        & $\rightarrow$ & $x$ $\vbar$ $\lambda x.e$ $\vbar$ $e$ $e$ & untyped $\lambda$-calculus \\
                  &            & $\vbar$       & $\link{e}{e}$                             & linked expression          \\
                  &            & $\vbar$       & $\varepsilon$                             & empty module               \\
                  &            & $\vbar$       & $\modid$                                  & module identifier          \\
                  &            & $\vbar$       & $\Let$ $x$ $e$ $e$                        & expression binding         \\
                  &            & $\vbar$       & $\Let$ $\modid$ $e$ $e$                   & module binding             \\
    \end{tabular}
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Semantic Domains}
  \begin{figure}[h!]
    \footnotesize
    \centering
    \begin{tabular}{rrcll}
      Environment/Context          & $\ctx$     & $\in$         & $\Ctx$                                            \\
      Value of expressions         & $v$        & $\in$         & $\Value \triangleq \ExprVar\times\Expr\times\Ctx$ \\
      Value of expressions/modules & $V$        & $\in$         & $\Value+\Ctx$                                     \\
      Configuration (left)         & $\config$  & $\in$         & $\Config\triangleq\Expr\times\Ctx$                \\
      Configuration (right)        & $\rightst$ & $\in$         & $\Right\triangleq\Config+\Value+\Ctx$             \\
      Context                      & $\ctx$     & $\rightarrow$ & []                                                \\
                                   &            & $\vbar$       & $(x,v)\cons \ctx$                                 \\
                                   &            & $\vbar$       & $(\modid,\ctx)\cons \ctx$                         \\
      Value of expressions         & $v$        & $\rightarrow$ & $\langle \lambda x.e, \ctx \rangle$\end{tabular}
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Operational Semantics (call-by-value $\lambda$ calculus)}
  \begin{figure}[t!]
    \scriptsize
    \begin{flushright}
      \fbox{$(e,\ctx)\semarrow V\text{ or }(e',\ctx')$}
    \end{flushright}
    \centering
    \vspace{0pt} % -0.75em}
    \[
      \begin{prooftree}
        \hypo{v=\ctx(x)}
        \infer[left label=ExprID]1{
        (x, \ctx)
        \semarrow
        v
        }
      \end{prooftree}\qquad
      \begin{prooftree}
        \infer[left label=Fn]0{
        (\lambda x.e, \ctx)
        \semarrow
        \langle\lambda x.e, \ctx\rangle
        }
      \end{prooftree}\qquad
      \begin{prooftree}
        \infer[left label={AppL}]0{
        (e_{1}\:e_{2}, \ctx)
        \semarrow
        (e_{1},\ctx)
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx)
            \semarrow
            \langle\lambda x.e_{\lambda}, \ctx_{\lambda}\rangle
          \end{matrix}
        }
        \infer[left label={AppR}]1{
        (e_{1}\:e_{2}, \ctx)
        \semarrow
        (e_{2}, \ctx)
        }
      \end{prooftree}\qquad
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx)
            \semarrow
            \langle\lambda x.e_{\lambda}, \ctx_{\lambda}\rangle \\
            (e_{2}, \ctx)
            \semarrow
            v
          \end{matrix}
        }
        \infer[left label={AppBody}]1{
        (e_{1}\:e_{2}, \ctx)
        \semarrow
        (e_{\lambda}, (x, v)\cons \ctx_{\lambda})
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx)
            \semarrow
            \langle\lambda x.e_{\lambda}, \ctx_{\lambda}\rangle \\
            (e_{2}, \ctx)
            \semarrow
            v                                                   \\
            (e_{\lambda}, (x, v)\cons \ctx_{\lambda})
            \semarrow
            v'
          \end{matrix}
        }
        \infer[left label={App}]1{
        (e_{1}\:e_{2}, \ctx)
        \semarrow
        v'
        }
      \end{prooftree}
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Operational Semantics (modules)}
  \begin{figure}[h!]
    \centering
    \scriptsize
    \begin{flushright}
      \fbox{$(e,\ctx)\semarrow V\text{ or }(e',\ctx')$}
    \end{flushright}
    \[
      \begin{prooftree}
        \infer[left label=Empty]0{
        (\varepsilon, \ctx)
        \semarrow
        \ctx
        }
      \end{prooftree}\qquad
      \begin{prooftree}
        \hypo{\ctx'=\ctx(\modid)}
        \infer[left label=ModID]1{
        (\modid, \ctx)
        \semarrow
        \ctx'
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \infer[left label=LetEL]0{
        (\mathtt{let}\:x\:e_1\:e_2, \ctx)
        \semarrow
        (e_{1}, \ctx)
        }
      \end{prooftree}\quad
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx)
            \semarrow
            v
          \end{matrix}
        }
        \infer[left label=LetER]1{
        (\mathtt{let}\:x\:e_1\:e_2, \ctx)
        \semarrow
        (e_{2}, (x, v)\cons \ctx)
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \infer[left label=LetML]0{
        (\mathtt{let}\:\modid\:e_{1}\:e_{2}, \ctx)
        \semarrow
        (e_{1}, \ctx)
        }
      \end{prooftree}\quad
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx)
            \semarrow
            \ctx'
          \end{matrix}
        }
        \infer[left label=LetMR]1{
        (\mathtt{let}\:\modid\:e_{1}\:e_{2}, \ctx)
        \semarrow
        (e_{2}, (\modid, \ctx')\cons \ctx)
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx)
            \semarrow
            v \\
            (e_{2}, (x, v)\cons \ctx)
            \semarrow
            \ctx'
          \end{matrix}
        }
        \infer[left label=LetE]1{
        (\mathtt{let}\:x\:e_1\:e_2, \ctx)
        \semarrow
        \ctx'
        }
      \end{prooftree}\quad
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx)
            \semarrow
            \ctx' \\
            (e_{2}, (\modid, \ctx')\cons \ctx)
            \semarrow
            \ctx''
          \end{matrix}
        }
        \infer[left label=LetM]1{
        (\mathtt{let}\:\modid\:e_{1}\:e_{2}, \ctx)
        \semarrow
        \ctx''
        }
      \end{prooftree}
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Operational Semantics (linking)}
  \begin{figure}[h!]
    \centering
    \scriptsize
    \begin{flushright}
      \fbox{$(e,\ctx)\semarrow V\text{ or }(e',\ctx')$}
    \end{flushright}
    \[
      \begin{prooftree}
        \infer[left label=LinkL]0{
        (\link{e_{1}}{e_{2}}, \ctx)
        \semarrow
        (e_{1}, \ctx)
        }
      \end{prooftree}\quad
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx)
            \semarrow
            \ctx'
          \end{matrix}
        }
        \infer[left label=LinkR]1{
        (\link{e_{1}}{e_{2}}, \ctx)
        \semarrow
        (e_{2}, \ctx')
        }
      \end{prooftree}\quad
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx)
            \semarrow
            \ctx' \\
            (e_{2}, \ctx')
            \semarrow
            V
          \end{matrix}
        }
        \infer[left label=Link]1{
        (\link{e_{1}}{e_{2}}, \ctx)
        \semarrow
        V
        }
      \end{prooftree}
    \]
  \end{figure}
\end{frame}
\section{Collecting Semantics \& Modularity}
\begin{frame}[c]
  \frametitle{Collecting Semantics}
  \[\Sigma\triangleq\Right\:+\:\semarrow\qquad\Trace\triangleq\pset(\Sigma)\]
  \begin{definition*}[Transfer function]
    Given $A\subseteq\Sigma$, define:
    \[
      \mathsf{Step}(A)\triangleq
      \left\{\config\semarrow\rightst, \rightst\middle|
      \begin{prooftree}[center=true]
        \hypo{A'}\infer1{\config\semarrow\rightst}
      \end{prooftree}\text{ and }
      A'\subseteq A\text{ and }\config\in A
      \right\}
    \]
  \end{definition*}
  \begin{definition*}[Collecting semantics]
    Given $e\in\Expr$ and $C\subseteq\Ctx$, define:
    \[
      \sembracket{e}C\triangleq\lfp(\lambda X.\mathsf{Step}(X)\cup\{(e,\ctx)|\ctx\in C\})
    \]
  \end{definition*}
\end{frame}
\begin{frame}[c]
  \frametitle{Modularity}
  \begin{theorem*}[Modularity]
    For all $e_1,e_2\in\Expr$ and $C,C_1,C_2\subseteq\Ctx$, we have:
    \[\sembracket{\link{e_1}{e_2}}C=C_1\semlink\sembracket{e_2}C_2\]
    where $C_1\rhd C_2=\sembracket{e_1}C$.
  \end{theorem*}
  $\sembracket{e_1}C$ (export) and $\sembracket{e_2}C_2$ (client) are separate
\end{frame}
\begin{frame}[c]
  \frametitle{The Modularity Theorem Hinges on the Advance Lemma}
  \begin{lemma*}[Advance]
    For all $e\in\Expr$ and $C_1,C_2\subseteq\Ctx$, $\sembracket{e}(C_1\rhd C_2)=C_1\semlink\sembracket{e}C_2$.
  \end{lemma*}
  Where:
  \begin{definition*}[Injection]
    For $C\subseteq\Ctx$ and $A\subseteq\Sigma$, define:
    \[C\rhd A\triangleq\{\inject{\ctx}{\rightst}|\ctx\in C,\rightst\in A\}\cup\{\inject{\ctx}{\config}\semarrow\inject{\ctx}{\rightst}|\ctx\in C,\config\semarrow\rightst\in A\}\]
  \end{definition*}
  \begin{definition*}[Semantic Linking]
    For $C\subseteq\Ctx$ and $A\subseteq \Sigma$, define:
    \[C\semlink A\triangleq\lfp(\lambda X.\Step(X)\cup(C\rhd A))\]
  \end{definition*}
\end{frame}
\begin{frame}[c]
  \frametitle{Injection}
  \begin{lemma*}[Injection Preserves $\semarrow$]\label{lem:injpreseval}
    $\forall\config\in\Config$, $\rightst\in\Right$, $\ctx\in\Ctx$,
    $\config\semarrow\rightst\Rightarrow\inject{\ctx}{\config}\semarrow\inject{\ctx}{\rightst}$
  \end{lemma*}

  Where:
    {\footnotesize
      \[
        \inject{\ctx_{1}}{r_{2}}\triangleq
        \begin{cases}
          \ctx_1                                                         & r_{2}=[]                           \\
          (x, \inject{\ctx_1}{v})\cons\inject{\ctx_{1}}{\ctx}            & r_{2}=(x,v)\cons \ctx              \\
          (\modid, \inject{\ctx_{1}}{\ctx})\cons\inject{\ctx_{1}}{\ctx'} & r_{2}=(\modid,\ctx)\cons \ctx'     \\
          \langle\lambda x.e,\inject{\ctx_1}{\ctx}\rangle                & r_2=\langle\lambda x.e,\ctx\rangle \\
          (e,\inject{\ctx_1}{\ctx})                                      & r_2 = (e, \ctx)
        \end{cases}
      \]}%
\end{frame}
\begin{frame}[c]
  \frametitle{A Trivial Case}
  For the trivial case when $C_2=\{[]\}$, we have:
  \begin{corollary*} For all $e_1,e_2\in\Expr$ and $C\subseteq\Ctx$, we have:
    \[\sembracket{\link{e_1}{e_2}}C=(\sembracket{e_1}C)\semlink\sembracket{e_2}\mt\]
    where $\mt=\{[]\}$.
  \end{corollary*}
\end{frame}
\begin{frame}[c]
  \frametitle{Skeleton for Static Analysis}
  Require $\Abs{\Trace},\Abs{\Step},\Abs{\rhd}$:
  \[\Trace=\pset(\Sigma)\galois{\alpha}{\gamma}\Abs{\Trace}\]
  \[\Step\circ\gamma\subseteq\gamma\circ\Abs\Step\qquad\rhd\circ(\gamma,\gamma)\subseteq\gamma\circ\Abs\rhd\]
  Define:
  \[\Abs{\sembracket{e}}\Abs{C}\triangleq\lfp(\lambda\Abs{X}.\Abs\Step(\Abs{X})\Abs\cup\alpha\{(e,\ctx)|\ctx\in\gamma\Abs{C}\})\]
  \[\Abs{C}\Abs\semlink\Abs{A}\triangleq\lfp(\lambda\Abs{X}.\Abs\Step(\Abs{X})\Abs\cup(\Abs{C}\Abs\rhd\Abs{A}))\]
  So that:
  \[\sembracket{e}\circ\gamma\subseteq\gamma\circ\Abs{\sembracket{e}}\qquad\semlink\circ(\gamma,\gamma)\subseteq\gamma\circ\Abs\semlink\]
\end{frame}
\section{Instrumented Collecting Semantics \& Modularity}
\begin{frame}[c]
  \frametitle{Semantic Domains}
  \begin{figure}[h!]
    \footnotesize
    \centering
    \begin{tabular}{rrcll}
      Time                         & $t$        & $\in$         & $\Time$                                                  \\
      Environment/Context          & $\ctx$     & $\in$         & $\Ctx$                                                   \\
      Value of expressions         & $v$        & $\in$         & $\Value \triangleq\ExprVar\times\Expr\times\Ctx$         \\
      Value of expressions/modules & $V$        & $\in$         & $\Value+\Ctx$                                            \\
      Memory                       & $\mem$     & $\in$         & $\Mem \triangleq \fin{\Time}{\Value}$                    \\
      State                        & $s$        & $\in$         & $\State \triangleq \Ctx\times\Mem\times\Time$            \\
      Outcome                      & $o$        & $\in$         & $\Outcome \triangleq (\Value+\Ctx)\times\Mem\times\Time$ \\
      Configuration (left)         & $\config$  & $\in$         & $\Config\triangleq\Expr\times\State$                     \\
      Configuration (right)        & $\rightst$ & $\in$         & $\Right\triangleq\Config+\Outcome$                       \\
      Context                      & $\ctx$     & $\rightarrow$ & []                                                       \\
                                   &            & $\vbar$       & $(x,t)\cons \ctx$                                        \\
                                   &            & $\vbar$       & $(\modid,\ctx)\cons \ctx$                                \\
      Value of expressions         & $v$        & $\rightarrow$ & $\langle \lambda x.e, \ctx \rangle$\end{tabular}
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{$\Time$ and $\tick$}
  Parametrized by choice of the set $\Time$(Time) and the function $\tick$.
  \begin{itemize}
    \item $\Time$: Timestamps for program states, used as addresses.
    \item $\tick$: Produces fresh timestamps.
  \end{itemize}
  Freshness: \emph{total order} on $\Time$
  \[t < \tick(t)\]
  \[\State\triangleq\{(\ctx,\mem,t)|\ctx\le t\text{ and }\mem\le t\}\]
  \[\Outcome\triangleq\{(V,\mem,t)|V\le t\text{ and }\mem\le t\}\]
\end{frame}
\begin{frame}[c]
  \frametitle{Operational Semantics (1/2)}
  \begin{figure}[t!]
    \scriptsize
    \begin{flushright}
      \fbox{$(e,\ctx,\mem,t)\semarrow(V,\mem',t')\text{ or }(e',\ctx',\mem',t')$}
    \end{flushright}
    \centering
    \vspace{0pt} % -0.75em}
    \[
      \begin{prooftree}
        \hypo{t_{x}={\ctx}(x)}
        \hypo{v=\mem(t_{x})}
        \infer[left label=ExprID]2{
        (x, \ctx, \mem, t)
        \semarrow
        (v, \mem, t)
        }
      \end{prooftree}\qquad
      \begin{prooftree}
        \infer[left label=Fn]0{
        (\lambda x.e, \ctx, \mem, t)
        \semarrow
        (\langle\lambda x.e, \ctx\rangle, \mem, t)
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx, \mem, t)
            \semarrow
            (\langle\lambda x.e_{\lambda}, \ctx_{\lambda}\rangle, \mem_{\lambda}, t_{\lambda}) \\
            (e_{2}, \ctx, \mem_{\lambda}, t_{\lambda})
            \semarrow
            (v, \mem_{a}, t_{a})                                                               \\
            (e_{\lambda}, (x, \tick(t_{a}))\cons \ctx_{\lambda}, \mem_{a}[\tick(t_{a})\mapsto v], \tick(t_a))
            \semarrow
            (v', \mem',t')
          \end{matrix}
        }
        \infer[left label={App}]1{
        (e_{1}\:e_{2}, \ctx, \mem, t)
        \semarrow
        (v', \mem',t')
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx, \mem, t)
            \semarrow
            (\ctx', \mem', t') \\
            (e_{2}, \ctx', \mem', t')
            \semarrow
            (V, \mem'', t'')
          \end{matrix}
        }
        \infer[left label=Link]1{
        (\link{e_{1}}{e_{2}}, \ctx, \mem, t)
        \semarrow
        (V, \mem'', t'')
        }
      \end{prooftree}\qquad
      \begin{prooftree}
        \infer[left label=Empty]0{
        (\varepsilon, \ctx, \mem, t)
        \semarrow
        (\ctx, \mem, t)
        }
      \end{prooftree}
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Operational Semantics (2/2)}
  \begin{figure}[h!]
    \scriptsize
    \begin{flushright}
      \fbox{$(e,\ctx,\mem,t)\semarrow(V,\mem',t')\text{ or }(e',\ctx',\mem',t')$}
    \end{flushright}
    \centering
    \[
      \begin{prooftree}
        \hypo{\ctx'={\ctx}(\modid)}
        \infer[left label=ModID]1{
        (\modid, \ctx, \mem, t)
        \semarrow
        (\ctx', \mem, t)
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx, \mem, t)
            \semarrow
            (v, \mem', t') \\
            (e_{2}, (x, \tick(t'))\cons \ctx, \mem'[\tick(t')\mapsto v], \tick(t'))
            \semarrow
            (\ctx', \mem'', t'')
          \end{matrix}
        }
        \infer[left label=LetE]1{
        (\mathtt{let}\:x\:e_1\:e_2, \ctx, \mem, t)
        \semarrow
        (\ctx', \mem'', t'')
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \ctx, \mem, t)
            \semarrow
            (\ctx', \mem', t') \\
            (e_{2}, (\modid, \ctx')\cons \ctx, \mem', t')
            \semarrow
            (\ctx'', \mem'', t'')
          \end{matrix}
        }
        \infer[left label=LetM]1{
        (\mathtt{let}\:\modid\:e_{1}\:e_{2}, \ctx, \mem, t)
        \semarrow
        (\ctx'', \mem'', t'')
        }
      \end{prooftree}
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Collecting Semantics}
  \[\Sigma\triangleq\Right\:+\:\semarrow\qquad\Trace\triangleq\pset(\Sigma)\]
  \begin{definition*}[Transfer function]
    Given $A\subseteq \Sigma$, define
    \[
      \mathsf{Step}(A)\triangleq
      \left\{\config\semarrow\rightst, \rightst\middle|
      \begin{prooftree}[center=true]
        \hypo{A'}\infer1{\config\semarrow\rightst}
      \end{prooftree}\text{ and }
      A'\subseteq A\text{ and }\config\in A
      \right\}
    \]
  \end{definition*}
  \begin{definition*}[Collecting semantics]
    Given $e\in\Expr$ and $S\subseteq\State$, define:
    \[
      \sembracket{e}S\triangleq\lfp(\lambda X.\mathsf{Step}(X)\cup\{(e,s)|s\in S\})
    \]
  \end{definition*}
\end{frame}
\begin{frame}[c]
  \frametitle{Linking Timestamps}
  \[
    \Time_{\semlink}\triangleq\Time_1+\Time_2\quad
    \le_{\semlink}\triangleq\text{lexicographic order}\quad
    \tick_{\semlink}(t)\triangleq
    \begin{cases}
      \tick_1(t) & t\in\Time_1 \\
      \tick_2(t) & t\in\Time_2
    \end{cases}
  \]

  \begin{notation*}
    All sets with the subscript $i(i=1,2)$ is assumed to be using $\Time_i$ as timestamps, and all sets with the subscript $\semlink$ is assumed to be using $\Time_{\semlink}$ as timestamps.
  \end{notation*}
\end{frame}
\begin{frame}[c]
  \frametitle{Injection}
  \begin{lemma*}[Injection Preserves $\semarrow$]
    For all $s_1\in\State_1$, $\config_2\in\Config_2$, $\rightst_2\in\Right_2$,
    \[\config_2\semarrow_2\rightst_2\Rightarrow\inject{s_1}{\config_2}\semarrow_{\semlink}\inject{s_1}{\rightst_2}\]
  \end{lemma*}

  Where:
    {\footnotesize
      \[
        \begin{array}{cc}
          \inject{\ctx_{1}}{V_{2}}\triangleq
          \begin{cases}
            \ctx_1                                                         & V_{2}=[]                               \\
            (x, t)\cons\inject{\ctx_{1}}{\ctx}                             & V_{2}=(x,t)\cons \ctx                  \\
            (\modid, \inject{\ctx_{1}}{\ctx})\cons\inject{\ctx_{1}}{\ctx'} & V_{2}=(\modid,\ctx)\cons \ctx'         \\
            \langle\lambda x.e,\inject{\ctx_1}{\ctx_2}\rangle              & V_{2}=\langle\lambda x.e,\ctx_2\rangle
          \end{cases} &
          \begin{array}{l}
            \inject{\ctx_1}{\mem_2}\triangleq
            \displaystyle\bigcup_{t\in\mathsf{dom}(\mem_2)}\{t\mapsto\inject{\ctx_1}{\mem_2(t)}\} \\ \\
            \inject{s_1}{o_2}\triangleq
            (\inject{\ctx_1}{V_2},\mem_1\cup\inject{\ctx_1}{\mem_2},t_2)
          \end{array}
        \end{array}
      \]}%
\end{frame}
\begin{frame}[c]
  \frametitle{Semantic Linking}
  \begin{definition*}[Injection]
    For $S_1\subseteq\State_1$ and $A_2\subseteq\Sigma_2$, define:
    \begin{align*}
      S_1\rhd A_2 \triangleq & \{\inject{s_1}{\rightst_2}|s_1\in S_1,\rightst_2\in A_2\}\cup                                                            \\
                             & \{\inject{s_1}{\config_2}\semarrow_{\semlink}\inject{s_1}{\rightst_2}|s_1\in S_1,\config_2\semarrow_2\rightst_2\in A_2\}
    \end{align*}
  \end{definition*}
  \begin{definition*}[Semantic Linking]
    For $S_1\subseteq\State_1$ and $A_2\subseteq\Sigma_2$, define:
    \[
      S_1\semlink A_2\triangleq\lfp(\lambda X.\Step_{\semlink}(X)\cup(S_1\rhd A_2))
    \]
  \end{definition*}
\end{frame}
\begin{frame}[c]
  \frametitle{Advance Lemma}
  \begin{lemma*}[Advance]
    For all $e\in\Expr$ and $S_1\subseteq\State_1$, $S_2\subseteq\State_2$,
    \[
      \sembracket{e}(S_1\rhd S_2)=S_1\semlink\sembracket{e}S_2
    \]
  \end{lemma*}
\end{frame}
\begin{frame}[c]
  \frametitle{The Same Modularity Theorem}
  \begin{theorem*}[Modularity]
    For all $e_1,e_2\in\Expr$ and $S\subseteq\State,S_i\subseteq\State_i(i=1,2)$, we have:
    \[\sembracket{\link{e_1}{e_2}}S\equivalent S_1\semlink\sembracket{e_2}S_2\]
    where $S_1\rhd S_2\equivalent\sembracket{e_1}S$.
  \end{theorem*}
  Note, no longer: $\sembracket{\link{e_1}{e_2}}S=(\sembracket{e_1}S)\semlink\sembracket{e_2}\mt$

  since $\underbrace{\sembracket{e_1}S\rhd\mt}_{\text{linked timestamp}}\neq\underbrace{\sembracket{e_1}S}_{\text{not linked}}$.
  \begin{center}
    \fbox{Need to replace $=$ with $\equivalent$}

    \fbox{$\equivalent$: Defined later}
  \end{center}
\end{frame}
\section{Abstracting the Instrumented Collecting Semantics \&\\ Modular Analysis}
\begin{frame}[c]
  \frametitle{Semantic Domains}
  \begin{figure}[h!]
    \footnotesize
    \centering
    \begin{tabular}{rrcll}
      Abstract Time                  & $\A{t}$        & $\in$         & $\A{\Time}$                                                                 \\
      Environment/Context            & $\A{\ctx}$     & $\in$         & $\A{\Ctx}$                                                                  \\
      Value of expressions           & $\A{v}$        & $\in$         & $\A{\Value} \triangleq \ExprVar\times\Expr\times\A{\Ctx}$                   \\
      Value of expressions/modules   & $\A{V}$        & $\in$         & $\A{\Value}+\A{\Ctx}$                                                       \\
      Abstract Memory                & $\A{\mem}$     & $\in$         & $\A{\Mem} \triangleq \fin{\A{\Time}}{\pset(\A{\Value})}$                    \\
      Abstract State                 & $\A{s}$        & $\in$         & $\A{\State} \triangleq \A{\Ctx}\times\A{\Mem}\times\A{\Time}$               \\
      Abstract outcome               & $\A{o}$        & $\in$         & $\A{\Outcome} \triangleq(\A{\Value}+\A{\Ctx})\times\A{\Mem}\times\A{\Time}$ \\
      Abstract configuration (left)  & $\A{\config}$  & $\in$         & $\A{\Config}\triangleq\Expr\times\A{\State}$                                \\
      Abstract configuration (right) & $\A{\rightst}$ & $\in$         & $\A{\Right}\triangleq\A{\Config}+\A{\Outcome}$                              \\
      Context                        & $\A{\ctx}$     & $\rightarrow$ & []                                                                          \\
                                     &                & $\vbar$       & $(x,\A{t})\cons \A{\ctx}$                                                   \\
                                     &                & $\vbar$       & $(\modid,\A{\ctx})\cons \A{\ctx}$                                           \\
      Value of expressions           & $\A{v}$        & $\rightarrow$ & $\langle \lambda x.e, \A{\ctx} \rangle$
    \end{tabular}
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{$\Time$ and $\tick$}
  Parametrized by choice of the set $\A\Time$(Time) and the function $\A\tick$.
  \begin{itemize}
    \item $\A\Time$: Timestamps for program states, used as addresses.
    \item $\A\tick$: Satisfies $\A\alpha\circ\tick=\A\tick\circ\A\alpha$.
  \end{itemize}
\end{frame}
\begin{frame}[c]
  \frametitle{Operational Semantics (that differ from the concrete)}
  \begin{figure}[t!]
    \scriptsize
    \begin{flushright}
      \fbox{$(e,\A{\ctx},\A\mem,\A{t})\A\semarrow(\A{V},\A{\mem'},\A{t'})\text{ or }(e',\A{\ctx'},\A{\mem'},\A{t'})$}
    \end{flushright}
    \vspace{0pt} % -0.75em}
    \[
      \begin{prooftree}
        \hypo{\A{t_x}=\A{\ctx}(x)}
        \hypo{\A{v}\in\A\mem(\A{t_x})}
        \infer[left label=ExprID]2{
        (x, \A{\ctx}, \A\mem, \A{t})
        \A\semarrow
        (\A{v}, \A\mem, \A{t})
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \A{\ctx}, \A\mem, \A{t})
            \A\semarrow
            (\langle\lambda x.e_{\lambda}, \A{\ctx}_{\lambda}\rangle, \A\mem_{\lambda}, \A{t_\lambda}) \\
            (e_{2}, \A{\ctx}, \A\mem_{\lambda}, \A{t_\lambda})
            \A\semarrow
            (\A{v}, \A\mem_{a}, \A{t_a})                                                               \\
            (e_{\lambda}, (x, \A\tick(\A{t_a}))\cons \A{\ctx}_{\lambda}, \A\mem_{a}[\A\tick(\A{t_a})\A\mapsto \A{v}], \A\tick(\A{t_a}))
            \A\semarrow
            (\A{v'}, \A{\mem'},\A{t'})
          \end{matrix}
        }
        \infer[left label={App}]1{
        (e_{1}\:e_{2}, \A{\ctx}, \A\mem, \A{t})
        \A\semarrow
        (\A{v'}, \A{\mem'},\A{t'})
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, \A{\ctx}, \A\mem, \A{t})
            \A\semarrow
            (\A{v}, \A{\mem'}, \A{t'}) \\
            (e_{2}, (x, \A\tick(\A{t'}))\cons \A{\ctx}, \A{\mem'}[\A\tick(\A{t'})\A\mapsto \A{v}], \A\tick(\A{t'}))
            \A\semarrow
            (\A{\ctx'}, \A{\mem''}, \A{t''})
          \end{matrix}
        }
        \infer[left label=LetE]1{
        (\mathtt{let}\:x\:e_1\:e_2, \A{\ctx}, \A\mem, \A{t})
        \A\semarrow
        (\A{\ctx'}, \A{\mem''}, \A{t''})
        }
      \end{prooftree}
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Abstraction and Concretization}
  \[\A\Sigma\triangleq\A\Right\:+\:\A\semarrow\qquad\Abs{\Trace}\triangleq\pset(\A\Sigma)\]
  \begin{definition*}
    Define $\alpha:\Trace\rightarrow\Abs{\Trace}$ and $\gamma:\Abs{\Trace}\rightarrow \Trace$ by:
    \begin{align*}
      \alpha(A)       & \triangleq\{\A\alpha(\config)\asemarrow\A\alpha(\rightst)|\config\semarrow\rightst\in A\}\cup\{\A\alpha(\rightst)|\rightst\in A\}           \\
      \gamma(\Abs{A}) & \triangleq\{\config\semarrow\rightst|\A\alpha(\config)\asemarrow\A\alpha(\rightst)\in\Abs{A}\}\cup\{\rightst|\A\alpha(\rightst)\in\Abs{A}\}
    \end{align*}
  \end{definition*}
\end{frame}
\begin{frame}[c]
  \frametitle{Abstract Semantics}
  \begin{definition*}[Abstract transfer function]
    Given $\Abs{A}\subseteq\A{\Sigma}$, define:
    \[
      \Abs{\mathsf{Step}}(\Abs{A})\triangleq
      \left\{\A\config\A\semarrow\A\rightst, \A\rightst\middle|
      \begin{prooftree}[center=true]
        \hypo{\Abs{A'}}\infer1{\A\config\A\semarrow\A\rightst}
      \end{prooftree}\text{ and }
      \Abs{A'}\subseteq \Abs{A}\text{ and }\A\config\in\Abs{A}
      \right\}
    \]
  \end{definition*}
  \begin{definition*}[Abstract semantics]
    Given $e\in\Expr$ and $\Abs{S}\subseteq\A\State$, define:
    \[
      \Abs{\sembracket{e}}\Abs{S}\triangleq\lfp(\lambda \Abs{X}.\Abs{\mathsf{Step}}(\Abs{X})\cup\{(e,\A{s})|\A{s}\in \Abs{S}\})
    \]
  \end{definition*}
\end{frame}
\begin{frame}[c]
  \frametitle{Soundness}
  \begin{lemma*}[Galois Connection]
    \[\Trace=\pset(\Sigma)\galois{\alpha}{\gamma}\Abs{\Trace}=\pset(\A\Sigma)\]
  \end{lemma*}
  \begin{lemma*}[Operational Soundness]\label{lem:opsound}
    For all $\config\in\Config$ and $\rightst\in\Right$, $\config\semarrow\rightst\Rightarrow\A\alpha(\config)\A\semarrow\A\alpha(\rightst)$
  \end{lemma*}
  \begin{theorem*}[Soundness]
    For all $e\in\Expr$, $\sembracket{e}\circ\gamma\subseteq\gamma\circ\Abs{\sembracket{e}}$
  \end{theorem*}
\end{frame}
\begin{frame}[c]
  \frametitle{Finiteness}
  \begin{theorem*}[Finiteness]\label{thm:absfinite}
    For all $e\in\Expr$, if $\A\Time$ and $\Abs{S}\subseteq\A\State$ is finite, $\Abs{\sembracket{e}}\Abs{S}$ is finite.
  \end{theorem*}
\end{frame}
\begin{frame}[c]
  \frametitle{Linking Timestamps}
  \[
    \A\Time_{\semlink}\triangleq\A\Time_1+\A\Time_2\quad
    \A\tick_{\semlink}(\A{t})\triangleq
    \begin{cases}
      \A\tick_1(\A{t}) & \A{t}\in\A\Time_1 \\
      \A\tick_2(\A{t}) & \A{t}\in\A\Time_2
    \end{cases}\quad
    \A\alpha_{\semlink}(t)\triangleq
    \begin{cases}
      \A\alpha_1(t) & t\in\Time_1 \\
      \A\alpha_2(t) & t\in\Time_2
    \end{cases}
  \]
  \begin{notation*}
    All sets with the subscript $i(i=1,2)$ is assumed to be using $\A\Time_i$ as timestamps, and all sets with the subscript $\semlink$ is assumed to be using $\A\Time_{\semlink}$ as timestamps.
  \end{notation*}
\end{frame}
\begin{frame}[c]
  \frametitle{Injection}
  \begin{lemma}[Injection Preserves $\A\semarrow$]\label{lem:injpresaval}
    For all $\A{s}_1\in\A\State_1$, $\A\config_2\in\A\Config_2$, $\A\rightst\in\A\Right_2$,
    \[\A\config_2\A\semarrow_2\A\rightst_2\Rightarrow\inject{\A{s}_1}{\A\config_2}\A\semarrow_{\semlink}\inject{\A{s}_1}{\A\rightst_2}\]
  \end{lemma}

  \[\inject{\A{\ctx}_1}{\A\mem_2}\triangleq\lambda\A{t}.\{\inject{\A{\ctx}_1}{\A{v}_2}|\A{v}_2\in\A\mem_2(\A{t})\}\]
  Where $\inject{\A\ctx_1}{\A{v}_2}$ is the same as concrete injection.
\end{frame}
\begin{frame}[c]
  \frametitle{Semantic Linking}
  \begin{definition*}[Abstract Injection]
    For $\Abs{S}_1\subseteq\A\State_1$ and $\Abs{A}_2\subseteq\A{\Sigma}_2$, define:
    \begin{align*}
      \Abs{S}_1\Abs\rhd\Abs{A}_2\triangleq & \{\inject{\A{s}_1}{\A\rightst_2}|\A{s}_1\in\Abs{S}_1,\A\rightst_2\in\Abs{A}_2\}\cup                                                                        \\
                                           & \{\inject{\A{s}_1}{\A\config_2}\A\semarrow_{\semlink}\inject{\A{s}_1}{\A\rightst_2}|\A{s}_1\in\Abs{S}_1,\A\config_2\A\semarrow_2\A\rightst_2\in\Abs{A}_2\}
    \end{align*}
  \end{definition*}
  \begin{definition*}[Abstract Linking]
    For $\Abs{S}_1\subseteq\A\State_1$ and $\Abs{A}_2\subseteq\A{\Sigma}_2$, define:
    \[
      \Abs{S}_1\Abs\semlink\Abs{A}_2\triangleq\lfp(\lambda\Abs{X}.\Abs\Step_{\semlink}(\Abs{X})\cup(\Abs{S}_1\Abs\rhd\Abs{A}_2))
    \]
  \end{definition*}
\end{frame}
\begin{frame}[c]
  \frametitle{Advance Lemma}
  \begin{lemma*}[Abstract Advance]\label{thm:absadvance}
    For all $e\in\Expr$ and $\Abs{S}_1\subseteq\A\State_1$, $\Abs{S}_2\subseteq\A\State_2$,
    \[
      \Abs{\sembracket{e}}(\Abs{S}_1\Abs\rhd\Abs{S}_2)=\Abs{S}_1\Abs\semlink\Abs{\sembracket{e}}\Abs{S}_2
    \]
  \end{lemma*}
\end{frame}
\begin{frame}[c]
  \frametitle{Soundness}
  \begin{corollary*}[Correctness of $\Abs{\semlink}$]
    For all $e\in\Expr$ and $S_1\subseteq\State_1$, $S_2\subseteq\State_2$,
    \[S_1\semlink\sembracket{e}S_2\subseteq\gamma_{\semlink}(\alpha_1(S_1)\Abs\semlink\Abs{\sembracket{e}}\alpha_2(S_2))\]
  \end{corollary*}
\end{frame}
\section{Soundness Proof :\\Modular Analysis + Linking \texorpdfstring{$\equivalent$}{a} Monolithic Analysis}
\begin{frame}[c]
  \frametitle{Access Paths}
  \scriptsize
  \begin{columns}
    \begin{column}{0.3\linewidth}
      \begin{tabular}{|rcl|r}
        \hline
        $p$                                   & $\rightarrow$ & $\epsilon$                              \\
                                              & $|$           & $\xrightarrow{x}t\:p$                   \\
                                              & $|$           & $\xrightarrow{\modid}p$                 \\
                                              & $|$           & $\xrightarrow{\lambda x.e}p$            \\
        $\varphi(\epsilon)$                   & $\triangleq$  & $\epsilon$                              \\
        $\varphi(\xrightarrow{x}t\:p)$        & $\triangleq$  & $\xrightarrow{x}\varphi(t)\:\varphi(p)$ \\
        $\varphi(\xrightarrow{M}p)$           & $\triangleq$  & $\xrightarrow{M}\varphi(p)$             \\
        $\varphi(\xrightarrow{\lambda x.e}p)$ & $\triangleq$  & $\xrightarrow{\lambda x.e}\varphi(p)$   \\
        \hline
      \end{tabular}
    \end{column}
    \begin{column}{0.05\linewidth}
    \end{column}
    \begin{column}{0.3\linewidth}
      \scriptsize
      \[
        \begin{prooftree}
          \infer0{\valid(\_,\mem,\epsilon)}
        \end{prooftree}
      \]
      \[
        \begin{prooftree}
          \hypo{t=\ctx(x)\qquad\valid(t,\mem,p)}
          \infer1{\valid(\ctx,\mem,\xrightarrow{x}t\:p)}
        \end{prooftree}
      \]
      \[
        \begin{prooftree}
          \hypo{\ctx'=\ctx(\modid)\qquad\valid(\ctx',\mem,p)}
          \infer1{\valid(\ctx,\mem,\xrightarrow{\modid}p)}
        \end{prooftree}
      \]
      \[
        \begin{prooftree}
          \hypo{\langle\lambda x.e,{\ctx}\rangle=\mem(t)\qquad\valid(\ctx,\mem,p)}
          \infer1{\valid(t,\mem,\xrightarrow{\lambda x.e}p)}
        \end{prooftree}
      \]
    \end{column}
    \begin{column}{0.3\linewidth}
      \scriptsize
      \[
        \begin{prooftree}
          \infer0{\A\valid(\_,\A\mem,\epsilon)}
        \end{prooftree}
      \]
      \[
        \begin{prooftree}
          \hypo{\A{t}=\A\ctx(x)\qquad\A\valid(\A{t},\A\mem,\A{p})}
          \infer1{\A\valid(\A\ctx,\A\mem,\xrightarrow{x}\A{t}\:\A{p})}
        \end{prooftree}
      \]
      \[
        \begin{prooftree}
          \hypo{\A\ctx'=\A\ctx(\modid)\qquad\A\valid(\A\ctx',\A\mem,\A{p})}
          \infer1{\A\valid(\A\ctx,\A\mem,\xrightarrow{\modid}\A{p})}
        \end{prooftree}
      \]
      \[
        \begin{prooftree}
          \hypo{\langle\lambda x.e,{\A\ctx}\rangle\in\A\mem(\A{t})\qquad\A\valid(\A\ctx,\A\mem,\A{p})}
          \infer1{\A\valid(\A{t},\A\mem,\xrightarrow{\lambda x.e}\A{p})}
        \end{prooftree}
      \]
    \end{column}
  \end{columns}
\end{frame}
\begin{frame}[c]
  \frametitle{Equivalent Concrete States}
  \begin{definition*}[Equivalent Concrete States: $\equivalent$]
    Let $s=(\ctx,\mem,\_)\in\State$ and $s'=(\ctx',\mem',\_)\in\State'$.
    $s\equivalent s'$ ($s$ is equivalent to $s'$) iff $\exists\varphi\in\Time\rightarrow\Time',\varphi'\in\Time'\rightarrow\Time:$
    \begin{enumerate}
      \item $\forall p\in\Path:\valid(\ctx,\mem,p)\Rightarrow(\valid(\ctx',\mem',\varphi(p))\land p=\varphi'(\varphi(p)))$
      \item $\forall p'\in\Path':\valid(\ctx',\mem',p')\Rightarrow(\valid(\ctx,\mem,\varphi'(p'))\land p'=\varphi(\varphi'(p')))$
    \end{enumerate}
  \end{definition*}
\end{frame}
\begin{frame}[c]
  \frametitle{Concretization Preserves Equivalence}
  \begin{lemma*}[Concretization Preserves Equivalence]\label{lem:concreteqiuv}
    Assume that each $\A{t},\A{t'}$ in $\ATime,\A{\Time'}$ corresponds to an infinite set of concrete timestamps.
    Then for all $\Abs{S}\subseteq\AState$ and $\Abs{S'}\subseteq\A{\State'}$,
    \[\Abs{S}\Abs\equivalent\Abs{S'}\Rightarrow\gamma(\Abs{S})\equivalent\gamma'(\Abs{S'})\]
  \end{lemma*}
\end{frame}
\begin{frame}[c]
  \frametitle{Evaluation Preserves Equivalence}
  \begin{lemma*}[Evaluation Preserves Equivalence]
    For all $\config\in\Config$, $\rightst\in\Right$, $\config'\in\Config'$,
    \[\config\semarrow\rightst\text{ and }\config\equivalent\config'\Rightarrow\exists\rightst':\config'\semarrow\rightst'\text{ and }\rightst\equivalent\rightst'\]
    Thus, if $S\subseteq\State$ and $S'\subseteq\State'$ are equivalent, $\sembracket{e}S\equivalent\sembracket{e}S'$.
  \end{lemma*}
\end{frame}
\begin{frame}[c]
  \frametitle{Soundness of Modular Analysis}
  Given $\Abs{S}\subseteq\A\Sigma$,
  if $\Abs{S}_1\Abs\rhd\Abs{S}_2\Abs\equivalent\Abs{S}$:
  \begin{align*}
    \sembracket{e}\gamma(\Abs{S}) & \equivalent\sembracket{e}\gamma_{\semlink}(\Abs{S}_1\Abs\rhd\Abs{S}_2)       & (\because\gamma,\semarrow\text{ preserves equivalence}) \\
                                  & \subseteq\gamma_{\semlink}(\Abs{\sembracket{e}}(\Abs{S}_1\Abs\rhd\Abs{S}_2)) & (\because\text{Soundness})                              \\
                                  & =\gamma_{\semlink}(\Abs{S}_1\Abs\semlink\Abs{\sembracket{e}}\Abs{S}_2)       & (\because\text{Abstract advance})
  \end{align*}
  Where $\gamma_{\semlink}$ is derived from:
  \[\Time_{\semlink}\triangleq\mathbb{Z}\times(\ATime_1+\ATime_2)\qquad\tick_{\semlink}(n,\A{t})\triangleq(n+1,\A\tick_{\semlink}(\A{t}))\qquad\A\alpha_{\semlink}(n,\A{t})\triangleq\A{t}\]
\end{frame}
\section{Extension : Parametrized Modules (Functors)}
\begin{frame}[c]
  \frametitle{Syntax}
  \begin{figure}[h!]
    \footnotesize
    \centering
    \begin{tabular}{rrcll}
      Identifiers & $x,\modid$ & $\in$         & $\ExprVar$                                                                                                    \\
      Signature   & $s$        & $\in$         & $\Sig$                                                                                                        \\
      Signature   & $s$        & $\rightarrow$ & $[]$ $\vbar$ $x\cons s$ $\vbar$ $(\modid,s)\cons s$                                                           \\
      Expression  & $e$        & $\rightarrow$ & $x$ $\vbar$ $\lambda x.e$ $\vbar$ $e$ $e$                               & untyped $\lambda$-calculus          \\
                  &            & $\vbar$       & $\modid$ $\vbar$ $\lambda\modid\project s.e$ $\vbar$ $(e\:e)\project s$ & module calculus, constrained by $s$ \\
                  &            & $\vbar$       & $\link{e}{e}$                                                           & linked expression                   \\
                  &            & $\vbar$       & $\varepsilon$                                                           & empty module
    \end{tabular}
  \end{figure}
  \begin{center}
    \fbox{The same theorems hold}
  \end{center}
\end{frame}
\end{document}
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:
