%! TEX program = xelatex
% \PassOptionsToPackage{draft}{graphicx}
\documentclass{beamer}

\usepackage{kotex}
\usepackage{xcolor}
\usepackage{tcolorbox}

\usepackage{setspace} % setstretch

\usepackage{tabularray}
\UseTblrLibrary{booktabs}
\UseTblrLibrary{counter}

%%% Math settings
\usepackage{amssymb,amsmath,mathtools} % Before unicode-math
\usepackage[math-style=TeX,bold-style=TeX]{unicode-math}

%%% Font settings
\setmainfont{Libertinus Serif}
\setmathfont{Libertinus Math} % Before set*hangulfont
\setmathfont{TeX Gyre Pagella Math}[range={\lbrace,\rbrace},Scale=1.1]
\setmainhangulfont{Noto Serif CJK KR}
\setsanshangulfont[BoldFont={* Bold}]{KoPubWorld Dotum.ttf}

%%% PL constructs
\usepackage{ebproof}
\ebproofset{left label template=\textsc{[\inserttext]}}
\ebproofset{center=false}

% For simplebnf
\newfontfamily{\fallbackfont}{EB Garamond}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\usepackage{newunicodechar}
\newunicodechar{⩴}{\textfallback{⩴}}

\usepackage{simplebnf}
\RenewDocumentCommand\SimpleBNFDefEq{}{\ensuremath{⩴}}

%%% Custom commands
\newcommand*{\vbar}{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{⩴}}
\newcommand*{\ortype}{\mathrel{|}}
\newcommand*{\cons}{::}

\def\ovbarw{1.2mu}
\def\ovbarh{1}
\newcommand*{\ovbar}[1]{\mkern \ovbarw\overline{\mkern-\ovbarw{\smash{#1}\scalebox{1}[\ovbarh]{\vphantom{i}}}\mkern-\ovbarw}\mkern \ovbarw}
\newcommand*{\A}[1]{{#1}^{\#}}
\newcommand*{\Expr}{\text{Expr}}
\newcommand*{\ExprVar}{\text{Var}}
\newcommand*{\Module}{\text{Module}}
\newcommand*{\ModVar}{\text{ModVar}}
\newcommand*{\Time}{\mathbb{T}}
\newcommand*{\ATime}{\A{\Time}}
\newcommand*{\Ctx}{\text{Ctx}}
\newcommand*{\Value}{\text{Val}}
\newcommand*{\Mem}{\text{Mem}}
\newcommand*{\Left}{\text{L}}
\newcommand*{\Right}{\text{R}}
\newcommand*{\mem}{m}
\newcommand*{\AMem}{\A{\text{Mem}}}
\newcommand*{\State}{\text{State}}
\newcommand*{\AState}{\A{\text{State}}}
\newcommand*{\Result}{\text{Result}}
\newcommand*{\AResult}{\A{\text{Result}}}
\newcommand*{\Tick}{\text{Tick}}
\newcommand*{\semarrow}{\rightsquigarrow}
\newcommand*{\semlink}{\mathbin{\rotatebox[origin=c]{180}{$\propto$}}}
\newcommand*{\link}[2]{{#1}\semlink{#2}}
\newcommand*{\mt}{\mathsf{empty}}

\newcommand*{\doubleplus}{\ensuremath{\mathbin{+\mkern-3mu+}}}
\newcommand*{\project}{\text{\texttt{:>} }}
\newcommand*{\Exp}{\mathsf{Exp}}
\newcommand*{\Imp}{\mathsf{Imp}}
\newcommand*{\Fin}{\mathsf{Fin}}
\newcommand*{\Link}{\mathsf{Link}}
\newcommand*{\sembracket}[1]{\lBrack{#1}\rBrack}
\newcommand*{\fin}[2]{{#1}\xrightarrow{\text{fin}}{#2}}
\newcommand*{\addr}{\mathsf{addr}}
\newcommand*{\tick}{\mathsf{tick}}
\newcommand*{\modctx}{\mathsf{ctx}}
\newcommand*{\mapinject}[2]{{#2}[{#1}]}
\newcommand*{\inject}[2]{{#2}\langle{#1}\rangle}
\newcommand*{\deletepre}[2]{{#2}\overline{\doubleplus}{#1}}
\newcommand*{\deletemap}[2]{{#1}\overline{[{#2}]}}
\newcommand*{\delete}[2]{{#2}{\langle{#1}\rangle}^{-1}}
\newcommand*{\filter}{\mathsf{filter}}
\newcommand*{\Let}{\mathtt{let}}

%%%%%%%%%%%%%%%%%%%%%
%  Beamer Settings  %
%%%%%%%%%%%%%%%%%%%%%
\usetheme[numbering=fraction,progressbar=frametitle]{metropolis}
\useoutertheme[subsection=false]{miniframes}
\usecolortheme{rose}

\setbeamertemplate{itemize item}[square]
\setbeamertemplate{itemize subitem}[triangle]
\setbeamertemplate{itemize subsubitem}[circle]

\usepackage{listings}
\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily\footnotesize
}
\lstset{style=mystyle}

\usepackage{pgfplots}
\usetikzlibrary{shapes,arrows}

\usepackage{adjustbox}
\newcommand{\cfbox}[1]{\adjustbox{cfbox=#1}}

\title{모듈별 프로그램 따로 분석}
\author{이준협}
\date{2023년 8월 4일}
\institute{ROPAS Show \& Tell}

\titlegraphic{%
  \begin{tikzpicture}[overlay,remember picture]
    \node at (current page.145) [xshift=3em, yshift=-1.3em] {
      \includegraphics[width=3em]{snu-symbol.png}
    };
    \node at (current page.35) [xshift=-3em, yshift=-1.3em] {
      \includegraphics[width=2.5em]{ropas-symbol.png}
    };
  \end{tikzpicture}%
}

\begin{document}
\maketitle
\begin{frame}[c]
  \frametitle{Problem Statement}
  \begin{itemize}
    \item Given two program segments $e_1$ and $e_2$,
    \item Want to derive a sound approximation of what ${\link{e_1}{e_2}}$ evaluates to, by \emph{separately} analyzing $e_1$ and $e_2$.
  \end{itemize}
\end{frame}
\begin{frame}{Overview}
  \tableofcontents
\end{frame}
\section{Abstract Syntax}
\begin{frame}[c]
  \frametitle{Abstract Syntax}
  \begin{figure}[h!]
    \centering
    \begin{tabular}{rrcll}
      Identifiers & $x,M$ & $\in$         & $\ExprVar$                              \\
      Expression  & $e$   & $\rightarrow$ & $x$                & value identifier   \\
                  &       & $\vbar$       & $\lambda x.e$      & function           \\
                  &       & $\vbar$       & $e$ $e$            & application        \\
                  &       & $\vbar$       & $\link{e}{e}$      & linked expression  \\
                  &       & $\vbar$       & $\varepsilon$      & empty module       \\
                  &       & $\vbar$       & $M$                & module identifier  \\
                  &       & $\vbar$       & $\Let$ $x$ $e$ $e$ & binding expression \\
                  &       & $\vbar$       & $\Let$ $M$ $e$ $e$ & binding module     \\
    \end{tabular}
  \end{figure}
\end{frame}
\begin{frame}[c,fragile]
  \frametitle{Example}
  \begin{tcolorbox}[sidebyside, sidebyside align=top, fontupper=\scriptsize, fontlower=\scriptsize]
    \begin{lstlisting}[basicstyle=\ttfamily,escapeinside={/*}{*/}]
(* A.ml *)
let true x y = x

(* main.ml *)
open A
let id x = x
;;
id true
\end{lstlisting}
    \tcblower
    \begin{lstlisting}[basicstyle=\ttfamily,escapeinside={/*}{*/}]
(* In our language *)
(let A =
  let true = \x.\y.x in/* $\varepsilon$ */
in/* $\varepsilon$ */)/* $\semlink$ */
  (A/* $\semlink$ */
    ((let id = \x.x
    in/* $\varepsilon$ */)/* $\semlink$ */
      (id true)))
\end{lstlisting}
  \end{tcolorbox}
\end{frame}
\section{Concrete Semantics}
\begin{frame}[c]
  \frametitle{Semantic Domains}
  \begin{figure}[h!]
    \centering
    \footnotesize
    \begin{tabular}{rrcl}
      Time            & $t$     & $\in$         & $\Time$                                                                                  \\
      Context         & $C$     & $\in$         & $\Ctx(\Time)$                                                                            \\
      Value(Expr)     & $v$     & $\in$         & $\Value(\Time) \triangleq \Expr\times\Ctx(\Time)$                                        \\
      Value(Expr/Mod) & $V$     & $\in$         & $\Value(\Time)\uplus\Ctx(\Time)$                                                         \\
      Memory          & $\mem$  & $\in$         & $\Mem(\Time) \triangleq \fin{\Time}{\Value(\Time)}$                                      \\
      State           & $s$     & $\in$         & $\State(\Time) \triangleq \Ctx(\Time)\times\Mem(\Time)\times\Time$                       \\
      Result          & $r$     & $\in$         & $\Result(\Time) \triangleq (\Value(\Time)\uplus\Ctx(\Time))\times\Mem(\Time)\times\Time$ \\
      Tick            & $\tick$ & $\in$         & $\Tick(\Time)\triangleq(\State(\Time)\times\ExprVar\times\Value(\Time))\rightarrow\Time$ \\
      Context         & $C$     & $\rightarrow$ & []                                                                                       \\
                      &         & $\vbar$       & $(x,t)\cons C$                                                                           \\
                      &         & $\vbar$       & $(M,C)\cons C$                                                                           \\
      Value(Expr)     & $v$     & $\rightarrow$ & $\langle \lambda x.e, C \rangle$
    \end{tabular}
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{$\addr$ and $\modctx$}
  \begin{itemize}
    \item $\addr(C,x)$ looks up when $x$ was bound in $C$.
    \item $\modctx(C,M)$ looks up what is bound to $M$ in $C$
  \end{itemize}
  \begin{figure}[h!]
    \centering
    \footnotesize
    \[
      \addr(C,x)\triangleq
      \begin{cases}
        \bot         & C=[]                              \\
        t            & C=(x, t)\cons C'                  \\
        \addr(C',x)  & C=(x', t)\cons C' \wedge x'\neq x \\
        \addr(C'',x) & C=(M, C')\cons C''
      \end{cases}
    \]
    \[
      \modctx(C,M)\triangleq
      \begin{cases}
        \bot           & C=[]                               \\
        C'             & C=(M, C')\cons C''                 \\
        \modctx(C'',M) & C=(M', C')\cons C''\wedge M'\neq M \\
        \modctx(C',M)  & C=(x, t)\cons C'
      \end{cases}
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Operational Semantics : $\semarrow_{\tick}$}
  \begin{figure}[h!]
    \begin{flushright}
      \fbox{$(e,C,\mem,t)\semarrow_\tick(V,\mem',t')\text{ or }(e',C',\mem',t')$}
    \end{flushright}
    \vspace{0pt} % -0.75em}
    \footnotesize
    \[
      \begin{prooftree}
        \hypo{t_{x}=\addr(C,x)}
        \hypo{v=\mem(t_{x})}
        \infer[left label=ExprVar]2{
        (x, C, \mem, t)
        \semarrow
        (v, \mem, t)
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \infer[left label={AppL}]0{
        (e_{1}\:e_{2}, C, \mem, t)
        \semarrow
        (e_{1},C, \mem,t)
        }
      \end{prooftree}\qquad
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, C, \mem, t)
            \semarrow
            (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \mem_{\lambda}, t_{\lambda})
          \end{matrix}
        }
        \infer[left label={AppR}]1{
        (e_{1}\:e_{2}, C, \mem, t)
        \semarrow
        (e_{2}, C, \mem_{\lambda}, t_{\lambda})
        }
      \end{prooftree}
    \]
    \[
      \begin{prooftree}
        \hypo{
          \begin{matrix}
            (e_{1}, C, \mem, t)
            \semarrow
            (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \mem_{\lambda}, t_{\lambda}) \\
            (e_{2}, C, \mem_{\lambda}, t_{\lambda})
            \semarrow
            (v, \mem_{a}, t_{a})
          \end{matrix}
        }
        \infer[left label={AppBody}]1{
        (e_{1}\:e_{2}, C, \mem, t)
        \semarrow
        (e_{\lambda}, (x, t_{a})\cons C_{\lambda}, \mem_{a}[t_{a}\mapsto v], \tick((C,\mem_{a},t_{a}),x,v))
        }
      \end{prooftree}
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{$\Time$ and $\tick$}
  Q: So, what $\Time$ and $\tick$ should we use?

  A: Anything! (If it satisfies two requirements)
  \pause
  \begin{enumerate}
    \item $\tick$ produces a strictly larger timestamp with respect to some total order on $\Time$.
          \[\forall t\in\Time:t<\tick((\_,\_,t),\_,\_)\]
    \item All $(V,\mem,t)\in\Result(\Time)$ satisfies: $V < t\wedge\mem < t$
          \begin{minipage}{\linewidth}
            \begin{figure}[h!]
              \scriptsize
              \[
                \begin{array}{cc}
                  C < t\triangleq
                  \begin{cases}
                    \mathsf{True}        & C=[]              \\
                    t' < t\wedge C' < t  & C=(x,t')\cons C'  \\
                    C' < t\wedge C'' < t & C=(M,C')\cons C''
                  \end{cases}
                   &
                  \begin{array}{l}
                    V < t\triangleq
                    \begin{cases}
                      C < t & V=\langle\_,C\rangle \\
                      C < t & V=C
                    \end{cases} \\
                    \mem < t\triangleq\forall t'\in\mathsf{dom}(\mem):t'<t\wedge\mem(t') < t
                  \end{array}
                \end{array}
              \]
            \end{figure}
          \end{minipage}
  \end{enumerate}
  Then all $\tick$s will produce \emph{fresh} timestamps.
\end{frame}
\begin{frame}[c]
  \frametitle{Irrelevence of $\tick$}
  Q: How can we consider semantics instantiated with different $\Time$ and $\tick$ to be equivalent?

  A: If they have the same structure!
  \pause
  \begin{itemize}
    \item Let $r=(V,\mem,t)\in\Result(\Time)$, $r'=(V',\mem',t')\in\Result(\Time')$.
    \item If we can \emph{translate} the timestamps in $r$ into $r'$ and vice versa, $r$ and $r'$ are \emph{isomorphic} ($r\cong r'$).

          \pause
    \item ``Can translate $r$ to $r'$": $\exists f\in\Time\rightarrow\Time':f(V)=V'\wedge f\circ\mem=\mem'\circ f\wedge f(t)=t'$.
  \end{itemize}
\end{frame}
\begin{frame}[c]
  \frametitle{Irrelevence of $\tick$}
  If we start from isomorphic states, the execution stays isomorphic!

  \pause
  Notation: $\ell\in\Left\triangleq\Expr\times\State(\Time)$, $\rho\in\Right\triangleq\Left\cup\Result(\Time)$
  \begin{theorem}[Irrelevence of $\tick$]
    Let $s\in\State(\Time)$ and $s'\in\State(\Time')$.
    If $s\cong s'$, then:
    \[\forall\tick,\tick',e,\rho:(e,s)\semarrow_\tick\rho\Rightarrow\exists\rho':(e,s')\semarrow_{\tick'}\rho'\wedge\rho\cong\rho'\]
  \end{theorem}
\end{frame}
\begin{frame}[c]
  \frametitle{Collecting Semantics}
  \[\sembracket{e}S\subseteq(\Right\times\Tick(\Time))\cup(\Left\times\Tick(\Time)\times\Right )\]
  \begin{itemize}
    \item Collecting semantics of $e$ under $S\subseteq\State(\Time)\times\Tick(\Time)$.
    \item Collect \emph{all} configurations in the proof tree starting from $\{((e,s),\tick)|(s,\tick)\in S\}\subseteq\Right\times\Tick(\Time)$.
  \end{itemize}
\end{frame}
\begin{frame}[c]
  \frametitle{Collecting Semantics}
  \begin{definition}[Transfer Function]
    \[
      \mathsf{Step}(A)\triangleq
      \left\{\ell\semarrow_\tick\rho, (\rho,\tick)|
      \begin{prooftree}[center=true]
        \hypo{A'}\infer1{\ell\semarrow_\tick\rho}
      \end{prooftree}\wedge
      A'\subseteq A\wedge(\ell,\tick)\in A
      \right\}
    \]
  \end{definition}
  \begin{definition}[Collecting Semantics]
    \[
      \sembracket{e}S\triangleq
      \mathsf{lfp}(\lambda X.\mathsf{Step}(X)\cup\{((e,s),\tick)|(s,\tick)\in S\})
    \]
  \end{definition}
\end{frame}
\section{Concrete Linking}
\begin{frame}[c]
  \frametitle{Our Goal}
  What does $\link{e_1}{e_2}$ evaluate to under $S$? : $|\sembracket{\link{e_1}{e_2}}S|$
  \begin{itemize}
    \item Normally, first evaluate $e_1$ under $S$ : $|\sembracket{e_1}S|$
    \item Then evaluate $e_2$ under the exported states : $|\sembracket{e_2}|\sembracket{e_1}S||$
          \[|\sembracket{\link{e_1}{e_2}}S|=|\sembracket{e_2}|\sembracket{e_1}S||\]
    \item Instead, collect $e_2$ \emph{in advance} under an \emph{assumed} $S_2$ : $\sembracket{e_2}S_2$
    \item Later, check if the assumption is guaranteed : $|\sembracket{e_1}S|\cong S_1\rhd S_2$
    \item Fill in the blanks with $S_1$, then finish : $S_1\semlink\sembracket{e_2}S_2$
          \[|\sembracket{\link{e_1}{e_2}}S|\cong|S_1\semlink\sembracket{e_2}S_2|\]
  \end{itemize}
\end{frame}
\begin{frame}[c]
  \frametitle{Definitions to Come}
  \begin{enumerate}
    \item What is $|\sembracket{e}S|$ and $|S_1\semlink\sembracket{e}S_2|$(final results)?
          \pause
          \[
            |\sembracket{e}S|\triangleq\{r|(e,\_)\semarrow r\in\sembracket{e}S\}\quad
            |S_1\semlink\sembracket{e}S_2|\triangleq\{r|(e,\_)\semarrow r\in S_1\semlink\sembracket{e}S_2\}
          \]

          \pause
    \item What is $\rhd$(injection)?
    \item What is $\semlink$(semantic linking)?
  \end{enumerate}
\end{frame}

\begin{frame}[c]
  \frametitle{Definition of $\rhd$: Desired Properties}
  Elementwise injection: $(s_+,\tick_+)=(s_1,\tick_1)\rhd(s_2,\tick_2)$

  \begin{enumerate}
    \item If $s_2=([],\varnothing,0)$, $s_+\cong s_1$
    \item If $(e,s_2)\semarrow_{\tick_2}^*(e',s_2')$, then $(s_+',\tick_+')=(s_1,\tick_1)\rhd(s_2',\tick_2)$ must satisfy
          $\tick_+=\tick_+'$ and $(e,s_+)\semarrow_{\tick_+}^*(e',s_+')$.
  \end{enumerate}
\end{frame}

\begin{frame}[c]
  \frametitle{Definition of $\rhd$, Step 1: Fill in the Blanks}
  \begin{figure}[h!]
    \footnotesize
    \[
      \inject{C_{1}}{C_{2}}\triangleq
      \begin{cases}
        C_1                                             & C_{2}=[]              \\
        (x, t)\cons\inject{C_{1}}{C'}                   & C_{2}=(x,t)\cons C'   \\
        (M, \inject{C_{1}}{C'})\cons\inject{C_{1}}{C''} & C_{2}=(M,C')\cons C''
      \end{cases}
    \]
    \[
      \delete{C_{1}}{C_{2}}\triangleq
      \begin{cases}
        []                                              & C_{2}=C_{1}\lor C_{2}=[] \\
        (x,t)\cons\delete{C_{1}}{C'}                    & C_{2}=(x,t)\cons C'      \\
        (M, \delete{C_{1}}{C'})\cons\delete{C_{1}}{C''} & C_{2}=(M, C')\cons C''
      \end{cases}
    \]\pause
    \[
      \begin{array}{cc}
        \inject{C_1}{V_2}\triangleq
        \begin{cases}
          \inject{C_1}{C_2}                           & V_2=C_2                            \\
          \langle\lambda x.e,\inject{C_1}{C_2}\rangle & V_2=\langle\lambda x.e, C_2\rangle
        \end{cases} &
        \begin{array}{l}
          \inject{C_1}{\mem_2}\triangleq
          \displaystyle\bigcup_{t\in\mathsf{dom}(\mem_2)}\{t\mapsto\inject{C_1}{\mem_2(t)}\} \\
          \inject{s_1}{r_2}\triangleq
          (\inject{C_1}{V_2},\mem_1\cup\inject{C_1}{\mem_2},t_2)
        \end{array}
      \end{array}
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Definition of $\rhd$, Step 2: $\tick_+$}
  Note $\inject{C_1}{C_2}\in\Ctx(\Time_1+\Time_2)$. What should $\tick_+$ be?

  \begin{figure}[h!]
    \footnotesize
    \[
      \tick_+((C,\mem,t),x,v)\triangleq
      \begin{cases}
        \tick_1((C.1,\mem.1,t),x,v.1)                                           & t\in\Time_1 \\
        \tick_2((\delete{C_1}{C}.2,\delete{C_1}{\mem}.2,t),x,\delete{C_1}{v}.2) & t\in\Time_2
      \end{cases}
    \]
  \end{figure}
  where
  \begin{figure}[h!]
    \footnotesize
    \[
      \begin{array}{cc}
        C.i\triangleq
        \begin{cases}
          []                  & C=[]                                    \\
          (x,t)\cons C'.i     & C=(x,t)\cons C'\wedge t\in{\Time_i}     \\
          C'.i                & C=(x,t)\cons C'\wedge t\not\in{\Time_i} \\
          (M,C'.i)\cons C''.i & C=(M, C')\cons C''
        \end{cases} &
        \begin{array}{l}
          V.i\triangleq
          \begin{cases}
            C.i                           & V=C                           \\
            \langle\lambda x.e,C.i\rangle & V=\langle\lambda x.e,C\rangle
          \end{cases} \\ \\
          \mem.i\triangleq
          \displaystyle\bigcup_{t\in\mathsf{dom}(\mem)\cap\Time_i}\{t\mapsto \mem(t).i\}
        \end{array}
      \end{array}
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Definition of $\rhd$}
  \begin{definition}[Definition of $\rhd$]
    \[(s_1,\tick_1)\rhd(r_2,\tick_2)\triangleq(\inject{s_1}{r_2},\tick_+)\]
    \[S_1\rhd S_2\triangleq\{(s_1,\tick_1)\rhd(s_2,\tick_2)|(s_1,\tick_1)\in S_1\wedge(s_2,\tick_2)\in S_2\}\]
  \end{definition}
  To inject into a cache,
  \begin{figure}[h!]
    \scriptsize
    \begin{align*}
      (s_1,\tick_1)\rhd(\rho_2,\tick_2)                  & \triangleq
      \begin{cases}
        (r_+,\tick_+)     & \rho_2=r_2\wedge(r_+,\tick_+)=(s_1,\tick_1)\rhd(r_2,\tick_2)            \\
        ((e,s_+),\tick_+) & \rho_2=\ell_2=(e,s_2)\wedge(s_+,\tick_+)=(s_1,\tick_1)\rhd(s_2,\tick_2)
      \end{cases} \\
      (s_1,\tick_1)\rhd(\ell_2\semarrow_{\tick_2}\rho_2) & \triangleq
      \ell_+\semarrow_{\tick_+}\rho_+
    \end{align*}
    \[
      \text{ where }
      (\ell_+,\tick_+)=(s_1,\tick_1)\rhd(\ell_2,\tick_2)\wedge
      (\rho_+,\tick_+)=(s_1,\tick_1)\rhd(\rho_2,\tick_2)
    \]
  \end{figure}
\end{frame}
\begin{frame}[c]
  \frametitle{Definition of $\semlink$}
  \begin{definition}[Semantic Linking]
    Let $S_1\subseteq\State(\Time_1)\times\Tick(\Time_1)$ and $A_2\subseteq(\Left_2\times\Tick(\Time_2)\times\Right_2)\cup(\Right_2\times\Tick(\Time_2))$.
    Then:
    \[
      S_1\semlink A_2\triangleq
      \mathsf{lfp}(\lambda X.\mathsf{Step}(X)\cup(S_1\rhd A_2))
    \]
  \end{definition}
\end{frame}
\begin{frame}[c]
  \frametitle{Advance}
  \begin{lemma}[Advance]
    Let $S_1\subseteq\State(\Time_1)\times\Tick(\Time_1)$ and $S_2\subseteq\State(\Time_2)\times\Tick(\Time_2)$. Then:
    \[
      \sembracket{e}(S_1\rhd S_2)=S_1\semlink\sembracket{e}S_2
    \]
  \end{lemma}
  Thus
  \[
    |\sembracket{\link{e_1}{e_2}}S|=|\sembracket{e_2}|\sembracket{e_1}S||\cong|\sembracket{e_2}(S_1\rhd S_2)|=|S_1\semlink\sembracket{e_2}S_2|
  \]
  when $\cong$ is due to the separability assumption and irrelevence of $\tick$
\end{frame}
\begin{frame}[c]
  \frametitle{A Trivial Example}
  \begin{itemize}
    \item When $S_2=\mt\triangleq\{([],\varnothing,0)\}$.
    \item Any $S$ is trivially separable as $S\cong S\rhd\mt$, so $|\sembracket{e_1}S|\cong|\sembracket{e_1}S|\rhd\mt$
    \item Since our language is CBV $\lambda$-calculus, can't do much better
  \end{itemize}
  \begin{corollary}[A Simple Case]
    \[
      |\sembracket{\link{e_1}{e_2}}S|\cong||\sembracket{e_1}S|\semlink\sembracket{e_2}\mt|
    \]
  \end{corollary}
\end{frame}
\begin{frame}[c]
  \frametitle{A Sketch of Analysis}
  \begin{itemize}
    \item Abstract $\Time$ by a finite $\A\Time$
    \item Use a sound $\A\tick$ satisfying $\A\tick\circ\alpha=\alpha\circ\tick$
    \item Define sound $\A\rhd$ and $\A\semlink$
  \end{itemize}
\end{frame}
\end{document}
%%% Local Variables:
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:
