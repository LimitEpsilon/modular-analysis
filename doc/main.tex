%! TEX program = xelatex
\documentclass[acmsmall,screen,review]{acmart}

%%% Typesetting for listings
\usepackage{listings}
\setmonofont{JuliaMono}[Scale=MatchLowercase]

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}

%%% lstlisting coq style (inspired from a file of Assia Mahboubi)
\lstdefinelanguage{Coq}{ 
    % Anything betweeen $ becomes LaTeX math mode
    mathescape=true,
    % Comments may or not include Latex commands
    texcl=false, 
    % Vernacular commands
    morekeywords=[1]{Section, Module, End, Require, Import, Export,
        Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
        Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
        Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
        Morphism, Relation, Implicit, Arguments, Unset, Contextual,
        Strict, Prenex, Implicits, Inductive, CoInductive, Record,
        Structure, Canonical, Coercion, Context, Class, Global, Instance,
        Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
        Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
        Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
        Projections, inside, outside, Def},
    % Gallina
    morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
        match, with, end, as, in, return, let, if, is, then, else, for, of,
        nosimpl, when},
    % Sorts
    morekeywords=[3]{Type, Prop, Set, true, false, option},
    % Various tactics, some are std Coq subsumed by ssr, for the manual purpose
    morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
        intro, intros, generalize, rename, pattern, after, destruct,
        induction, using, refine, inversion, injection, rewrite, congr,
        unlock, compute, ring, field, fourier, replace, fold, unfold,
        change, cutrewrite, simpl, have, suff, wlog, suffices, without,
        loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
        symmetry, transitivity, auto, split, left, right, autorewrite},
    % Terminators
    morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
        assumption, solve, contradiction, discriminate},
    % Control
    morekeywords=[6]{do, last, first, try, idtac, repeat},
    % Comments delimiters, we do turn this off for the manual
    morecomment=[s]{(*}{*)},
    % Spaces are not displayed as a special character
    showstringspaces=false,
    % String delimiters
    morestring=[b]",
    morestring=[d],
    % Size of tabulations
    tabsize=3,
    % Enables ASCII chars 128 to 255
    extendedchars=false,
    % Case sensitivity
    sensitive=true,
    % Automatic breaking of long lines
    breaklines=false,
    % Default style fors listings
    basicstyle=\small,
    % Position of captions is bottom
    captionpos=b,
    % flexible columns
    columns=[l]flexible,
    % Style for (listings') identifiers
    identifierstyle={\ttfamily\color{black}},
    % Style for declaration keywords
    keywordstyle=[1]{\ttfamily\color{dkviolet}},
    % Style for gallina keywords
    keywordstyle=[2]{\ttfamily\color{dkgreen}},
    % Style for sorts keywords
    keywordstyle=[3]{\ttfamily\color{ltblue}},
    % Style for tactics keywords
    keywordstyle=[4]{\ttfamily\color{dkblue}},
    % Style for terminators keywords
    keywordstyle=[5]{\ttfamily\color{dkred}},
    %Style for iterators
    %keywordstyle=[6]{\ttfamily\color{dkpink}},
    % Style for strings
    stringstyle=\ttfamily,
    % Style for comments
    commentstyle={\ttfamily\color{dkgreen}},
    %moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
    literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
    %    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
    %
}[keywords,comments,strings]

%%% Math settings
\usepackage{amsthm,mathtools}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{lem}{Lemma}[section]
\newtheorem{thm}{Theorem}[section]
\newtheorem{example}{Example}[section]

%%% PL constructs
\usepackage{ebproof}
\ebproofset{left label template=\textsc{[\inserttext]}}

%%% Custom commands
\newcommand*{\vbar}{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{â©´}}
\newcommand*{\ortype}{\mathrel{|}}
\newcommand*{\cons}{::}

\def\ovbarw{1.2mu}
\def\ovbarh{0.8}
\newcommand*{\ovbar}[1]{\mkern \ovbarw\overline{\mkern-\ovbarw{\smash{#1}\scalebox{1}[\ovbarh]{\vphantom{i}}}\mkern-\ovbarw}\mkern \ovbarw}
\newcommand*{\A}[1]{{#1}^{\#}}
\newcommand*{\Expr}{\text{Expr}}
\newcommand*{\ExprVar}{\text{ExprVar}}
\newcommand*{\Module}{\text{Module}}
\newcommand*{\ModVar}{\text{ModVar}}
\newcommand*{\Time}{\mathbb{T}}
\newcommand*{\ATime}{\A{\Time}}
\newcommand*{\Ctx}[1]{\text{Ctx}\vphantom{#1}}
\newcommand*{\Value}[1]{\text{Val}\vphantom{#1}}
\newcommand*{\Mem}[1]{\text{Mem}\vphantom{#1}}
\newcommand*{\mem}{m}
\newcommand*{\AMem}[1]{\A{\text{Mem}}\vphantom{#1}}
\newcommand*{\Config}[1]{\text{Config}\vphantom{#1}}
\newcommand*{\AConfig}[1]{\A{\text{Config}}\vphantom{#1}}
\newcommand*{\Result}[1]{\text{Result}\vphantom{#1}}
\newcommand*{\AResult}[1]{\A{\text{Result}}\vphantom{#1}}
\newcommand*{\link}[2]{{#1}\mathtt{!}{#2}}
\newcommand*{\EE}{\mathsf{Exp}}
\newcommand*{\LL}{\mathsf{L}}
\newcommand*{\Link}{\mathsf{Link}}
\newcommand*{\sembracket}[1]{\lBrack{#1}\rBrack}
\newcommand*{\fin}[2]{{#1}\xrightarrow{\text{fin}}{#2}}
\newcommand*{\addr}{\mathsf{addr}}
\newcommand*{\tick}{\mathsf{tick}}
\newcommand*{\modctx}{\mathsf{ctx}}
\newcommand*{\mapinject}{\mathsf{map\_inject}}
\newcommand*{\inject}[2]{{#1}\langle{#2}\rangle}
\newcommand*{\deletepre}{\mathsf{delete\_prefix}}
\newcommand*{\deletemap}{\mathsf{delete\_map}}
\newcommand*{\delete}{\mathsf{delete}}
\newcommand*{\filter}{\mathsf{filter}}
\newcommand*{\Let}{\mathtt{let}}
\newcommand*{\doubleplus}{+\kern-1.3ex+\kern0.8ex}
\newcommand*{\mdoubleplus}{\ensuremath{\mathbin{+\mkern-10mu+}}}
\newcommand*{\project}{\text{\texttt{:>} }}

\title{A Syntax-Guided Framework for Modular Analysis}
\author{Joonhyup Lee}
\begin{document}
\maketitle

\section{Abstract Syntax}

In this section we define the abstract syntax for a simple language that captures the essence of modules and linking.
The language is basically an extension of untyped lambda calculus with modules and the linking construct.

\begin{figure}[htb]
  \centering
  \footnotesize
  \begin{tabular}{rccll}
    Expression Identifier & $x$ & $\in$         & $\ExprVar$                                   \\
    Module Identifier     & $M$ & $\in$         & $\ModVar$                                    \\
    Expression            & $e$ & $\in$         & $\Expr$                                      \\
    Expression            & $e$ & $\rightarrow$ & $x$                & identifier, expression  \\
                          &     & $\vbar$       & $\lambda x.e$      & function                \\
                          &     & $\vbar$       & $e$ $e$            & application             \\
                          &     & $\vbar$       & $\link{e}{e}$      & linked expression       \\
                          &     & $\vbar$       & $\varepsilon$      & empty module            \\
                          &     & $\vbar$       & $M$                & identifier, module      \\
                          &     & $\vbar$       & $\Let$ $x$ $e$ $e$ & let-binding, expression \\
                          &     & $\vbar$       & $\Let$ $M$ $e$ $e$ & let-binding, module     \\
  \end{tabular}
  \caption{Abstract syntax of the simple module language.}
\end{figure}
\subsection{Rationale for the design of the simple language}

There are no recursive modules, first-class modules, or functors in the simple language that is defined.
Also, note that the nonterminals for the modules and expressions are not separated. Why is this so?

The rationale for the exclusion of recursive modules/first-class modules/functors is because we want to enforce static scoping.
That is, we need to be able to statically determine where variables were bound when using them.
To enforce static scoping when function applications might return modules, we need to employ signatures to project the dynamically computed modules onto a statically known context.
Concretely, we need to define signatures $S$ where $\lambda M\project S.e$ statically resolves the context when $M$ is used in the body $e$, and $(e_1\:e_2)\project S$ enforces that a dynamic computation is resolved into one static form.

The rationale for not separating modules and expressions in the syntax is because we want to utilize the linking construct to link both modules to expressions and modules to modules.
That is, we want expressions to be parsed as $(m_1!m_2)!e$.
$\link{m_1}{m_2}$ links a module with a module, and $(m_1!m_2)!e$ links a module with an expression.
Why this is convenient will be clear when we explain separate analysis; we want to link modules with modules as well as expressions.

\section{Structural Operational Semantics}

In this section we give the big-step operational semantics for the dynamic execution of the module language.
The big-step evaluation relation relates the initial configuration(context, memory and time) and expression with the resulting value and state.

This relation is nonstandard in that the \emph{environment} that is often used to define closures in the call-by-value dynamics is not a finite map from variables to values.
Rather, the surrounding \emph{syntactic} context annotated with the \emph{binding times} for the variables serve as the environment.
To access the value of the variable $x$ from the context $C$, one has to read off the closest binding time from the context and look up the value bound at that time from the memory.
To access the exported context from the variable $M$, one has to look up the exported context from $C$, not from the memory.

This separation between where we store modules and where we store the evaluated values from expressions emphasizes the fact that \emph{where} the variables are bound is guided by syntax.
The only thing that is dynamic is \emph{when} the variables are bound, which is represented by the time component.

Now, we start by defining what we mean by \emph{time} and \emph{context}, which is the essence of our model.

\subsection{Time and Context}

We first define sets that are parametrized by our choice of the time domain, mainly the \emph{value}, \emph{memory}, and \emph{context} domains.
Also, we present the notational conventions used in this paper to represent members of each domain.

\begin{figure}[htb]
  \centering
  \footnotesize
  \begin{tabular}{rccll}
    Time                          & $t$    & $\in$         & $\Time$                                                                                                          \\
    Context                       & $C$    & $\in$         & $\Ctx\Time$                                                                                                      \\
    Result of expressions         & $v$    & $\in$         & $\Value\Time \triangleq \Expr\times\Ctx\Time$                                                                    \\
    Result of expressions/modules & $V$    & $\in$         & $\Value{\Time}+\Ctx{\Time}$                                                                                      \\
    Memory                        & $\mem$ & $\in$         & $\Mem{\Time} \triangleq \fin{\Time}{\Value{\Time}}$                                                              \\
    Configuration                 & $s$    & $\in$         & $\Config{\Time} \triangleq \Ctx{\Time}\times\Mem{\Time}\times\Time$                                              \\
    Result                        & $r$    & $\in$         & $\Result{\Time} \triangleq (\Value{\Time}+\Ctx{\Time})\times\Mem{\Time}\times\Time$                              \\
    Context                       & $C$    & $\rightarrow$ & []                                                                                  & hole                       \\
                                  &        & $\vbar$       & $\lambda x^{t}.C$                                                                   & function parameter binding \\
                                  &        & $\vbar$       & $\Let$ $x^{t}$ $C$                                                                  & let expression binding     \\
                                  &        & $\vbar$       & $\Let$ $M$ $C$ $C$                                                                  & let module binding         \\
    Result of expressions         & $v$    & $\rightarrow$ & $\langle \lambda x.e, C \rangle$                                                    & closure
  \end{tabular}
  \caption{Definition of the semantic domains.}
\end{figure}

Above, there are no constraints placed upon the set $\Time$.
Now we give the conditions that the concrete time domain must satisfy.

\begin{definition}[Concrete time]
  $(\Time, \le, \tick)$ is a \emph{concrete time} when
  \begin{enumerate}
    \item $(\Time, \le)$ is a total order.
    \item $\tick\in\Time\rightarrow\Time$ satisfies: $\forall t\in\Time: t < \tick\:t$.
  \end{enumerate}
\end{definition}

Now for the auxiliary operators that is used when defining the evaluation relation.
We define the plugin operator for the dynamic context,
the function that extracts the address for an $\ExprVar$,
and the function that looks up the dynamic context bound to a $\ModVar$ $M$.

\begin{figure}[h!]
  \centering
  \footnotesize
  \[
    C_{1}[C_{2}]\triangleq
    \begin{cases}
      C_{2}                           & C_{1}=[]                       \\
      \lambda x^{t}.C'[C_{2}]         & C_{1}=\lambda x^{t}.C'         \\
      \mathtt{let}\:x^{t}\:C'[C_{2}]  & C_{1}=\mathtt{let}\:x^{t}\:C'  \\
      \mathtt{let}\:M\:C'\:C''[C_{2}] & C_{1}=\mathtt{let}\:M\:C'\:C''
    \end{cases}
  \]

  \[
    \addr(C,x)\triangleq
    \begin{cases}
      \bot         & C=[]                                                                                           \\
      t            & (C=\lambda x'^{t}.C'\lor C=\mathtt{let}\:x'^{t}C')\wedge (x'= x\wedge \addr(C',x)=\bot)        \\
      \addr(C',x)  & (C=\lambda x'^{t}.C'\lor C=\mathtt{let}\:x'^{t}\:C') \wedge (x'\neq x\lor \addr(C',x)\neq\bot) \\
      \addr(C'',x) & C=\mathtt{let}\:M\:C'\:C''
    \end{cases}
  \]

  \[
    \modctx(C,M)\triangleq
    \begin{cases}
      \bot           & C=[]                                                                   \\
      C'             & C=\mathtt{let}\:M'\:C'\:C''\wedge (M'= M\wedge\modctx(C'',M)=\bot)     \\
      \modctx(C'',M) & C=\mathtt{let}\:M'\:C'\:C''\wedge (M'\neq M\lor\modctx(C'',M)\neq\bot) \\
      \modctx(C',M)  & C=\lambda x^{t}.C'\lor C=\Let\:x^{t}\:C'
    \end{cases}
  \]
  \caption{Definitions for the plugin, $\addr$, and $\modctx$ operators.}
\end{figure}

\subsection{The Evaluation Relation}

Now we are in a position to define the big-step evaluation relation.
The relation $\Downarrow$ relates $(e,C,\mem,t)\in\Expr\times\Config{\Time}$ with
$(V,\mem,t)\in\Result{\Time}$.
Note that we constrain whether the evaluation relation returns $v\in\Value{\Time}$(when the expression being evaluated is not a module) or $C\in\Ctx{\Time}$ by the definition of the relation.

\begin{figure}[h!]
  \begin{flushright}\fbox{$(e,C,\mem,t)\Downarrow(V,\mem',t')$}\end{flushright}
  \vspace{0pt} % -0.75em}
  \footnotesize
  \[
    \begin{prooftree}
      \hypo{t_{x}=\addr(C,x)}
      \hypo{v=\mem(t_{x})}
      \infer[left label=ExprVar]2{
      (x, C, \mem, t)
      \Downarrow
      (v, \mem, t)
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \infer[left label=Fn]0{
      (\lambda x.e, C, \mem, t)
      \Downarrow
      (\langle\lambda x.e, C\rangle, \mem, t)
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, C, \mem, t)
          \Downarrow
          (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \mem_{\lambda}, t_{\lambda}) \\
          (e_{2}, C, \mem_{\lambda}, t_{\lambda})
          \Downarrow
          (v, \mem_{a}, t_{a})                                                            \\
          (e_{\lambda}, C_{\lambda}[\lambda x^{t_{a}}.[]], \mem_{a}[t_{a}\mapsto v], \tick\:t_{a})
          \Downarrow
          (v', \mem',t')
        \end{matrix}
      }
      \infer[left label={App}]1{
      (e_{1}\:e_{2}, C, \mem, t)
      \Downarrow
      (v', \mem',t')
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, C, \mem, t)
          \Downarrow
          (C', \mem', t') \\
          (e_{2}, C', \mem', t')
          \Downarrow
          (V, \mem'', t'')
        \end{matrix}
      }
      \infer[left label=Linking]1{
      (\link{e_{1}}{e_{2}}, C, \mem, t)
      \Downarrow
      (V, \mem'', t'')
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=Empty]0{
      (\varepsilon, C, \mem, t)
      \Downarrow
      (C, \mem, t)
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{C'=\modctx(C,M)}
      \infer[left label=ModVar]1{
      (M, C, \mem, t)
      \Downarrow
      (C', \mem, t)
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, C, \mem, t)
          \Downarrow
          (v, \mem', t') \\
          (e_{2}, C[\mathtt{let}\:x^{t'}\:[]], \mem'[t'\mapsto v], \tick\:t')
          \Downarrow
          (C', \mem'', t'')
        \end{matrix}
      }
      \infer[left label=LetE]1{
      (\mathtt{let}\:x\:e_1\:e_2, C, \mem, t)
      \Downarrow
      (C', \mem'', t'')
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, C, \mem, t)
          \Downarrow
          (C', \mem', t') \\
          (e_{2}, C[\mathtt{let}\:M\:C'\:[]], \mem', t')
          \Downarrow
          (C'', \mem'', t'')
        \end{matrix}
      }
      \infer[left label=LetM]1{
      (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \mem, t)
      \Downarrow
      (C'', \mem'', t'')
      }
    \end{prooftree}
  \]
  \caption{The concrete big-step evaluation relation.}
  \label{fig:conceval}
\end{figure}
Note that we do not constrain whether $v$ or $C$ is returned by $e_{2}$ in the linking case.
That is, linking may return either values or modules.

The equivalence of the evaluation relation with a reference interpreter is formalized in Coq.

\subsection{Collecting Semantics}

For program analysis, we need to define a collecting semantics that captures the strongest property we want to model.
In the case of modular analysis, we need to collect \emph{all} pairs of $(e,s)\Downarrow r$ that appear in the proof tree when trying to prove what the initial configuration evaluates to.
Consider the case when $\link{e_1}{e_2}$ is evaluated under configuration $s$.
Since $e_2$ has free variables that are exported by $e_1$, separately analyzing $e_2$ will result in an incomplete proof tree.
What it means to separately analyze, then link two expressions $e_1$ and $e_2$ is to (1) compute what $e_1$ will export to $e_2$ (2) partially compute the proof tree for $e_2$, and (3) inject the exported context into the partial proof to complete the execution of $e_2$.

What should be the \emph{type} of the collecting semantics?
Obviously, given the type of the evaluation relation, $\wp((\Expr\times\Config{\Time})\times\Result{\Time})$ seems to be the natural choice.
However, by requiring that all collected pairs have a result fails to collect the configurations that are reached but does not return.
Such a situation will occur frequently when separately analyzing an expression that depends on an external module to resolve its free variables.
Therefore, we interpret the relation as a partial function that maps an element of $\Expr\times\Config\Time$ to a \emph{set} of results.
An $(e,s)$ that is not in the domain of the collecting semantics means that it is not \emph{reached} by the initial configuration, and a $(e,s)$ that is inside the domain but is mapped to $\varnothing$ means that the configuration is reached but does not return.

\begin{definition}[Collecting Semantics] 
  The collecting semantics of an expression $e$ under initial configuration $s$ is a partial function $\sembracket{e}(s)\in(\Expr\times\Config\Time)\rightarrow\wp(\Result{\Time})_\bot$ that collects all pairs of reachable configurations with the results they return.
\end{definition}

\section{Fixpoint Semantics}

The collecting semantics in the previous section was defined in a declarative style and does not provide \emph{how} to actually calculate the semantics.
To formalize the notion of reachability and to utilize this in proofs, we define the single-step reachability relation $\rightsquigarrow$ in \ref{fig:concreach}.

\begin{figure}[htb]
  \begin{flushright}\fbox{$(e,C,\mem,t)\rightsquigarrow(e',C',\mem',t')$}\end{flushright}
  \centering
  \footnotesize
  \[
    \begin{prooftree}
      \infer[left label={AppL}]0{
      (e_{1}\:e_{2}, C, \mem, t)
      \rightsquigarrow
      (e_{1},C, \mem,t)
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, C, \mem, t)
          \Downarrow
          (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \mem_{\lambda}, t_{\lambda})
        \end{matrix}
      }
      \infer[left label={AppR}]1{
      (e_{1}\:e_{2}, C, \mem, t)
      \rightsquigarrow
      (e_{2}, C, \mem_{\lambda}, t_{\lambda})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, C, \mem, t)
          \Downarrow
          (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \mem_{\lambda}, t_{\lambda}) \\
          (e_{2}, C, \mem_{\lambda}, t_{\lambda})
          \Downarrow
          (v, \mem_{a}, t_{a})
        \end{matrix}
      }
      \infer[left label={AppBody}]1{
      (e_{1}\:e_{2}, C, \mem, t)
      \rightsquigarrow
      (e_{\lambda}, C_{\lambda}[\lambda x^{t_{a}}.[]], \mem_{a}[t_{a}\mapsto v], \tick\:t_{a})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=LinkL]0{
      (\link{e_{1}}{e_{2}}, C, \mem, t)
      \rightsquigarrow
      (e_{1}, C, \mem, t)
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, C, \mem, t)
          \Downarrow
          (C', \mem', t')
        \end{matrix}
      }
      \infer[left label=LinkR]1{
      (\link{e_{1}}{e_{2}}, C, \mem, t)
      \rightsquigarrow
      (e_{2}, C', \mem', t')
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=LetEL]0{
      (\mathtt{let}\:x\:e_1\:e_2, C, \mem, t)
      \rightsquigarrow
      (e_{1}, C, \mem, t)
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, C, \mem, t)
          \Downarrow
          (v, \mem', t')
        \end{matrix}
      }
      \infer[left label=LetER]1{
      (\mathtt{let}\:x\:e_1\:e_2, C, \mem, t)
      \rightsquigarrow
      (e_{2}, C[\mathtt{let}\:x^{t'}\:[]], \mem'[t'\mapsto v], \tick\:t')
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=LetML]0{
      (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \mem, t)
      \rightsquigarrow
      (e_{1}, C, \mem, t)
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, C, \mem, t)
          \Downarrow
          (C', \mem', t')
        \end{matrix}
      }
      \infer[left label=LetMR]1{
      (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \mem, t)
      \rightsquigarrow
      (e_{2}, C[\mathtt{let}\:M\:C'\:[]], \mem', t')
      }
    \end{prooftree}
  \]
  \caption{The concrete single-step reachability relation.}
  \label{fig:concreach}
\end{figure}
The well-definedness of the reachability relation with respect to a reference interpreter is formalized in Coq.

Using the transitive and reflexive closure $\rightsquigarrow^{*}$ of $\rightsquigarrow$, we can formalize the notion of collecting semantics.

\begin{lem}[Collecting semantics using $\rightsquigarrow^{*}$]
  \[
    \sembracket{e}(s)=\bigcup_{(e,s)\rightsquigarrow^{*}(e',s')}[(e',s')\mapsto\{r|(e',s')\Downarrow r\}]
  \]
\end{lem}

Now we define a transfer function that takes a cache and returns a cache that takes one step further.
Using this transfer function, we will express the collecting semantics as a fixpoint, which directly shows how to compute the semantics.

\begin{definition}[Transfer function]
  Given an element $a$ of $(\Expr\times\Config{\Time})\rightarrow{\wp(\Result{\Time})}_{\bot}$,

  \begin{itemize}
    \item Define ${\Downarrow}_{a}$ and ${\rightsquigarrow}_{a}$ by replacing all assumptions $(e,s)\Downarrow r$ to $r\in a(e,s)$ in $\Downarrow$ and $\rightsquigarrow$.
    \item Define the ${\mathsf{step}}$ function that collects all results derivable in one step from $(e,s)$ using $a$.
          \[
            \mathsf{step}(a)(e,s)\triangleq
            [(e,s)\mapsto\{r|(e,s){\Downarrow}_{a}r\}]
            \cup
            \bigcup_{(e,s)\rightsquigarrow_{a}(e',s')}[(e',s')\mapsto\varnothing]
          \]
  \end{itemize}

  We define the transfer function $F$ by:
  \[
    F(a)\triangleq
    \bigcup_{(e,s)\in\mathsf{dom}(a)}
    {\mathsf{step}(a)(e,s)}
  \]
\end{definition}

We can finally formulate the collecting semantics in fixpoint form.
\begin{lem}[Concrete semantics as a fixpoint]
  \[
    \sembracket{e}(s)=\mathsf{lfp}(\lambda a.F(a)\cup[(e,s)\mapsto\varnothing])
  \]
\end{lem}

To justify separate analysis, we decompose the collecting semantics of the linking expression into a composition of the semantics of the left and right expressions.

\begin{definition}[Auxiliary operators for concrete linking]
  \begin{align*}
    \EE\:e_1\:s        & \triangleq\sembracket{e_1}(s)(e_1,s)                    & (\text{Exported under }s)      \\
    \LL\:E\:e_2        & \triangleq\bigcup_{s'\in E}\sembracket{e_2}(s')         & (\text{Reached under }E)       \\
    \mathsf{F}\:E\:e_2 & \triangleq\bigcup_{s'\in E}\sembracket{e_2}(s')(e_2,s') & (\text{Final results under }E)
  \end{align*}
\end{definition}

\begin{definition}[Concrete linking operator]
  \begin{align*}
    \Link\:e_1\:e_2\:s & \triangleq\sembracket{e_1}(s)\cup\LL\:(\EE\:e_1\:s)\:e_2\cup[(\link{e_1}{e_2},s)\mapsto\mathsf{F}\:(\EE\:e_1\:s)\:e_2]
  \end{align*}
\end{definition}

\begin{thm}[Concrete linking]
  \[
    \sembracket{\link{e_1}{e_2}}(s)=\Link\:e_1\:e_2\:s
  \]

  That is, the semantics of the linked expression is the union of the semantics of the exporting expression and the semantics of the consuming expression under the exported configuration.
\end{thm}

\section{Abstract Semantics}

The abstract semantics is almost exactly the same as the concrete semantics, except for the fact that the memory domain is now a finite map from the abstract time domain to a \emph{set} of values.
Note we do not need to define the $\A{C}$, $\A{v}$, $\A{V}$ components, as they are \emph{exactly} their concrete counterparts.
They are simply $C$, $v$, $V$, parametrized by a different $\Time$.

\begin{figure}[htb]
  \centering
  \footnotesize
  \begin{tabular}{rccll}
    Abstract Time                 & $\A{t}$  & $\in$ & $\ATime$                                                                                   \\
    Context                       & $\A{C}$  & $\in$ & $\Ctx\ATime$                                                                               \\
    Result of expressions         & $\A{v}$  & $\in$ & $\Value\ATime$                                                                             \\
    Result of expressions/modules & $\A{V}$  & $\in$ & $\Value{\ATime}+\Ctx{\ATime}$                                                              \\
    Abstract Memory               & $\A\mem$ & $\in$ & $\AMem{\ATime} \triangleq \fin{\ATime}{\wp(\Value{\ATime})}$                               \\
    Abstract Configuration        & $\A{s}$  & $\in$ & $\AConfig{\ATime} \triangleq \Ctx{\ATime}\times\Mem{\ATime}\times\ATime$                   \\
    Abstract Result               & $\A{r}$  & $\in$ & $\AResult{\ATime} \triangleq (\Value{\ATime}+\Ctx{\ATime})\times\AMem{\ATime}\times\ATime$ \\
  \end{tabular}
  \caption{Definition of the semantic domains.}
\end{figure}

\subsection{Big-Step Evaluation}

\begin{figure}[htb]
  \begin{flushright}\fbox{$(e,\A{C},\A\mem,\A{t})\A\Downarrow(\A{V},\A{\mem'},\A{t'})$}\end{flushright}
  \footnotesize
  \[
    \begin{prooftree}
      \hypo{\A{t_{x}}=\addr(\A{C},x)}
      \hypo{\A{v}\in\A{\mem}(\A{t_{x}})}
      \infer[left label=ExprVar]2{
      (x, \A{C}, \A{\mem}, \A{t})
      \A{\Downarrow}
      (\A{v}, \A{\mem}, \A{t})
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \infer[left label=Fn]0{
      (\lambda x.e, \A{C}, \A{\mem}, \A{t})
      \A{\Downarrow}
      (\langle\lambda x.e, \A{C}\rangle, \A{\mem}, \A{t})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{C}, \A{\mem}, \A{t})
          \A{\Downarrow}
          (\langle\lambda x.e_{\lambda}, \A{C_{\lambda}}\rangle, \A{\mem_{\lambda}}, \A{t_{\lambda}}) \\
          (e_{2}, \A{C}, \A{\mem_{\lambda}}, \A{t_{\lambda}})
          \A{\Downarrow}
          (\A{v}, \A{\mem_{a}}, \A{t_{a}})                                                            \\
          (e_{\lambda}, \A{C_{\lambda}}[\lambda x^{\A{t_{a}}}.[]], \A{\mem_{a}}[\A{t_{a}}\A{\mapsto} \A{v}], \A{\tick}\:\A{C}\:\A{\mem_a}\:\A{t_{a}}\:x\:\A{v})
          \A{\Downarrow}
          (\A{v'}, \A{\mem'},\A{t'})
        \end{matrix}
      }
      \infer[left label={App}]1{
      (e_{1}\:e_{2}, \A{C}, \A{\mem}, \A{t})
      \A{\Downarrow}
      (\A{v'}, \A{\mem'},\A{t'})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{C}, \A{\mem}, \A{t})
          \A{\Downarrow}
          (\A{C'}, \A{\mem'}, \A{t'}) \\
          (e_{2}, \A{C'}, \A{\mem'}, \A{t'})
          \A{\Downarrow}
          (\A{V}, \A{\mem''}, \A{t''})
        \end{matrix}
      }
      \infer[left label=Linking]1{
      (\link{e_{1}}{e_{2}}, \A{C}, \A{\mem}, \A{t})
      \A\Downarrow
      (\A{V}, \A{\mem''}, \A{t''})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=Empty]0{
      (\varepsilon, \A{C}, \A{\mem}, \A{t})
      \A{\Downarrow}
      (\A{C}, \A{\mem}, \A{t})
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{\A{C'}=\modctx(\A{C},M)}
      \infer[left label=ModVar]1{
      (M, \A{C}, \A{\mem}, \A{t})
      \A{\Downarrow}
      (\A{C'}, \A{\mem}, \A{t})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{C}, \A{\mem}, \A{t})
          \A\Downarrow
          (\A{v}, \A{\mem'}, \A{t'}) \\
          (e_{2}, \A{C}[\mathtt{let}\:x^{\A{t'}}\:[]], \A{\mem'}[\A{t'}\A{\mapsto} \A{v}], \A{\tick}\:\A{C}\:\A{\mem'}\:\A{t'}\:x\:\A{v})
          \A\Downarrow
          (\A{C'}, \A{\mem''}, \A{t''})
        \end{matrix}
      }
      \infer[left label=LetE]1{
      (\mathtt{let}\:x\:e_1\:e_2, \A{C}, \A{\mem}, \A{t})
      \A\Downarrow
      (\A{C'}, \A{\mem''}, \A{t''})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{C}, \A{\mem}, \A{t})
          \A\Downarrow
          (\A{C'}, \A{\mem'}, \A{t'}) \\
          (e_{2}, \A{C}[\mathtt{let}\:M\:\A{C'}\:[]], \A{\mem'}, \A{t'})
          \A\Downarrow
          (\A{C''}, \A{\mem''}, \A{t''})
        \end{matrix}
      }
      \infer[left label=LetM]1{
      (\mathtt{let}\:M\:e_{1}\:e_{2}, \A{C}, \A{\mem}, \A{t})
      \A\Downarrow
      (\A{C''}, \A{\mem''}, \A{t''})
      }
    \end{prooftree}
  \]
  \caption{The abstract big-step evaluation relation.}
  \label{fig:abseval}
\end{figure}

\begin{figure}[htb]
  \begin{flushright}\fbox{$(e,\A{C},\A\mem,\A{t})\A\rightsquigarrow(e',\A{C'},\A{\mem'},\A{t'})$}\end{flushright}
  \centering
  \footnotesize
  \[
    \begin{prooftree}
      \infer[left label={AppL}]0{
      (e_{1}\:e_{2}, \A{C}, \A{\mem}, \A{t})
      \A\rightsquigarrow
      (e_{1}, \A{C}, \A{\mem}, \A{t})
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{C}, \A{\mem}, \A{t})
          \A{\Downarrow}
          (\langle\lambda x.e_{\lambda}, \A{C_{\lambda}}\rangle, \A{\mem_{\lambda}}, \A{t_{\lambda}})
        \end{matrix}
      }
      \infer[left label={AppR}]1{
      (e_{1}\:e_{2}, \A{C}, \A{\mem}, \A{t})
      \A\rightsquigarrow
      (e_{2}, \A{C}, \A{\mem_{\lambda}}, \A{t_{\lambda}})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{C}, \A{\mem}, \A{t})
          \A{\Downarrow}
          (\langle\lambda x.e_{\lambda}, \A{C_{\lambda}}\rangle, \A{\mem_{\lambda}}, \A{t_{\lambda}}) \\
          (e_{2}, \A{C}, \A{\mem_{\lambda}}, \A{t_{\lambda}})
          \A{\Downarrow}
          (\A{v}, \A{\mem_{a}}, \A{t_{a}})
        \end{matrix}
      }
      \infer[left label={AppBody}]1{
      (e_{1}\:e_{2}, \A{C}, \A{\mem}, \A{t})
      \A\rightsquigarrow
      (e_{\lambda}, \A{C_{\lambda}}[\lambda x^{\A{t_{a}}}.[]], \A{\mem_{a}}[\A{t_{a}}\A{\mapsto} \A{v}], \A{\tick}\:\A{C}\:\A{\mem_a}\:\A{t_{a}}\:x\:\A{v})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=LinkL]0{
      (\link{e_{1}}{e_{2}}, \A{C}, \A{\mem}, \A{t})
      \A\rightsquigarrow
      (e_{1}, \A{C}, \A{\mem}, \A{t})
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{C}, \A{\mem}, \A{t})
          \A{\Downarrow}
          (\A{C'}, \A{\mem'}, \A{t'})
        \end{matrix}
      }
      \infer[left label=LinkR]1{
      (\link{e_{1}}{e_{2}}, \A{C}, \A{\mem}, \A{t})
      \A\rightsquigarrow
      (e_{2}, \A{C'}, \A{\mem'}, \A{t'})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=LetEL]0{
      (\mathtt{let}\:x\:e_1\:e_2, \A{C}, \A{\mem}, \A{t})
      \A\rightsquigarrow
      (e_{1}, \A{C}, \A{\mem}, \A{t})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{C}, \A{\mem}, \A{t})
          \A\Downarrow
          (\A{v}, \A{\mem'}, \A{t'})
        \end{matrix}
      }
      \infer[left label=LetER]1{
      (\mathtt{let}\:x\:e_1\:e_2, \A{C}, \A{\mem}, \A{t})
      \A\rightsquigarrow
      (e_{2}, \A{C}[\mathtt{let}\:x^{\A{t'}}\:[]], \A{\mem'}[\A{t'}\A{\mapsto} \A{v}], \A{\tick}\:\A{C}\:\A{\mem'}\:\A{t'}\:x\:\A{v})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=LetML]0{
      (\mathtt{let}\:M\:e_{1}\:e_{2}, \A{C}, \A{\mem}, \A{t})
      \A\rightsquigarrow
      (e_{1}, \A{C}, \A{\mem}, \A{t})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{C}, \A{\mem}, \A{t})
          \A\Downarrow
          (\A{C'}, \A{\mem'}, \A{t'})
        \end{matrix}
      }
      \infer[left label=LetMR]1{
      (\mathtt{let}\:M\:e_{1}\:e_{2}, \A{C}, \A{\mem}, \A{t})
      \A\rightsquigarrow
      (e_{2}, \A{C}[\mathtt{let}\:M\:\A{C'}\:[]], \A{\mem'}, \A{t'})
      }
    \end{prooftree}
  \]
  \caption{The abstract single-step reachability relation.}
  \label{fig:absreach}
\end{figure}

First the abstract evaluation relation $\A{\Downarrow}$ is defined.
Note that the update for the memory is now a weak update. That is,
\begin{definition}[Weak update]
  Given $\A{\mem}\in\AMem{\ATime}$, $\A{t}\in\ATime$, $\A{v}\in\Value{\ATime}$, we define $\A{\mem}[\A{t}\A{\mapsto}\A{v}]$ as:
  \[
    \A{\mem}[\A{t}\A{\mapsto}\A{v}](\A{t'})\triangleq
    \begin{cases}
      \A{\mem}(\A{t})\cup\{\A{v}\} & (\A{t'}=\A{t})     \\
      \A{\mem}(\A{t'})             & (\text{otherwise})
    \end{cases}
  \]
\end{definition}

Also, for the abstract time, we do not enforce the existence of an ordering on the timestamps, but we do need a policy for performing the tick operation.
Since we want to utilize the information when the binding is performed, the $\A{\tick}$ function takes in more information than simply the previous abstract time.
\begin{definition}[Abstract time]
  $(\ATime,\A{\tick})$ is an \emph{abstract time} when $\A{\tick}\in\Ctx{\ATime}\rightarrow\AMem{\ATime}\rightarrow\ATime\rightarrow\ExprVar\rightarrow\Value{\ATime}\rightarrow\ATime$ is the policy for advancing the timestamp.
\end{definition}
In our semantics, $\A{\tick}\:\A{C}\:\A{\mem}\:\A{t}\:x\:\A{v}$ is performed when $\A{v}$ is bound to $x$ under configuration $(\A{C},\A{\mem},\A{t})$.

The abstract big-step evaluation relation is defined in \ref{fig:abseval}, and the single-step reachability relation is defined in \ref{fig:absreach}.

\subsection{Soundness}

From the relations above, we can define the abstract semantics:
\begin{definition}[Abstract semantics]
  The semantics for an expression $e$ under configuration $\A{s}\in\AConfig{\ATime}$ is an element in $(\Expr\times\AConfig{\ATime})\rightarrow{\wp(\AResult{\ATime})}_{\bot}$ defined as:
  \[
    \A{\sembracket{e}}(\A{s})\triangleq\bigsqcup_{(e,\A{s}){\A\rightsquigarrow}^{*}(e',\A{s'})}[(e',\A{s'})\mapsto\{\A{r}|(e',\A{s'})\A\Downarrow \A{r}\}]
  \]
\end{definition}

We need to present how to compute the abstract semantics by equating the semantics with the least fixed point of some transfer function.

\begin{definition}[Transfer function]
  Given an element $\A{a}$ of $(\Expr\times\AConfig{\ATime})\rightarrow{\wp(\AResult{\ATime})}_{\bot}$,

  \begin{itemize}
    \item Define $\A{\Downarrow}_{\A{a}}$ and $\A{\rightsquigarrow}_{\A{a}}$ by replacing all assumptions $(e,\A{s})\A\Downarrow\A{r}$ to $\A{r}\in\A{a}(e,\A{s})$ in $\A\Downarrow$ and $\A\rightsquigarrow$.
    \item Define the $\A{\mathsf{step}}$ function that collects all results derivable in one step from $(e,\A{s})$ using $\A{a}$.
          \[
            \A{\mathsf{step}}(\A{a})(e,\A{s})\triangleq
            [(e,\A{s})\mapsto\{\A{r}|(e,\A{s})\A{\Downarrow}_{\A{a}}\A{r}\}]
            \sqcup
            \bigsqcup_{(e,\A{s})\A{\rightsquigarrow}_{\A{a}}(e',\A{s'})}[(e',\A{s'})\mapsto\varnothing]
          \]
  \end{itemize}

  We define the transfer function $\A{F}$ by:
  \[
    \A{F}(\A{a})\triangleq
    \bigsqcup_{(e,\A{s})\in\mathsf{dom}(\A{a})}
    {\A{\mathsf{step}}(\A{a})(e,\A{s})}
  \]
\end{definition}

\begin{lem}[Abstract semantics as a fixpoint]
  \[
    \A{\sembracket{e}}(\A{s})=\mathsf{lfp}(\lambda \A{a}.\A{F}(\A{a})\sqcup[(e,\A{s})\mapsto\varnothing])
  \]
\end{lem}

The usual thing to do now is to connect the collecting semantics $\sembracket{e}$ with the abstract semantics $\A{\sembracket{e}}$ via a Galois connection.
However, we do not enforce the existence of an explicit abstraction and concretization function.
Instead, we define a notion of soundness between abstract and concrete results and prove that for any $\A{\tick}$, the abstract semantics overapproximate the collecting semantics if it starts from a sound configuration.

\begin{definition}[$\alpha$-soundness between results]
  $\:$

  \begin{itemize}
    \item Let $(V,\mem,t)\in\Result{\Time}$ and $(\A{V},\A\mem,\A{t})\in\AResult{\ATime}$. We do not assume that $\Time$ and $\ATime$ are concrete/abstract times.
    \item Let $\alpha:\Time\rightarrow\ATime$, and extend $\alpha$ to a function in $\Ctx{\Time}\rightarrow\Ctx{\ATime}$ by mapping $\alpha$ over all timestamps.
    \item Extend $\alpha$ to a function in $(\Ctx{\Time}+\Value{\Time})\rightarrow(\Ctx{\ATime}+\Value{\ATime})$ accordingly.
    \item Extend $\alpha$ to a function in $\Mem{\Time}\rightarrow\AMem{\ATime}$ by defining
          \[\alpha(\mem)\triangleq\bigsqcup_{t\in\mathsf{dom}(\mem)}[\alpha(t)\mapsto\{\alpha(\mem(t))\}]\]
  \end{itemize}

  We say that $(\A{V},\A\mem,\A{t})$ is an \emph{$\alpha$-sound approximation} of $(V,\mem,t)$ when $\alpha(V)=\A{V}$, $\alpha(\mem)\sqsubseteq\A\mem$, and $\alpha(t)=\A{t}$.
\end{definition}

\begin{definition}[Soundness between semantics : $\lesssim$]
  $\:$

  \begin{itemize}
    \item Let $a\in(\Expr\times\Config{\Time})\rightarrow{\wp(\Result{\Time})}_{\bot}$ and $\A{a}\in(\Expr\times\AConfig{\ATime})\rightarrow{\wp(\AResult{\ATime})}_{\bot}$.
  \end{itemize}

  We say that $\A{a}$ is a sound approximation of $a$ and write $a\lesssim\A{a}$ if:
  \[
    \forall e\in\Expr,s\in\Config{\Time},r\in\Result{\Time}:r\in a(e,s)\Rightarrow\exists\alpha,\alpha',\A{s},\A{r}:\alpha(s)\sqsubseteq\A{s}\wedge\alpha'(r)\sqsubseteq\A{r}\in\A{a}(e,\A{s})
  \]

  $\A{a}$ is sound with respect to $a$ iff for every $(e,s), r$ pair in $a$, there exists an $\alpha$-sound pair in $\A{a}$.
\end{definition}

\begin{lem}[Preservation of soundness, relation version]
  $\:$

  \begin{itemize}
    \item Let $s\in\Config{\Time}$ and $\A{s}\in\AConfig{\ATime}$.
    \item Let all timestamps in the $C$ and $\mem$ component of $s$ be strictly less than the $t$ component.
    \item Let $\A{s}$ be an $\alpha$-sound approximation of $s$ for some $\alpha$.
  \end{itemize}

  Then for all $e$,
  \begin{enumerate}
    \item If $(e,s)\Downarrow r$, then $\exists\alpha',\A{r}$ such that $(e,\A{s})\A\Downarrow\A{r}$, $\alpha'(s)\sqsubseteq\A{s}$, and $\alpha'(r)\sqsubseteq\A{r}$.
    \item If $(e,s)\rightsquigarrow (e',s')$, then $\exists\alpha', \A{s'}$ such that $(e,\A{s})\A\rightsquigarrow(e',\A{s'})$, $\alpha'(s)\sqsubseteq\A{s}$, and $\alpha'(s')\sqsubseteq\A{s'}$.
  \end{enumerate}
\end{lem}

\begin{lem}[Preservation of soundness]
  $\:$

  \begin{itemize}
    \item Let $s\in\Config{\Time}$ and $\A{s}\in\AConfig{\ATime}$.
    \item Let all timestamps in the $C$ and $\mem$ component of $s$ be strictly less than the $t$ component.
    \item Let $\A{s}$ be an $\alpha$-sound approximation of $s$ for some $\alpha$.
  \end{itemize}

  Then for all $e$, $\sembracket{e}(s)\lesssim\A{\sembracket{e}}(\A{s})$.
\end{lem}

What's remarkable is that we did not put any constraint on the $\tick$ and $\A{\tick}$ functions.
Moreover, we can guarantee that $\A{\sembracket{e}}(\A{s})$ can be computed.

\begin{thm}[Finiteness of time implies finiteness of abstraction]
  If $\ATime$ is finite,
  \[
    \forall e,\A{s}: |\A{\sembracket{e}}(\A{s})|<\infty
  \]
\end{thm}

\section{Modular Analysis}
Now for separate analysis, we need to define an abstract time on $\ATime_1+\ATime_2$, when the first time domain exports $\A{s'}$ to the second time domain.

Before elaborating on how to add the time domains, we need to define the injection and deletion operators that inject the exported context into the separately analyzed results.
The notation for injecting $C_{1}$ into $C_{2}$ is $\inject{C_{1}}{C_{2}}$, similar to the plugin operator defined above.
\begin{figure}[htb]
  \footnotesize
  \[
    \mapinject(C_{1},C_{2})\triangleq
    \begin{cases}
      []                                                          & C_{2}=[]                \\
      \lambda x^{t}. \mapinject(C_{1},C')                         & C_{2}=\lambda x^{t}. C' \\
      \Let\:x^{t}\:\mapinject(C_{1},C')                           & C_{2}=\Let\:x^{t}\:C'   \\
      \Let\:M\:C_{1}[\mapinject(C_{1},C')]\:\mapinject(C_{1},C'') & C_{2}=\Let\:M\:C'\:C''
    \end{cases}
  \]

  \[
    \inject{C_{1}}{C_{2}}\triangleq C_{1}[\mapinject(C_{1},C_{2})]
  \]

  \[
    \deletepre(C_{1},C_{2})\triangleq
    \begin{cases}
      \deletepre(C_{1}',C_{2}') & (C_{1},C_{2})=(\lambda x^{t}.C_{1}',\lambda x^{t}.C_{2}') \\
      \deletepre(C_{1}',C_{2}') & (C_{1},C_{2})=(\Let\: x^{t}\:C_{1}',\Let\:x^{t}\:C_{2}')  \\
      \deletepre(C_{1}',C_{2}') & (C_{1},C_{2})=(\Let\:M\:C'\:C_{1}',\Let\:M\:C'\:C_{2}')   \\
      C_{2}                     & \text{otherwise}
    \end{cases}
  \]

  \[
    \deletemap(C_{1},C_{2})\triangleq
    \begin{cases}
      []                                                                     & C_{2}=[]               \\
      \lambda x^{t}.\deletemap(C_{1},C')                                     & C_{2}=\lambda x^{t}.C' \\
      \Let\:x^{t}\:\deletemap(C_{1},C')                                      & C_{2}=\Let\:x^{t}\:C'  \\
      \Let\:M\:\deletemap(C_{1},\deletepre(C_{1},C'))\:\deletemap(C_{1},C'') & C_{2}=\Let\:M\:C'\:C''
    \end{cases}
  \]

  \[
    \delete(C_{1},C_{2})\triangleq \deletemap(C_{1},\deletepre(C_{1},C_{2}))
  \]
  \caption{Definitions for the injection and deletion operators.}
\end{figure}

We extend the injection operator to map over all closures in a memory so that $\inject{C}{\A\mem}$ can be defined naturally.

The deletion operation has the expected property that $\delete(C,\inject{C}{C'})=C'$.

Finally, before delving into the definition of the linked time domain, we need to define a filter function that filters the context and memory by membership in each time domain.

\begin{figure}[htb]
  \footnotesize
  \[
    \filter(C,\Time)\triangleq
    \begin{cases}
      []                                             & (C=[])                                   \\
      \lambda x^{t}.\filter(C',\Time)                & (C=\lambda x^{t}.C'\wedge t\in\Time)     \\
      \Let\:x^{t}\:\filter(C',\Time)                 & (C=\Let\:x^{t}\:C'\wedge t\in\Time)      \\
      \Let\:M\:\filter(C',\Time)\:\filter(C'',\Time) & (C=\Let\:M\:C'\:C'')                     \\
      \filter(C',\Time)                              & (C=\lambda x^{t}.C'\wedge t\not\in\Time) \\
      \filter(C',\Time)                              & (C=\Let\:x^{t}\:C'\wedge t\not\in\Time)
    \end{cases}
  \]

  \[
    \filter(v,\Time)\triangleq
    \begin{array}{ll}
      \langle\lambda x.e,\filter(C,\Time)\rangle & (v=\langle\lambda x.e,C\rangle)
    \end{array}
  \]

  \[
    \filter(\A\mem,\Time)\triangleq
    \lambda t\in\Time.\{\filter(v,\Time)|v\in\A{m}(t)\}
  \]
  \caption{Definitions for the filter operation.}
\end{figure}

\begin{definition}[Injection of a configuration]
  $\:$

  \begin{itemize}
    \item Let $\A{s}=(\A{C_1},\A{\mem_1},\A{t_1})$ be an exported configuration from $\ATime_1$.
    \item Let $\A{r}=(\A{V_2},\A{\mem_2},\A{t_2})$ be a result in $\ATime_2$.
  \end{itemize}

  Define $\A{s}\rhd\A{r}\triangleq(\A{C_1}\langle\A{V_2}\rangle,\A{C_1}\langle\A{\mem_2}\rangle\sqcup\A{\mem_1},\A{t_2})$ to be a result in $\ATime_1+\ATime_2$.

  We extend the $\rhd$ operator to inject $\A{s}$ in an element of $(\Expr\times\AConfig{\ATime})\rightarrow{\wp(\AResult{\ATime})}_{\bot}$:
  \[
    \A{s}\rhd\A{a}\triangleq\bigsqcup_{(e,\A{s'})\in\mathsf{dom}(\A{a})}[(e,\A{s}\rhd\A{s'})\mapsto\{\A{s}\rhd\A{r}|\A{r}\in\A{a}(e,\A{s'})\}]
  \]
\end{definition}

\begin{definition}[Addition of time domains]
  $\:$

  \begin{itemize}
    \item Let $\A{s_1}=(\A{C_1},\A{\mem_1},\A{t_1})$ be a configuration in $\ATime_1$, and let $(\ATime_2,\A{\tick})$ be an abstract time.
    \item Define the $\A{\tick_{+}}(\A{s_1})$ function as:
          \[
            \A\tick_{+}(\A{s_1})(\A{C},\A\mem,\A{t},x,\A{v})\triangleq
            \begin{cases}
              \A{t}                                                                      & (\A{t}\in\ATime_1) \\
              \A{\tick}\:\filter(\delete(\A{C_1},(\A{C},\A\mem,\A{t},x,\A{v})),\ATime_2) & (\A{t}\in\ATime_2)
            \end{cases}
          \]
  \end{itemize}

  Then we call the abstract time $(\ATime_1+\ATime_2,\A\tick_{+}(\A{s_1}))$ the linked time of $(\ATime_2,\A{\tick})$ under exported configuration $\A{s_1}$.
\end{definition}

\begin{lem}[Injection preserves soundness]
  $\:$

  Let $s=(C,\mem,t)$ be a configuration in a concrete time $(\Time,\le,\tick)$ with all timestamps in $C,\mem$ strictly less than $t$, and let $\A{s}$ be an $\alpha$-sound approximation of $s$ with timestamps in $\ATime_1$.
  Then there exists an $\alpha'$ such that $\A{s}\rhd([],\varnothing,\A{0})$ is an $\alpha'$-sound approximation of $s$, when $\A{0}\in\ATime_2$.
\end{lem}

\begin{lem}[Injection preserves timestamps under added time]
  $\:$

  Let $\A{s}$ be a configuration in $\ATime_1$, $\A{\sembracket{e}}(\A{s'})$ be the semantics of $e$ under $(\ATime_2,\A\tick)$, and $\A{\sembracket{e}}(\A{s}\rhd\A{s'})$ be the semantics of $e$ under $(\ATime_1+\ATime_2,\A\tick_{+}(\A{s}))$.
  Then:
  \[
    \A{s}\rhd\A{\sembracket{e}}(\A{s'})\sqsubseteq\A{\sembracket{e}}(\A{s}\rhd\A{s'})
  \]
\end{lem}

\begin{definition}[Addition between exported configurations and separately analyzed results]
  $\:$

  Let $\A{s_1}$ be a configuration in $\ATime_1$, and let $\A{a_2}=\A{\sembracket{e}}(\A{s'})$ be the semantics of $e$ under $(\ATime_2,\A\tick)$.
  Define the ``addition'' between $\A{s_1}$ and $\A{a_2}$ as:
  \[
    \A{s_1}\oplus\A{a_2}\triangleq\mathsf{lfp}(\lambda\A{a}.\A{F}(\A{a})\sqcup(\A{s_1}\rhd\A{a_2}))
  \]
\end{definition}

\begin{lem}[Addition of semantics equals semantics under added time]
  \[
    \A{s_1}\oplus\A{\sembracket{e_2}}(\A{s'}) = \A{\sembracket{e}}(\A{s}\rhd\A{s'})
  \]
\end{lem}

\begin{definition}[Auxiliary operators for abstract linking]
  \begin{align*}
    \A\EE\:\A{a}\:e_1\:\A{s}   & \triangleq\A{a}(e_1,\A{s})                                                                                                          & (\text{Exported under }\A{s}\text{ using }\A{a}) \\
    \A\LL\:\A{E}\:e_2          & \triangleq\bigsqcup_{\A{s'}\in \A{E}}(\A{s'}\oplus\A{\sembracket{e_2}}([],\varnothing,\A{0}))                                       & (\text{Reached under }\A{E})                     \\
    \A{\mathsf{F}}\:\A{E}\:e_2 & \triangleq\bigsqcup_{\A{s'}\in \A{E}}(\A{s'}\oplus\A{\sembracket{e_2}}([],\varnothing,\A{0}))(e_2,\A{s'}\rhd([],\varnothing,\A{0})) & (\text{Final results under }\A{E})
  \end{align*}
\end{definition}

\begin{definition}[Abstract linking operator]
  \[
    \A\Link\:\A{a}\:e_1\:e_2\:\A{s}\triangleq\A{a}\sqcup\A\LL\:(\A\EE\:\A{a}\:e_1\:\A{s})\:e_2\sqcup[(\link{e_1}{e_2},\A{s})\mapsto\A{\mathsf{F}}\:(\A\EE\:\A{a}\:e_1\:\A{s})\:e_2]
  \]
\end{definition}

\begin{thm}[Abstract linking]
  Let $s$ be a concrete configuration.

  Let $\A{s}$ be an $\alpha$-sound approximation of $s$ for some $\alpha$, let $\sembracket{e_1}(s)\lesssim\A{a}$, and let $\sembracket{e_1}(s)(e_1,s)\lesssim\A{a}(e_1,\A{s})$. Then:
  \[
    \sembracket{\link{e_1}{e_2}}(s)\lesssim\A\Link\:\A{a}\:e_1\:e_2\:\A{s}
  \]
  and
  \[
    \sembracket{\link{e_1}{e_2}}(s)(\link{e_1}{e_2},s)\lesssim(\A\Link\:\A{a}\:e_1\:e_2\:\A{s})(\link{e_1}{e_2},\A{s})
  \]
\end{thm}

Why did we introduce $\A{a}$, instead of using $\A{\sembracket{e_1}}(\A{s})$ directly for the overapproximation of $\sembracket{e_1}(s)$?

\begin{thm}[Compositionality of abstract linking]
  $\:$

  Let $\{e_i\}_{i\ge 0}$ be a sequence of expressions and let $s$ be a concrete configuration. Define $\{l_i\}_{i\ge 0}$ as:
  \[
    l_0\triangleq e_0\qquad l_{i+1}\triangleq\link{l_i}{e_{i+1}}
  \]
  and define $L_i\triangleq\sembracket{l_i}(s)$. Now, given an $\alpha$-sound approximation $\A{s}$ of $s$, define
  \[
    \A{L_0}\triangleq\A{\sembracket{e_0}}(\A{s})\qquad\A{L_{i+1}}\triangleq\A\Link\:\A{L_i}\:l_i\:e_{i+1}\:\A{s}
  \]
  Then we have:
  \[
    \forall n:L_n\lesssim\A{L_n}
  \]
\end{thm}

%\printbibliography
\end{document}
%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:
