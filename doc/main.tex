%! TEX program = xelatex
\documentclass{article}
\usepackage{geometry}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
}
\usepackage{setspace} % setstretch

\usepackage{graphicx}
\usepackage{kotex}
\usepackage{csquotes}
\usepackage{tabularray}
\UseTblrLibrary{booktabs}
\UseTblrLibrary{counter}

\usepackage{biblatex}
\addbibresource{citations.bib}

%%% Math settings
\usepackage{amssymb,amsmath,amsthm,mathtools} % Before unicode-math
\usepackage[math-style=TeX,bold-style=TeX]{unicode-math}
\newtheorem{lem}{Lemma}[section]
\newtheorem{thm}{Theorem}[section]

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

%%% Font settings
\setmainfont{Libertinus Serif}
\setsansfont{Libertinus Sans}[Scale=MatchUppercase]
\setmonofont{JuliaMono}[Scale=MatchLowercase]
\setmathfont{Libertinus Math} % Before set*hangulfont
\setmathfont{TeX Gyre Pagella Math}[range={\lbrace,\rbrace},Scale=1.1]
\setmainhangulfont{Noto Serif CJK KR}
\setsanshangulfont[BoldFont={* Bold}]{KoPubWorld Dotum.ttf}
\setmonohangulfont{D2Coding}

%%% PL constructs
\usepackage{ebproof}
\ebproofset{left label template=\textsc{[\inserttext]}}

% For simplebnf
\newfontfamily{\fallbackfont}{EB Garamond}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\usepackage{newunicodechar}
\newunicodechar{⩴}{\textfallback{⩴}}

\usepackage{simplebnf}
\RenewDocumentCommand\SimpleBNFDefEq{}{\ensuremath{⩴}}

% because of simplebnf
\newcommand*{\vbar}{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{⩴}}
\newcommand*{\ortype}{\mathrel{|}}
\newcommand*{\cons}{::}

% for complement
\newcommand{\loverbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
\newcommand*{\Expr}{\text{Expr}}
\newcommand*{\ExprVar}{\text{ExprVar}}
\newcommand*{\Module}{\text{Module}}
\newcommand*{\ModVar}{\text{ModVar}}
\newcommand*{\Time}{\mathbb{T}}
\newcommand*{\ATime}{\mathbb{T}^{\#}}
\newcommand*{\Ctx}[1]{\text{Ctx}\:{#1}}
\newcommand*{\Value}[1]{\text{Val}\:{#1}}
\newcommand*{\Mem}[1]{\text{Mem}\:{#1}}
\newcommand*{\AMem}[1]{\text{Mem}^{\#}\:{#1}}
\newcommand*{\link}[2]{{#1}\mathtt{!}{#2}}
\newcommand*{\Stuck}[1]{\underline{#1}^{\times}}
\newcommand*{\Resolved}[1]{\underline{#1}^{\circ}}
\newcommand*{\sembracket}[1]{\lBrack{#1}\rBrack}
\newcommand*{\fin}[2]{{#1}\xrightarrow{\text{fin}}{#2}}
\newcommand*{\addr}{\mathsf{addr}}
\newcommand*{\tick}{\mathsf{tick}}
\newcommand*{\modctx}{\mathsf{ctx}}
\newcommand*{\doubleplus}{+\kern-1.3ex+\kern0.8ex}
\newcommand*{\mdoubleplus}{\ensuremath{\mathbin{+\mkern-10mu+}}}

\title{Semantics for Modular Analysis}
\author{Joonhyup Lee}
\date{}
\begin{document}
\maketitle

\section{Abstract Syntax}

In this section we define the abstract syntax for a simple language that captures the essence of modules and linking.
The language is basically an extension of untyped lambda calculus with modules and the linking operator.

\begin{bnfgrammar}
  $x$ : \in \ExprVar
  ;;
  $M$ : \in \ModVar
  ;;
  $e$ : \in \Expr
  ;;
  $e$ ::= $x$ : identifier, expression
  | $\lambda x.e$ : function
  | $e$ $e$ : application
  | $\link{e}{e}$ : linked expression
  | $\varepsilon$ : empty module
  | $M$ : identifier, module
  | \texttt{let} $x$ $e$ $e$ : let-binding, expression
  | \texttt{let} $M$ $e$ $e$ : let-binding, module
\end{bnfgrammar}

\subsection{Rationale for the design of the simple language}

There are no recursive modules, first-class modules, or functors in the simple language that is defined.
Also, note that the nonterminals for the modules and expressions are not separated. Why is this so?

The rationale for the exclusion of recursive modules/first-class modules/functors is because we want to enforce static scoping.
That is, we need to be able to statically determine where variables were bound when using them.
To enforce static scoping when function applications might return modules, we need to employ signatures to project the dynamically computed modules onto a statically known context.
Concretely, we need to define signatures $S$ where $\lambda M:>S.e$ statically resolves the context when $M$ is used in the body $e$, and $e:>S$ enforces that a dynamic computation is resolved into one static form.

The rationale for not separating modules and expressions in the syntax is because we want to utilize the linking operator to link both modules to expressions and modules to modules.
That is, we want expressions to be parsed as $(m_1!m_2)!e$.
$\link{m_1}{m_2}$ links a module with a module, and $(m_1!m_2)!e$ links a module with an expression.
Why this is convenient will be clear when we explain separate analysis; we want to link modules with modules as well as expressions.

\section{Big-Step Operational Semantics}

In this section we give the big-step operational semantics for the dynamic execution of the module language.
The big-step evaluation relation relates the initial state(memory and time) and configuration(the subexpression being evaluated, and the surrounding dynamic context) with the resulting state and value.

This relation is nonstandard in that the \emph{environment} that is often used to define closures in the call-by-value dynamics is not a finite map from variables to values.
Rather, the surrounding \emph{syntactic} context annotated with the \emph{binding times} for the variables serve as the environment.
To access the value of the variable $x$ from the context $C$, one has to read off the closest binding time from the context and look up the value bound at that time from the memory.
To access the exported context from the variable $M$, one has to look up the exported context from $C$, not from the memory.

This separation between where we store modules and where we store the evaluated values from expressions emphasizes the fact that \emph{where} the variables are bound is guided by syntax.
The only thing that is dynamic is \emph{when} the variables are bound, which is represented by the time component.

Now, we start by defining what we mean by \emph{time} and \emph{context}, which is the essence of our model.

\subsection{Time and Context}

We first define sets that are parametrized by our choice of the time domain, mainly the \emph{value}, \emph{memory}, and \emph{context} domains.
Also, we present the notational conventions used in this paper to represent members of each domain.

\begin{bnfgrammar}
  $t$ : \in \Time
  ;;
  $v$ : \in \Value{\Time}
  ;;
  $C$ : \in \Ctx{\Time}
  ;;
  $V$ : \in \Value{\Time}+\Ctx{\Time}
  ;;
  $\sigma$ : \in \Mem{\Time} \triangleq \fin{\Time}{\Value{\Time}}
  ;;
  $C$ ::= [] : hole
  | $\lambda x^{t}.C$ : function parameter binding
  | \texttt{let} $x^{t}$ $C$ : let expression binding
  | \texttt{let} $M$ $C$ $C$ : let module context binding
  ;;
  $v$ ::= $\langle \lambda x.e, C \rangle$ : closure
\end{bnfgrammar}

Above, there are no constraints placed upon the set $\Time$.
Now we give the conditions that the concrete time domain must satisfy.

\begin{definition}[Concrete time]
  $(\Time, \le, \tick)$ is a \emph{concrete time} when
  \begin{enumerate}
    \item $(\Time, \le)$ is a total order.
    \item $\tick\in\Ctx{\Time}\rightarrow\Mem{\Time}\rightarrow\Time\rightarrow\ExprVar\rightarrow\Value{\Time}\rightarrow\Time$ gives a strictly larger timestamp. That is,
          \[\forall C\in\Ctx{\Time}, \sigma\in\Mem{\Time},t\in\Time,x\in\ExprVar,v\in\Value{\Time}, t < \tick\:C\:\sigma\:t\:x\:v.\]
          $\tick$ updates the timestamp when $v$ is bound to $x$ under the context $C$ and state $(\sigma, t)$.
  \end{enumerate}
\end{definition}

Now for the auxiliary operators that is used when defining the evaluation relation.
We first define the plugin operator for the dynamic context.
\[
  C_{1}[C_{2}]\triangleq
  \begin{cases}
    C_{2}                           & (C_{1}=[])                       \\
    \lambda x^{t}.C'[C_{2}]         & (C_{1}=\lambda x^{t}.C')         \\
    \mathtt{let}\:x^{t}\:C'[C_{2}]  & (C_{1}=\mathtt{let}\:x^{t}\:C')  \\
    \mathtt{let}\:M\:C'\:C''[C_{2}] & (C_{1}=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]

Next, the function that extracts the address for an $\ExprVar$ must be defined.
\[
  \addr(C,x)\triangleq
  \begin{cases}
    \bot         & (C=[])                                                           \\
    \bot         & (C=\lambda x'^{t}.C'\wedge x'\neq x\wedge \addr(C',x)=\bot)      \\
    \bot         & (C=\mathtt{let}\:x'^{t}C'\wedge x'\neq x\wedge \addr(C',x)=\bot) \\
    t            & (C=\lambda x'^{t}.C'\wedge x'= x\wedge \addr(C',x)=\bot)         \\
    t            & (C=\mathtt{let}\:x'^{t}C'\wedge x'= x\wedge \addr(C',x)=\bot)    \\
    t'           & (C=\lambda x'^{t}.C'\wedge \addr(C',x)=t')                       \\
    t'           & (C=\mathtt{let}\:x'^{t}\:C'\wedge \addr(C',x)=t')                \\
    \addr(C'',x) & (C=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]
Finally, the function that looks up the dynamic context bound to a module variable $M$ must be defined.
\[
  \modctx(C,M)\triangleq
  \begin{cases}
    \bot           & (C=[])                                                             \\
    C'             & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'= M\wedge\modctx(C'',M)=\bot) \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge\modctx(C'',M)\neq\bot)          \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'\neq M)                       \\
    \modctx(C',M)  & (C=\lambda x^{t}.C')                                               \\
    \modctx(C',M)  & (C=\mathtt{let}\:x^{t}\:C')
  \end{cases}
\]

\subsection{The Evaluation Relation}

Now we are in a position to define the big-step evaluation relation.
The relation $\Downarrow$ relates $(e,C,\sigma,t)\in\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time$ with
$(V,\sigma,t)\in(\Value{\Time}+\Ctx{\Time})\times\Mem{\Time}\times\Time$.
Note that we constrain whether the evaluation relation returns $v\in\Value{\Time}$(when the expression being evaluated is not a module) or $C\in\Ctx{\Time}$ by the definition of the relation.

\begin{prooftree*}
  \hypo{t_{x}=\addr(C,x)}
  \hypo{\sigma(t_{x}) = v}
  \infer[left label=ExprVar]2{
  (x, C, \sigma, t)
  \Downarrow
  (v, \sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \infer[left label=Fn]0{
  (\lambda x.e, C, \sigma, t)
  \Downarrow
  (\langle\lambda x.e, C\rangle, \sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (e_{1}, C, \sigma, t)
      \Downarrow
      (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \sigma_{\lambda}, t_{\lambda}) \\
      (e_{2}, C, \sigma_{\lambda}, t_{\lambda})
      \Downarrow
      (v, \sigma_{a}, t_{a})                                                            \\
      (e_{\lambda}, C_{\lambda}[\lambda x^{t_{a}}.[]], \sigma_{a}[t_{a}\mapsto(v, C_{a})], \tick\:C\:\sigma_{a}\:t_{a}\:x\:v)
      \Downarrow
      (v', \sigma',t')
    \end{matrix}
  }
  \infer[left label={App}]1{
  (e_{1}\:e_{2}, C, \sigma, t)
  \Downarrow
  (v', \sigma',t')
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (e_{1}, C, \sigma, t)
      \Downarrow
      (C', \sigma', t') \\
      (e_{2}, C', \sigma', t')
      \Downarrow
      (V, \sigma'', t'')
    \end{matrix}
  }
  \infer[left label=Linking]1{
  (\link{e_{1}}{e_{2}}, C, \sigma, t)
  \Downarrow
  (V, \sigma'', t'')
  }
\end{prooftree*}
Note that we do not constrain whether $v$ or $C$ is returned by $e_{2}$ in the linking case.
That is, linking may return either values or modules.

\begin{prooftree*}
  \infer[left label=Empty]0{
  (\varepsilon, C, \sigma, t)
  \Downarrow
  (C, \sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{C'=\modctx(C,M)}
  \infer[left label=ModVar]1{
  (M, C, \sigma, t)
  \Downarrow
  (C', \sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (e_{1}, C, \sigma, t)
      \Downarrow
      (v, \sigma', t') \\
      (e_{2}, C[\mathtt{let}\:x^{t'}\:[]], \sigma'[t'\mapsto v], \tick\:C\:\sigma'\:t'\:x\:v)
      \Downarrow
      (C', \sigma'', t'')
    \end{matrix}
  }
  \infer[left label=LetE]1{
  (\mathtt{let}\:x\:e_1\:e_2, C, \sigma, t)
  \Downarrow
  (C', \sigma'', t'')
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (e_{1}, C, \sigma, t)
      \Downarrow
      (C', \sigma', t') \\
      (e_{2}, C[\mathtt{let}\:M\:C'\:[]], \sigma', t')
      \Downarrow
      (C'', \sigma'', t'')
    \end{matrix}
  }
  \infer[left label=LetM]1{
  (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \sigma, t)
  \Downarrow
  (C'', \sigma'', t'')
  }
\end{prooftree*}

\section{Collecting Semantics}

We want to enable separate analysis without making any assumptions 

\begin{definition}[Reachable stuck states]
  \[
    \Stuck{e}(C,\sigma,t)\triangleq\{(e',C',\sigma,t')|(e,C,\sigma,t)\rightsquigarrow(e',C',\sigma',t')\wedge\forall v,\sigma'',t'',\lnot((e',C'\sigma',t')\Downarrow(v,\sigma'',t''))\}
  \]
\end{definition}

\begin{definition}[Reachable resolved states]
  \[
    \Resolved{e}(C,\sigma,t)\triangleq\{((e',C',\sigma',t'),(v,\sigma'',t''))|(e,C,\sigma,t)\rightsquigarrow(e',C',\sigma',t')\wedge(e',C'\sigma',t')\Downarrow(v,\sigma'',t'')\}
  \]
\end{definition}

\begin{definition}[Collecting semantics]
  The semantics for an expression $e$ under context $C$, memory $\sigma$ and time $t$ is:
  \[
    \sembracket{e}(C,\sigma,t)\triangleq(\Resolved{e}(C,\sigma,t),\Stuck{e}(C,\sigma,t))
  \]
\end{definition}

\begin{lem}[Separation of linking, resolved part]
  \[
    \Resolved{\link{e_1}{e_2}}(C,\sigma,t)=
    \Resolved{e_1}(C,\sigma,t)\cup\left(\bigcup_{(e_1,C,\sigma,t)\Downarrow(C',\sigma',t')}{\Resolved{e_2}(C',\sigma',t')}\right)
  \]
\end{lem}

\begin{lem}[Separation of linking, stuck part]
  \[
    \Stuck{\link{e_1}{e_2}}(C,\sigma,t)=
    \Stuck{e_1}(C,\sigma,t)\cup\left(\bigcup_{(e_1,C,\sigma,t)\Downarrow(C',\sigma',t')}{\Stuck{e_2}(C',\sigma',t')}\right)
  \]
\end{lem}

Now we only need a way to calculate $\sembracket{e_{2}}(C',\sigma',t')$ by utilizing the separately analyzed $\sembracket{e_{2}}([],\varnothing,t_{0})$.



\begin{lem}[Separate analysis]
\end{lem}

\printbibliography
\end{document}
%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:
