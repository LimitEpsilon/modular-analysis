%! TEX program = xelatex
\documentclass{article}
\usepackage{geometry}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
}
\usepackage{setspace} % setstretch

\usepackage{graphicx}
\usepackage{kotex}
\usepackage{csquotes}
\usepackage{tabularray}
\UseTblrLibrary{booktabs}
\UseTblrLibrary{counter}

\usepackage{biblatex}
\addbibresource{citations.bib}

%%% Math settings
\usepackage{amssymb,amsmath,mathtools} % Before unicode-math
\usepackage[math-style=TeX,bold-style=TeX]{unicode-math}
\newtheorem{clm}{Claim}[section]

%%% Font settings
\setmainfont{Libertinus Serif}
\setsansfont{Libertinus Sans}[Scale=MatchUppercase]
\setmonofont{JuliaMono}[Scale=MatchLowercase]
\setmathfont{Libertinus Math} % Before set*hangulfont
\setmathfont{TeX Gyre Pagella Math}[range={\lbrace,\rbrace},Scale=1.1]
\setmainhangulfont{Noto Serif CJK KR}
\setsanshangulfont[BoldFont={* Bold}]{KoPubWorld Dotum.ttf}
\setmonohangulfont{D2Coding}

%%% PL constructs
\usepackage{ebproof}
\ebproofset{left label template=\textsc{[\inserttext]}}

% For simplebnf
\newfontfamily{\fallbackfont}{EB Garamond}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\usepackage{newunicodechar}
\newunicodechar{⩴}{\textfallback{⩴}}

\usepackage{simplebnf}
\RenewDocumentCommand\SimpleBNFDefEq{}{\ensuremath{⩴}}

% because of simplebnf
\newcommand*{\vbar}{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{⩴}}
\newcommand*{\ortype}{\mathrel{|}}
\newcommand*{\cons}{::}

% for complement
\newcommand{\loverbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
\newcommand*{\Expr}{\mathit{Expr}}
\newcommand*{\ExprVar}{\mathit{ExprVar}}
\newcommand*{\Module}{\mathit{Module}}
\newcommand*{\ModVar}{\mathit{ModVar}}
\newcommand*{\Path}{\text{Path}}
\newcommand*{\Ctx}{\text{Ctx}}
\newcommand*{\link}[2]{{#1}\mathtt{!}{#2}}
\newcommand*{\sembracket}[1]{\lBrack{#1}\rBrack}
\newcommand*{\fin}[2]{{#1}\xrightarrow{\text{fin}}{#2}}
\newcommand*{\addr}{\mathsf{addr}}
\newcommand*{\level}{\mathsf{level}}
\newcommand*{\modctx}{\mathsf{ctx}}
\newcommand*{\doubleplus}{+\kern-1.3ex+\kern0.8ex}
\newcommand*{\mdoubleplus}{\ensuremath{\mathbin{+\mkern-10mu+}}}

\title{Semantics for Modular Analysis}
\author{Joonhyup Lee}
\date{}
\begin{document}
\maketitle

\section{Abstract Syntax}

In this section we define the abstract syntax for a simple language that captures the essence of modules and linking.
The language is basically an extension of untyped lambda calculus with modules and the linking operator.

\begin{bnfgrammar}
  $x$ : \in \ExprVar
  ;;
  $M$ : \in \ModVar
  ;;
  $m$ ::= $\varepsilon$ : empty module
  | $M$ : identifier, module
  | \texttt{let} $x$ $e$ $m$ : let-binding, expression
  | \texttt{let} $M$ $m$ $m$ : let-binding, module
  ;;
  $e$ ::= $x$ : identifier, expression
  | $\lambda x.e$ : function
  | $e$ $e$ : application
  | $\link{m}{e}$ : linked expression
\end{bnfgrammar}

\subsection{Rationale for the design of the simple language}

We want to statically determine what names are available.
This was the simplest language I could think of that enforces this criterion.
Of course, modules with signatures(ref: Rossberg, 1ML) enforce this criterion as well, but that is not the point here.
The abstraction that we make is possible iff the context of the expression to be evaluated can always be determined statically.
Thus, the same abstraction can readily be extended to any other language satisfying this criterion.

\section{Big-Step Operational Semantics}

In this section we give the big-step operational semantics for the dynamic execution of the language defined previously.
The relation which gives the semantics relates the initial state(memory and time) and configuration(the subexpression being evaluated, and the surrounding dynamic context) with the resulting state and configuration.

This relation is nonstandard in that the \textit{environment} that is often used to define closures in the call-by-value dynamics is not a finite map from variables to values.
Rather, the surrounding \textit{syntactic} context annotated with the \textit{binding times} for the variables together with the memory serves as the environment.
To access the value of the variable $x$ from the context $C$, one has to read the list of times starting from the nearest binding time for $x$ in the surrounding context up until the root, and use that list as an address to search the memory for the value.

The reason the semantics is defined as such is for the convenience and precision of abstraction.
One only has to finitize the time component to make the search space finite.
Furthermore, one can reason precisely about how the syntactic change on the surrounding context affects the evaluation of the expression inside the hole of $C$ by including $C$ in the configuration.

Before presenting the inference rules for the big-step relation, we first present the domains for the state($\sigma, t$) and configuration($C, e$).
The concrete time $t$ is defined to be a natural number, $C$ is inside the inductively defined set $\Ctx$,
and $\sigma$ is a finite map from $\Path\triangleq\mathsf{list}(\text{time})$ to $\mathbb{V}\times\Ctx$, when $\mathbb{V}$ is the subset of the set of expressions that satisfy the $\textit{value}$ predicate.
In this language, only functions satisfy this predicate.

\begin{bnfgrammar}
  $t$ : \in \mathbb{N}
  ;;
  $p$ : \in \Path
  ;;
  $C$ : \in \Ctx
  ;;
  $\sigma$ : \in \fin{\Path}{\mathbb{V}\times\mathbb{C}}
  ;;
  $p$ ::= \textsf{nil} : nil
  | $t$\cons$p$ : cons
  ;;
  $C$ ::= [] : hole
  | $\lambda x^{t}.C$ : function parameter binding
  | \texttt{let} $x^{t}$ $C$ : let expression binding
  | \texttt{let} $M$ $C$ $C$ : let module context binding
\end{bnfgrammar}

We define the plugin operator for the dynamic context.
\[
  C_{1}[C_{2}]\triangleq
  \begin{cases}
    C_{2}                           & (C_{1}=[])                       \\
    \lambda x^{t}.C'[C_{2}]         & (C_{1}=\lambda x^{t}.C')         \\
    \mathtt{let}\:x^{t}\:C'[C_{2}]  & (C_{1}=\mathtt{let}\:x^{t}\:C')  \\
    \mathtt{let}\:M\:C'\:C''[C_{2}] & (C_{1}=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]

Now, for the operational semantics, the functions that extract information about the binding times from the dynamic context must be defined.
The first function to be defined is the $\level$ function, which returns the list of binding times counted from the hole upwards.
\[
  \level(C) \triangleq
  \begin{cases}
    \mathsf{nil}              & (C=[])                                           \\
    \level(C')\mdoubleplus[t] & (C=\lambda x^{t}.C'\lor \mathtt{let\:}x^{t}\:C') \\
    \level(C'')               & (C=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]
Also, the function that calculates the address from the dynamic context $C$ and variable $x$ must be defined.
Note that $\mathsf{nil}$ is used as the null address, which should never be accessed.
\[
  \addr(C,x)\triangleq
  \begin{cases}
    \mathsf{nil}       & (C=[])                                                                   \\
    \mathsf{nil}       & (C=\lambda x'^{t}.C'\wedge x'\neq x\wedge \addr(C',x)=\mathsf{nil})      \\
    \mathsf{nil}       & (C=\mathtt{let}\:x'^{t}C'\wedge x'\neq x\wedge \addr(C',x)=\mathsf{nil}) \\
    [t]                & (C=\lambda x'^{t}.C'\wedge x'= x\wedge \addr(C',x)=\mathsf{nil})         \\
    [t]                & (C=\mathtt{let}\:x'^{t}C'\wedge x'= x\wedge \addr(C',x)=\mathsf{nil})    \\
    p \mdoubleplus [t] & (C=\lambda x'^{t}.C'\wedge \addr(C',x)=p\neq\mathsf{nil})                \\
    p \mdoubleplus [t] & (C=\mathtt{let}\:x'^{t}\:C'\wedge \addr(C',x)=p\neq\mathsf{nil})         \\
    \addr(C'',x)       & (C=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]
Finally, the function that looks up the dynamic context bound to a module variable $M$ must be defined.
Note that this function returns $\bot$ when the module $M$ is not found.
\[
  \modctx(C,M)\triangleq
  \begin{cases}
    \bot           & (C=[])                                                             \\
    C'             & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'= M\wedge\modctx(C'',M)=\bot) \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge\modctx(C'',M)\neq\bot)          \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'\neq M)                       \\
    \modctx(C',M)  & (C=\lambda x^{t}.C')                                               \\
    \modctx(C',M)  & (C=\mathtt{let}\:x^{t}\:C')
  \end{cases}
\]

Now we are in a position to define the big-step evaluation relation.

\begin{prooftree*}
  \hypo{p_{x}=\addr(C,x)}
  \hypo{p_{x}\neq\mathsf{nil}}
  \infer[left label=ExprVar]2{
  (x, C), (\sigma, t)
  \Downarrow
  \sigma(p_{x}), (\sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \infer[left label=Fn]0{
  (\lambda x.e, C), (\sigma, t)
  \Downarrow
  (\lambda x.e, C), (\sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (e_{1}, C), (\sigma, t)
      \Downarrow
      (\lambda x.e_{\lambda}, C_{\lambda}), (\sigma_{\lambda}, t_{\lambda}) \\
      (e_{2}, C), (\sigma_{\lambda}, t_{\lambda})
      \Downarrow
      (v, C_{a}), (\sigma_{a}, t_{a})                                       \\
      (e_{\lambda}, C_{\lambda}[\lambda x^{t_{a}}.[]]), (\sigma_{a}[t_{a}::\level(C_{\lambda})\mapsto(v, C_{a})], t_{a} + 1)
      \Downarrow
      (v', C'), (\sigma',t')
    \end{matrix}
  }
  \infer[left label={App}]1{
  (e_{1}\:e_{2}, C), (\sigma, t)
  \Downarrow
  (v',C'), (\sigma',t')
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (m, C), (\sigma, t)
      \Downarrow
      C', (\sigma', t') \\
      (e, C'), (\sigma', t')
      \Downarrow
      (v, C''), (\sigma'', t'')
    \end{matrix}
  }
  \infer[left label=Linking]1{
  (\link{m}{e}, C), (\sigma, t)
  \Downarrow
  (v, C''), (\sigma'', t'')
  }
\end{prooftree*}

\begin{prooftree*}
  \infer[left label=Empty]0{
  (\varepsilon, C), (\sigma, t)
  \Downarrow
  C, (\sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{C'=\modctx(C,M)}
  \hypo{C'\neq\bot}
  \infer[left label=ModVar]2{
  (M, C), (\sigma, t)
  \Downarrow
  C', (\sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (e, C), (\sigma, t)
      \Downarrow
      (v, C'), (\sigma', t') \\
      (m, C[\mathtt{let}\:x^{t'}\:[]]), (\sigma_{v}[t'::\level(C)\mapsto(v,C')], t'+1)
      \Downarrow
      C'', (\sigma'', t'')
    \end{matrix}
  }
  \infer[left label=LetE]1{
  (\mathtt{let}\:x\:e\:m,C), (\sigma, t)
  \Downarrow
  C'', (\sigma'', t'')
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (m_{1}, C), (\sigma, t)
      \Downarrow
      C', (\sigma', t') \\
      (m_{2}, C[\mathtt{let}\:M\:C'\:[]]), (\sigma'[t'::\level(C')\mapsto(p', C')], t'+1)
      \Downarrow
      C'', (\sigma'', t'')
    \end{matrix}
  }
  \infer[left label=LetM]1{
  (\mathtt{let}\:M\:m_{1}\:m_{2}, C), (\sigma, t)
  \Downarrow
  C'', (\sigma'', t'')
  }
\end{prooftree*}

To 

\section{Collecting Semantics}

Now we make the semantics of a module $m$ and the semantics of an expression $e$ explicit.

\printbibliography
\end{document}
%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:
