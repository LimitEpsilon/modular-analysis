%! TEX program = xelatex
\documentclass{article}
\usepackage{geometry}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
}
\usepackage{setspace} % setstretch

\usepackage{graphicx}
\usepackage{kotex}
\usepackage{csquotes}
\usepackage{tabularray}
\UseTblrLibrary{booktabs}
\UseTblrLibrary{counter}

\usepackage{biblatex}
\addbibresource{citations.bib}

%%% Math settings
\usepackage{amssymb,amsmath,amsthm,mathtools} % Before unicode-math
\usepackage[math-style=TeX,bold-style=TeX]{unicode-math}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{lem}{Lemma}[section]
\newtheorem{thm}{Theorem}[section]

%%% Font settings
\setmainfont{Libertinus Serif}
\setsansfont{Libertinus Sans}[Scale=MatchUppercase]
\setmonofont{JuliaMono}[Scale=MatchLowercase]
\setmathfont{Libertinus Math} % Before set*hangulfont
\setmathfont{TeX Gyre Pagella Math}[range={\lbrace,\rbrace},Scale=1.1]
\setmainhangulfont{Noto Serif CJK KR}
\setsanshangulfont[BoldFont={* Bold}]{KoPubWorld Dotum.ttf}
\setmonohangulfont{D2Coding}

%%% PL constructs
\usepackage{ebproof}
\ebproofset{left label template=\textsc{[\inserttext]}}

% For simplebnf
\newfontfamily{\fallbackfont}{EB Garamond}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\usepackage{newunicodechar}
\newunicodechar{⩴}{\textfallback{⩴}}

\usepackage{simplebnf}
\RenewDocumentCommand\SimpleBNFDefEq{}{\ensuremath{⩴}}

% because of simplebnf
\newcommand*{\vbar}{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{⩴}}
\newcommand*{\ortype}{\mathrel{|}}
\newcommand*{\cons}{::}

\def\ovbarw{1.2mu}
\def\ovbarh{0.8}
\newcommand*{\ovbar}[1]{\mkern \ovbarw\overline{\mkern-\ovbarw{\smash{#1}\scalebox{1}[\ovbarh]{\vphantom{i}}}\mkern-\ovbarw}\mkern \ovbarw}
\newcommand*{\A}[1]{{#1}^{\#}}
\newcommand*{\Expr}{\text{Expr}}
\newcommand*{\ExprVar}{\text{ExprVar}}
\newcommand*{\Module}{\text{Module}}
\newcommand*{\ModVar}{\text{ModVar}}
\newcommand*{\Time}{\mathbb{T}}
\newcommand*{\ATime}{\mathbb{T}^{\#}}
\newcommand*{\Ctx}[1]{\text{Ctx}\:{#1}}
\newcommand*{\Value}[1]{\text{Val}\:{#1}}
\newcommand*{\AValue}[1]{\text{Val}^{\#}\:{#1}}
\newcommand*{\Mem}[1]{\text{Mem}\:{#1}}
\newcommand*{\AMem}[1]{\text{Mem}^{\#}\:{#1}}
\newcommand*{\link}[2]{{#1}\mathtt{!}{#2}}
\newcommand*{\Reach}[1]{\underline{#1}^{*}}
\newcommand*{\Resolved}[1]{\underline{#1}^{\circ}}
\newcommand*{\sembracket}[1]{\lBrack{#1}\rBrack}
\newcommand*{\fin}[2]{{#1}\xrightarrow{\text{fin}}{#2}}
\newcommand*{\addr}{\mathsf{addr}}
\newcommand*{\tick}{\mathsf{tick}}
\newcommand*{\modctx}{\mathsf{ctx}}
\newcommand*{\mapinject}{\mathsf{map\_inject}}
\newcommand*{\inject}[2]{{#1}\langle{#2}\rangle}
\newcommand*{\deletepre}{\mathsf{delete\_prefix}}
\newcommand*{\deletemap}{\mathsf{delete\_map}}
\newcommand*{\delete}{\mathsf{delete}}
\newcommand*{\filter}{\mathsf{filter}}
\newcommand*{\Let}{\mathtt{let}}
\newcommand*{\doubleplus}{+\kern-1.3ex+\kern0.8ex}
\newcommand*{\mdoubleplus}{\ensuremath{\mathbin{+\mkern-10mu+}}}

\title{Semantics for Modular Analysis}
\author{Joonhyup Lee}
\date{}
\begin{document}
\maketitle

\section{Abstract Syntax}

In this section we define the abstract syntax for a simple language that captures the essence of modules and linking.
The language is basically an extension of untyped lambda calculus with modules and the linking operator.

\begin{bnfgrammar}
  $x$ : \in \ExprVar
  ;;
  $M$ : \in \ModVar
  ;;
  $e$ : \in \Expr
  ;;
  $e$ ::= $x$ : identifier, expression
  | $\lambda x.e$ : function
  | $e$ $e$ : application
  | $\link{e}{e}$ : linked expression
  | $\varepsilon$ : empty module
  | $M$ : identifier, module
  | $\Let$ $x$ $e$ $e$ : let-binding, expression
  | $\Let$ $M$ $e$ $e$ : let-binding, module
\end{bnfgrammar}

\subsection{Rationale for the design of the simple language}

There are no recursive modules, first-class modules, or functors in the simple language that is defined.
Also, note that the nonterminals for the modules and expressions are not separated. Why is this so?

The rationale for the exclusion of recursive modules/first-class modules/functors is because we want to enforce static scoping.
That is, we need to be able to statically determine where variables were bound when using them.
To enforce static scoping when function applications might return modules, we need to employ signatures to project the dynamically computed modules onto a statically known context.
Concretely, we need to define signatures $S$ where $\lambda M:>S.e$ statically resolves the context when $M$ is used in the body $e$, and $e:>S$ enforces that a dynamic computation is resolved into one static form.

The rationale for not separating modules and expressions in the syntax is because we want to utilize the linking operator to link both modules to expressions and modules to modules.
That is, we want expressions to be parsed as $(m_1!m_2)!e$.
$\link{m_1}{m_2}$ links a module with a module, and $(m_1!m_2)!e$ links a module with an expression.
Why this is convenient will be clear when we explain separate analysis; we want to link modules with modules as well as expressions.

\section{Big-Step Operational Semantics}

In this section we give the big-step operational semantics for the dynamic execution of the module language.
The big-step evaluation relation relates the initial configuration(context, memory and time) and expression with the resulting value and state.

This relation is nonstandard in that the \emph{environment} that is often used to define closures in the call-by-value dynamics is not a finite map from variables to values.
Rather, the surrounding \emph{syntactic} context annotated with the \emph{binding times} for the variables serve as the environment.
To access the value of the variable $x$ from the context $C$, one has to read off the closest binding time from the context and look up the value bound at that time from the memory.
To access the exported context from the variable $M$, one has to look up the exported context from $C$, not from the memory.

This separation between where we store modules and where we store the evaluated values from expressions emphasizes the fact that \emph{where} the variables are bound is guided by syntax.
The only thing that is dynamic is \emph{when} the variables are bound, which is represented by the time component.

Now, we start by defining what we mean by \emph{time} and \emph{context}, which is the essence of our model.

\subsection{Time and Context}

We first define sets that are parametrized by our choice of the time domain, mainly the \emph{value}, \emph{memory}, and \emph{context} domains.
Also, we present the notational conventions used in this paper to represent members of each domain.

\begin{bnfgrammar}
  $t$ : \in \Time
  ;;
  $v$ : \in \Value{\Time}
  ;;
  $C$ : \in \Ctx{\Time}
  ;;
  $V$ : \in \Value{\Time}+\Ctx{\Time}
  ;;
  $\sigma$ : \in \Mem{\Time} \triangleq \fin{\Time}{\Value{\Time}}
  ;;
  $C$ ::= [] : hole
  | $\lambda x^{t}.C$ : function parameter binding
  | $\Let$ $x^{t}$ $C$ : let expression binding
  | $\Let$ $M$ $C$ $C$ : let module context binding
  ;;
  $v$ ::= $\langle \lambda x.e, C \rangle$ : closure
\end{bnfgrammar}

Above, there are no constraints placed upon the set $\Time$.
Now we give the conditions that the concrete time domain must satisfy.

\begin{definition}[Concrete time]
  $(\Time, \le, \tick)$ is a \emph{concrete time} when
  \begin{enumerate}
    \item $(\Time, \le)$ is a total order.
    \item $\tick\in\Ctx{\Time}\rightarrow\Mem{\Time}\rightarrow\Time\rightarrow\ExprVar\rightarrow\Value{\Time}\rightarrow\Time$ gives a strictly larger timestamp. That is,
          \[\forall C\in\Ctx{\Time}, \sigma\in\Mem{\Time},t\in\Time,x\in\ExprVar,v\in\Value{\Time}: t < \tick\:C\:\sigma\:t\:x\:v.\]
          $\tick$ updates the timestamp when $v$ is bound to $x$ under the context $C$ and state $(\sigma, t)$.
  \end{enumerate}
\end{definition}

Now for the auxiliary operators that is used when defining the evaluation relation.
We first define the plugin operator for the dynamic context.
\[
  C_{1}[C_{2}]\triangleq
  \begin{cases}
    C_{2}                           & (C_{1}=[])                       \\
    \lambda x^{t}.C'[C_{2}]         & (C_{1}=\lambda x^{t}.C')         \\
    \mathtt{let}\:x^{t}\:C'[C_{2}]  & (C_{1}=\mathtt{let}\:x^{t}\:C')  \\
    \mathtt{let}\:M\:C'\:C''[C_{2}] & (C_{1}=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]

Next, the function that extracts the address for an $\ExprVar$ must be defined.
\[
  \addr(C,x)\triangleq
  \begin{cases}
    \bot         & (C=[])                                                           \\
    \bot         & (C=\lambda x'^{t}.C'\wedge x'\neq x\wedge \addr(C',x)=\bot)      \\
    \bot         & (C=\mathtt{let}\:x'^{t}C'\wedge x'\neq x\wedge \addr(C',x)=\bot) \\
    t            & (C=\lambda x'^{t}.C'\wedge x'= x\wedge \addr(C',x)=\bot)         \\
    t            & (C=\mathtt{let}\:x'^{t}C'\wedge x'= x\wedge \addr(C',x)=\bot)    \\
    t'           & (C=\lambda x'^{t}.C'\wedge \addr(C',x)=t')                       \\
    t'           & (C=\mathtt{let}\:x'^{t}\:C'\wedge \addr(C',x)=t')                \\
    \addr(C'',x) & (C=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]
Finally, the function that looks up the dynamic context bound to a module variable $M$ must be defined.
\[
  \modctx(C,M)\triangleq
  \begin{cases}
    \bot           & (C=[])                                                             \\
    C'             & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'= M\wedge\modctx(C'',M)=\bot) \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge\modctx(C'',M)\neq\bot)          \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'\neq M)                       \\
    \modctx(C',M)  & (C=\lambda x^{t}.C')                                               \\
    \modctx(C',M)  & (C=\mathtt{let}\:x^{t}\:C')
  \end{cases}
\]

\subsection{The Evaluation Relation}

Now we are in a position to define the big-step evaluation relation.
The relation $\Downarrow$ relates $(e,C,\sigma,t)\in\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time$ with
$(V,\sigma,t)\in(\Value{\Time}+\Ctx{\Time})\times\Mem{\Time}\times\Time$.
Note that we constrain whether the evaluation relation returns $v\in\Value{\Time}$(when the expression being evaluated is not a module) or $C\in\Ctx{\Time}$ by the definition of the relation.

\[
  \begin{prooftree}
    \hypo{t_{x}=\addr(C,x)}
    \hypo{\sigma(t_{x}) = v}
    \infer[left label=ExprVar]2{
    (x, C, \sigma, t)
    \Downarrow
    (v, \sigma, t)
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \infer[left label=Fn]0{
    (\lambda x.e, C, \sigma, t)
    \Downarrow
    (\langle\lambda x.e, C\rangle, \sigma, t)
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \sigma_{\lambda}, t_{\lambda}) \\
        (e_{2}, C, \sigma_{\lambda}, t_{\lambda})
        \Downarrow
        (v, \sigma_{a}, t_{a})                                                            \\
        (e_{\lambda}, C_{\lambda}[\lambda x^{t_{a}}.[]], \sigma_{a}[t_{a}\mapsto v], \tick\:C\:\sigma_{a}\:t_{a}\:x\:v)
        \Downarrow
        (v', \sigma',t')
      \end{matrix}
    }
    \infer[left label={App}]1{
    (e_{1}\:e_{2}, C, \sigma, t)
    \Downarrow
    (v', \sigma',t')
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (C', \sigma', t') \\
        (e_{2}, C', \sigma', t')
        \Downarrow
        (V, \sigma'', t'')
      \end{matrix}
    }
    \infer[left label=Linking]1{
    (\link{e_{1}}{e_{2}}, C, \sigma, t)
    \Downarrow
    (V, \sigma'', t'')
    }
  \end{prooftree}
\]
Note that we do not constrain whether $v$ or $C$ is returned by $e_{2}$ in the linking case.
That is, linking may return either values or modules.

\[
  \begin{prooftree}
    \infer[left label=Empty]0{
    (\varepsilon, C, \sigma, t)
    \Downarrow
    (C, \sigma, t)
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{C'=\modctx(C,M)}
    \infer[left label=ModVar]1{
    (M, C, \sigma, t)
    \Downarrow
    (C', \sigma, t)
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (v, \sigma', t') \\
        (e_{2}, C[\mathtt{let}\:x^{t'}\:[]], \sigma'[t'\mapsto v], \tick\:C\:\sigma'\:t'\:x\:v)
        \Downarrow
        (C', \sigma'', t'')
      \end{matrix}
    }
    \infer[left label=LetE]1{
    (\mathtt{let}\:x\:e_1\:e_2, C, \sigma, t)
    \Downarrow
    (C', \sigma'', t'')
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (C', \sigma', t') \\
        (e_{2}, C[\mathtt{let}\:M\:C'\:[]], \sigma', t')
        \Downarrow
        (C'', \sigma'', t'')
      \end{matrix}
    }
    \infer[left label=LetM]1{
    (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \sigma, t)
    \Downarrow
    (C'', \sigma'', t'')
    }
  \end{prooftree}
\]

The equivalence of the evaluation relation with a reference interpreter is formalized in Coq.

\section{Collecting Semantics}

To describe what happens when an expression $e$ is excecuted under the context $C$, memory $\sigma$ and initial time $t$, we need to collect all \emph{reachable states} starting from $(e,C,\sigma,t)$ and all values that are returned by the reachable states.
We first define the one-step reachability relation $\rightsquigarrow$.

\[
  \begin{prooftree}
    \infer[left label={AppL}]0{
    (e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e_{1},C, \sigma,t)
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \sigma_{\lambda}, t_{\lambda})
      \end{matrix}
    }
    \infer[left label={AppR}]1{
    (e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e_{2}, C, \sigma_{\lambda}, t_{\lambda})
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \sigma_{\lambda}, t_{\lambda}) \\
        (e_{2}, C, \sigma_{\lambda}, t_{\lambda})
        \Downarrow
        (v, \sigma_{a}, t_{a})
      \end{matrix}
    }
    \infer[left label={AppBody}]1{
    (e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e_{\lambda}, C_{\lambda}[\lambda x^{t_{a}}.[]], \sigma_{a}[t_{a}\mapsto v], \tick\:C\:\sigma_{a}\:t_{a}\:x\:v)
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \infer[left label=LinkL]0{
    (\link{e_{1}}{e_{2}}, C, \sigma, t)
    \rightsquigarrow
    (e_{1}, C, \sigma, t)
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (C', \sigma', t')
      \end{matrix}
    }
    \infer[left label=LinkR]1{
    (\link{e_{1}}{e_{2}}, C, \sigma, t)
    \rightsquigarrow
    (e_{2}, C', \sigma', t')
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \infer[left label=LetEL]0{
    (\mathtt{let}\:x\:e_1\:e_2, C, \sigma, t)
    \rightsquigarrow
    (e_{1}, C, \sigma, t)
    }
  \end{prooftree}\:\:
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (v, \sigma', t')
      \end{matrix}
    }
    \infer[left label=LetER]1{
    (\mathtt{let}\:x\:e_1\:e_2, C, \sigma, t)
    \rightsquigarrow
    (e_{2}, C[\mathtt{let}\:x^{t'}\:[]], \sigma'[t'\mapsto v], \tick\:C\:\sigma'\:t'\:x\:v)
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \infer[left label=LetML]0{
    (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e_{1}, C, \sigma, t)
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (C', \sigma', t')
      \end{matrix}
    }
    \infer[left label=LetMR]1{
    (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e_{2}, C[\mathtt{let}\:M\:C'\:[]], \sigma', t')
    }
  \end{prooftree}
\]
The well-definedness of the reachability relation with respect to a reference interpreter is formalized in Coq.

We want to enable separate analysis without making any assumptions on the free variables.
That is, there may be stuck states because the value of free variables are not known in the given context.
Since we want to collect the most precise information that describes the execution of the program, we have to collect all reachable states.
The relation that collects the reachable states $\rightsquigarrow^{*}$ is defined as the reflexive and transitive closure of $\rightsquigarrow$.

\begin{definition}[Reachable states]
  \[
    \Reach{e}(C,\sigma,t)\triangleq\{(e',C',\sigma,t')| (e,C,\sigma,t)\rightsquigarrow^{*}(e',C',\sigma',t')\}
  \]
\end{definition}

\begin{definition}[Resolved states]
  \[
    \Resolved{e}(C,\sigma,t)\triangleq\{((e',C',\sigma',t'),(V,\sigma'',t''))|(e,C,\sigma,t)\rightsquigarrow^{*}(e',C',\sigma',t')\wedge(e',C'\sigma',t')\Downarrow(V,\sigma'',t'')\}
  \]
\end{definition}

\begin{definition}[Collecting semantics]
  The semantics for an expression $e$ under context $C$, memory $\sigma$ and time $t$ is:
  \[
    \sembracket{e}(C,\sigma,t)\triangleq(\Resolved{e}(C,\sigma,t),\Reach{e}(C,\sigma,t))
  \]
\end{definition}

To justify separate analysis, we first decompose the collecting semantics of the linking expression into a composition of the semantics of the left and right expressions.
\begin{lem}[Separation of linking, resolved part]
  $\:$

  \begin{itemize}
    \item Let $E=\{(C',\sigma',t')|(e_{1},C,\sigma,t)\Downarrow(C',\sigma',t')\}$(exported configurations).
  \end{itemize}
  \[
    \Resolved{\link{e_1}{e_2}}(C,\sigma,t)=
    \Resolved{e_1}(C,\sigma,t)\cup\bigcup_{(C',\sigma',t')\in E}{(\Resolved{e_2}(C',\sigma',t')\cup\underbrace{\{((\link{e_1}{e_2}, C, \sigma, t), (V,\sigma'',t''))|(e_{2},C',\sigma',t')\Downarrow(V,\sigma'',t'')\}}_{\text{The final evaluation}})}
  \]
\end{lem}

\begin{lem}[Separation of linking, reached part]
  $\:$

  \begin{itemize}
    \item Let $E=\{(C',\sigma',t')|(e_{1},C,\sigma,t)\Downarrow(C',\sigma',t')\}$(exported configurations).
  \end{itemize}
  \[
    \Reach{\link{e_1}{e_2}}(C,\sigma,t)= \{(\link{e_1}{e_2},C,\sigma,t)\}\cup\Reach{e_1}(C,\sigma,t)\cup\bigcup_{(C',\sigma',t')\in E}{\Reach{e_2}(C',\sigma',t')}                                                                                                                                         \\
  \]
\end{lem}

Now we only need a way to calculate $\sembracket{e_{2}}(C',\sigma',t')$ by utilizing the separately calculated $\sembracket{e_{2}}([],\varnothing,t_{0})$.
The problem here is that when we calculate the two modules separately, we cannot enforce the order of the time component of each component.
The order is important, because the \emph{equivalence} of the concrete semantics depends on the fact that the $\tick$ function always generates a fresh timestamp larger than the times in the context and in the memory.
The notion of equivalence between concrete configurations and the notion of soundness between the concrete and abstract configurations is essential in developing a formal guarantee that our modular separate analysis does generate some sound abstract state.

\begin{definition}[Domain of a configuration]
  We define the domain of a configuration given by $C, \sigma, t$ to be
  \[
    \mathsf{Dom}(C,\sigma,t)\triangleq\{t'|t'\in C\lor t'\in\mathsf{Dom}(\sigma)\lor t' = t\}
  \]
\end{definition}

\begin{definition}[Equivalence between concrete configurations]
  $\:$

  \begin{itemize}
    \item Let $(\Time,\le,\tick)$ and $(\Time',\le',\tick')$ be two concrete times.
    \item Let $(C,\sigma,t)$ be a configuration in the first time domain and $(C',\sigma',t')$ be a configuration in the second time domain.
  \end{itemize}
  The two configurations are equivalent if there exists a strictly increasing function $f\in\mathsf{Dom}(C,\sigma,t)\rightarrow\mathsf{Dom}(C',\sigma',t')$ that translates $(C,\sigma,t)$ into $(C',\sigma',t')$.
  \[
    (C,\sigma,t)\equiv(C',\sigma',t')\triangleq\exists f\in\mathsf{Dom}(C,\sigma,t)\rightarrow\mathsf{Dom}(C',\sigma',t'): f\text{ strictly increases}\wedge f(C)= C' \wedge f(t) = t' \wedge f\circ\sigma = \sigma'\circ f
  \]

  Furthermore, we extend the definition of $\equiv$ to a relation between $(\Value{\Time}+\Ctx{\Time})\times\Mem{\Time}\times\Time$ and $(\Value{\Time'}+\Ctx{\Time'})\times\Mem{\Time'}\times\Time'$ to mean that
  \[
    (V,\sigma,t)\equiv(V',\sigma',t')\triangleq
    \begin{cases}
      x=x'\wedge e=e'\wedge (C,\sigma,t)\equiv(C',\sigma',t') & (V=\langle\lambda x.e,C\rangle\wedge V'=\langle\lambda x'.e',C'\rangle) \\
      (C,\sigma,t)\equiv(C',\sigma',t')                       & (V=C\wedge V'=C')                                                       \\
      \text{False}                                            & (\text{otherwise})
    \end{cases}
  \]
\end{definition}

We can prove that this relation indeed defines an equivalence relation, since such a function $f$ automatically becomes a bijection between $\mathsf{Dom}(C,\sigma,t)$ and $\mathsf{Dom}(C',\sigma',t')$.

\begin{lem}[Preservation of equivalence]
  $\:$

  \begin{itemize}
    \item Let $(\Time,\le,\tick)$ and $(\Time',\le',\tick')$ be two concrete times.
    \item Let $(C,\sigma,t)$ be a configuration in the first time domain and $(C',\sigma',t')$ be a configuration in the second time domain.
    \item Let all timestamps in $C$ and $\mathsf{Dom}(\sigma)$ be strictly less than $t$.
    \item Let $(C,\sigma,t)\equiv (C',\sigma',t')$.
  \end{itemize}

  Then for all $e$, if $(e,C,\sigma,t)\Downarrow(V,\sigma'',t'')$, there exists $V',\sigma''',t'''$ such that $(e,C',\sigma',t')\Downarrow(V',\sigma''',t''')$ and $(V,\sigma'',t'')\equiv(V',\sigma''',t''')$.
  Likewise, if $(e,C,\sigma,t)\rightsquigarrow(e',C'',\sigma'',t'')$, there exists $C''',\sigma''',t'''$ such that $(e,C',\sigma',t')\rightsquigarrow(e',C''',\sigma''',t''')$ and $(C'',\sigma'',t'')\equiv(C''',\sigma''',t''')$.
\end{lem}

Now we need to define a concrete time on $\Time+\Time'$, when the first time domain exports $C',\sigma'$ to the second time domain.
What we want to prove is: $(C',\sigma',t')\equiv(C',\sigma',t_{0})$, when the first configuration is in $\Time$ and the second configuration is in $\Time+\Time'$, with $t_{0}$ being the initial time in $\Time'$.
Then the reachable states from $(e_{2},C',\sigma',t_{0})$ under the sum domain are equivalent to the reachable states from $(e_{2},C',\sigma',t')$.
Thus, because we can obtain a subset of the reachable states from $(e_{2},C',\sigma',t_{0})$ by simply \emph{injecting} $C'$ and $\sigma'$ into the reachable states obtained from $\sembracket{e_{2}}([],\varnothing,t_{0})$, we can compute a set \textit{equivalent to} $\sembracket{e_{2}}(C',\sigma',t')$ starting from the \emph{separately analyzed} results.

Before elaborating on how to link the time domains, we need to define the injection and deletion operators that inject the exported context into the separately analyzed results.
The notation for injecting $C_{1}$ into $C_{2}$ is $\inject{C_{1}}{C_{2}}$, similar to the plugin operator defined above.

\[
  \mapinject(C_{1},C_{2})\triangleq
  \begin{cases}
    []                                                          & (C_{2}=[])                \\
    \lambda x^{t}. \mapinject(C_{1},C')                         & (C_{2}=\lambda x^{t}. C') \\
    \Let\:x^{t}\:\mapinject(C_{1},C')                           & (C_{2}=\Let\:x^{t}\:C')   \\
    \Let\:M\:C_{1}[\mapinject(C_{1},C')]\:\mapinject(C_{1},C'') & (C_{2}=\Let\:M\:C'\:C'')
  \end{cases}
\]

\[
  \inject{C_{1}}{C_{2}}\triangleq C_{1}[\mapinject(C_{1},C_{2})]
\]
We extend the injection operator to map over all closures in a memory so that $\inject{C}{\sigma}$ can be defined naturally.

\[
  \deletepre(C_{1},C_{2})\triangleq
  \begin{cases}
    \deletepre(C_{1}',C_{2}') & ((C_{1},C_{2})=(\lambda x^{t}.C_{1}',\lambda x^{t}.C_{2}')) \\
    \deletepre(C_{1}',C_{2}') & ((C_{1},C_{2})=(\Let\: x^{t}\:C_{1}',\Let\:x^{t}\:C_{2}'))  \\
    \deletepre(C_{1}',C_{2}') & ((C_{1},C_{2})=(\Let\:M\:C'\:C_{1}',\Let\:M\:C'\:C_{2}'))   \\
    C_{2}                     & (\text{otherwise})
  \end{cases}
\]

\[
  \deletemap(C_{1},C_{2})\triangleq
  \begin{cases}
    []                                                                     & (C_{2}=[])               \\
    \lambda x^{t}.\deletemap(C_{1},C')                                     & (C_{2}=\lambda x^{t}.C') \\
    \Let\:x^{t}\:\deletemap(C_{1},C')                                      & (C_{2}=\Let\:x^{t}\:C')  \\
    \Let\:M\:\deletemap(C_{1},\deletepre(C_{1},C'))\:\deletemap(C_{1},C'') & (C_{2}=\Let\:M\:C'\:C'')
  \end{cases}
\]

\[
  \delete(C_{1},C_{2})\triangleq \deletemap(C_{1},\deletepre(C_{1},C_{2}))
\]
The deletion operation has the expected property that $\delete(C,\inject{C}{C'})=C'$.

Finally, before delving into the definition of the linked time domain, we need to define a filter function that filters the context and memory by membership in each time domain.

\[
  \filter(C,\Time)\triangleq
  \begin{cases}
    []                                             & (C=[])                                   \\
    \lambda x^{t}.\filter(C',\Time)                & (C=\lambda x^{t}.C'\wedge t\in\Time)     \\
    \Let\:x^{t}\:\filter(C',\Time)                 & (C=\Let\:x^{t}\:C'\wedge t\in\Time)      \\
    \Let\:M\:\filter(C',\Time)\:\filter(C'',\Time) & (C=\Let\:M\:C'\:C'')                     \\
    \filter(C',\Time)                              & (C=\lambda x^{t}.C'\wedge t\not\in\Time) \\
    \filter(C',\Time)                              & (C=\Let\:x^{t}\:C'\wedge t\not\in\Time)
  \end{cases}
\]

\[
  \filter(\sigma,\Time)\triangleq
  \lambda t\in\Time.\mathsf{let}\:\langle\lambda x.e,C\rangle\coloneq\sigma(t)\:\mathsf{in}\:\langle\lambda x.e,\filter(C,\Time)\rangle
\]

\begin{lem}[Linking of time domains]
  $\:$

  \begin{itemize}
    \item Let $(\Time,\le,\tick)$ and $(\Time',\le',\tick')$ be two concrete times.
    \item Let $C_{0}\in\Ctx{\Time}$ be the injected context.
    \item Define the $\le_{+}$ order by
          \[
            t \le_{+} t' \triangleq
            \begin{cases}
              t \le t'     & (t,t'\in\Time)          \\
              t \le' t'    & (t,t'\in\Time')         \\
              \text{True}  & (t\in\Time,t'\in\Time') \\
              \text{False} & (t\in\Time',t'\in\Time)
            \end{cases}
          \]
    \item Define the $\tick_{+}$ function so that the timestamps produced from the \emph{injected} context and state are exactly the timestamps produced before injection.
          \[
            \tick_{+}(C,\sigma,t,x,v)\triangleq
            \begin{cases}
              \tick(\filter(C,\Time),\filter(\sigma,\Time),t,x,\filter(v,\Time))                                            & (t\in\Time)  \\
              \tick'(\filter(\delete(C_0,C),\Time'),\filter(\delete(C_0,\sigma),\Time'),t,x,\filter(\delete(C_0,v),\Time')) & (t\in\Time')
            \end{cases}
          \]
  \end{itemize}

  Then $(\Time+\Time',\le_{+},\tick_{+})$ is a concrete time.
\end{lem}

\begin{lem}[Preservation of timestamps under linked time]
  $\:$

  \begin{itemize}
    \item Let $(\Time,\le,\tick)$ and $(\Time',\le',\tick')$ be two concrete times.
    \item Let $C_{0}\in\Ctx{\Time}$ be the injected context.
    \item Let $\sigma_{0}\in\Mem{\Time}$ be the injected memory, and let
          \[
            \sigma;\sigma_{0}\triangleq\lambda t.
            \begin{cases}
              \sigma(t)     & (t\in\Time') \\
              \sigma_{0}(t) & (t\in\Time)
            \end{cases}
          \]
          for $\sigma\in\Mem{\Time'}$.
  \end{itemize}

  Now, if $(e,C,\sigma,t)\Downarrow(V,\sigma',t')$ under $\Time'$, then
  $(e,\inject{C_0}{C},\inject{C_0}{\sigma};\sigma_{0},t)\Downarrow(\inject{C_0}{V},\inject{C_0}{\sigma};\sigma_0,t')$ under $\Time+\Time'$.

  Likewise, if $(e,C,\sigma,t)\rightsquigarrow^{*}(e',C',\sigma',t')$ under $\Time'$, then
  $(e,\inject{C_0}{C},\inject{C_0}{\sigma};\sigma_{0},t)\rightsquigarrow^{*}(e',\inject{C_0}{C'},\inject{C_0}{\sigma};\sigma_0,t')$ under $\Time+\Time'$.
\end{lem}

\begin{definition}[Subset to an equivalent set]
  $\:$

  \begin{itemize}
    \item $A\ovbar{\subseteq}B$ in the context when $A,B\in(\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time)$ is defined as
          \[
            (e,C,\sigma,t)\in A\Rightarrow \exists C',\sigma',t' : (C,\sigma,t)\equiv(C',\sigma',t')\wedge(e,C',\sigma',t')\in B
          \]
    \item $A\ovbar{\subseteq}B$ in the context when $A,B\in(\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time)\times(\Value{\Time}\times\Mem{\Time}\times\Time)$ is defined as
          \begin{align*}
            ((e,C,\sigma,t),(V,\sigma',t'))\in A\Rightarrow \exists C',\sigma'',t'',V',\sigma''',t''' : & (C,\sigma,t)\equiv(C',\sigma'',t'')\wedge(V,\sigma',t')\equiv(V',\sigma''',t''')\wedge \\
                                                                                                        & ((e,C',\sigma'',t''),(V',\sigma''',t'''))\in B
          \end{align*}
  \end{itemize}
\end{definition}

Before going into the formulation of linking in the concrete semantics, we need to cast $\sembracket{e}$ into a fixpoint computation form.
We define a transfer function $\mathcal{F}$ that takes $(R^{\circ},R^{*})\in\wp((\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time)\times(\Value{\Time}\times\Mem{\Time}\times\Time))\times\wp(\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time)$ and outputs $({R'}^{\circ},{R'}^{*})$ that are one step away from the original sets.
\begin{definition}[Transfer function]
  $\:$

  \begin{itemize}
    \item Given $(R^{\circ},R^{*})\in\wp((\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time)\times(\Value{\Time}\times\Mem{\Time}\times\Time))\times\wp(\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time)$,
    \item Let the relations $\Downarrow_{R^{\circ}}$ and $\rightsquigarrow_{R^{\circ}}$ be defined as exactly the relations $\Downarrow$ and $\rightsquigarrow$ with all assumptions of the form $a\Downarrow b$ replaced with the assumptions $(a,b)\in R^{\circ}$.
    \item Let $\Delta R^{\circ}=\{(a,b)|a\in R^{*}\wedge a\Downarrow_{R^{\circ}}b\}$ and $\Delta R^{*}=\{b|\exists a\in R^{*}:a\rightsquigarrow_{R^{\circ}}b\}$
    \item The definition of the transfer function is $\mathcal{F}(R^{\circ},R^{*})\triangleq(R^{\circ}\cup\Delta R^{\circ}, R^{*}\cup\Delta R^{*})$.
  \end{itemize}
\end{definition}

\begin{lem}[Collecting semantics as a least fixpoint]
  \[
    \sembracket{e}(C,\sigma,t)=\mathsf{lfp}(\lambda (R^{\circ}, R^{*}).\mathcal{F}(R^{\circ}, R^{*}\cup\{(e,C,\sigma,t)\}))
  \]
\end{lem}

\begin{thm}[Linking of collected states] We want to compute $\sembracket{\link{e_{1}}{e_{2}}}(C,\sigma,t)$.
  $\:$

  \begin{itemize}
    \item Given $R^{\circ}$ and $R^{*}$ that satisfies $\Resolved{e_{1}}(C,\sigma,t)\ovbar{\subseteq} R^{\circ}$ and $\Reach{e_{1}}(C,\sigma,t)\ovbar{\subseteq} R^{*}$,
    \item Let $E=\{(C_{0},\sigma_{0},t'')|\exists C',\sigma',t':(C,\sigma,t)\equiv(C',\sigma',t')\wedge((e_{1},C',\sigma',t'),(C_{0},\sigma_{0},t''))\in R^{\circ}\}$(exported configurations).
    \item Let $R^{\circ}(C_{0},\sigma_{0})=\{((e_{2},C_{0},\sigma_{0},t_{0}), (\inject{C_{0}}{V},\inject{C_{0}}{\sigma'};\sigma_{0},t'))|((e_{2},[],\varnothing,t_{0}),(V,\sigma',t'))\in\Resolved{e_{2}}([],\varnothing,t_{0})\}$(separate resolved).
    \item Let $R^{*}(C_{0},\sigma_{0})=\{(e',\inject{C_{0}}{C'},\inject{C_{0}}{\sigma'};\sigma_{0},t')|(e',C',\sigma',t')\in\Reach{e_{2}}([],\varnothing,t_{0})\}$(separate reached).
  \end{itemize}

  We have:
  \[
    \sembracket{e_{2}}(C_{0},\sigma_{0},t_{0})=\mathsf{lfp}(\lambda (R^{\circ}, R^{*}).\mathcal{F}(R^{\circ}\cup R^{\circ}(C_{0},\sigma_{0}), R^{*}\cup R^{*}(C_{0},\sigma_{0})))
  \]

  Thus:
  \[
    \Resolved{\link{e_1}{e_2}}(C,\sigma,t)\ovbar{\subseteq}
    R^{\circ}\cup\bigcup_{(C_{0},\sigma_{0},t')\in E}{(\Resolved{e_2}(C_{0},\sigma_{0},t_{0})\cup\underbrace{\{((\link{e_1}{e_2}, C, \sigma, t), (V,\sigma'',t''))|((e_{2},C_{0},\sigma_{0},t_{0}),(V,\sigma'',t''))\in\Resolved{e_{2}}(C_{0},\sigma_{0},t_{0})\}}_{\text{The final evaluation}})}
  \]
  \begin{align*}
    \Reach{\link{e_1}{e_2}}(C,\sigma,t)\ovbar{\subseteq}\{(\link{e_1}{e_2},C,\sigma,t)\}\cup R^{*}\cup\bigcup_{(C_{0},\sigma_{0},t')\in E}{\Reach{e_2}(C_{0},\sigma_{0},t_{0})}
  \end{align*}
\end{thm}

\section{Abstract Semantics}

The abstract semantics is almost exactly the same as the concrete semantics, except for the fact that the memory domain is now a finite map from the abstract time domain to a \emph{set} of abstract values.

\begin{bnfgrammar}
  $t^{\#}$ : \in \ATime
  ;;
  $v^{\#}$ : \in \AValue{\ATime}
  ;;
  $C^{\#}$ : \in \Ctx{\ATime}
  ;;
  $V^{\#}$ : \in \AValue{\ATime}+\Ctx{\ATime}
  ;;
  $\sigma^{\#}$ : \in \AMem{\Time} \triangleq \fin{\ATime}{\wp(\AValue{\ATime})}
  ;;
  $v^{\#}$ ::= $\langle \lambda x.e, C^{\#} \rangle$ : closure
\end{bnfgrammar}

\begin{definition}[Soundness]
  $\:$

  \begin{itemize}
    \item Given two configurations $(C,\sigma,t)$ in $\Time$ and $(C^{\#},\sigma^{\#},t^{\#})$ in $\ATime$, we say that the latter is a sound approximation of the former when
          there exists an $\alpha:\Time\rightarrow\ATime$ such that $\alpha(t)=t^{\#}\wedge\alpha(C)=C^{\#}\wedge\forall t:\alpha(\sigma(t))\in\sigma^{\#}(\alpha(t))$.
          We write this as $(C,\sigma,t)\lhd(C^{\#},\sigma^{\#},t^{\#})$.
    \item Given two states $(e,C,\sigma,t)$ and $(e',C^{\#},\sigma^{\#},t^{\#})$, the latter is said to be a sound approximation of the former when $e=e'$ and $(C,\sigma,t)\lhd(C^{\#},\sigma^{\#},t^{\#})$.
    \item Given two results $(V,\sigma,t)$ and $(V^{\#}, \sigma^{\#},t^{\#})$, the latter is said to be a sound approximation of the former either if
          they are both of the form $(C,\sigma,t)$ and $(C^{\#},\sigma^{\#},t^{\#})$ and the latter is a sound approximation of the former,
          or if they are of the form $(\langle\lambda x.e,C\rangle,\sigma,t)$ and $(\langle\lambda x'.e',C^{\#}\rangle,\sigma^{\#},t^{\#})$ satisfying $x=x'\wedge(C,\sigma,t)\lhd(C^{\#},\sigma^{\#},t^{\#})$.
    \item Given two sets $S$ and $S^{\#}$,
          we write $S\ovbar{\subseteq}^{\#} S^{\#}$ when for every element of $S$, there exists a sound approximation in $S^{\#}$.
  \end{itemize}
\end{definition}

We define the abstract evaluation relation $\Downarrow^{\#}$ and abstract reachability relation $\rightsquigarrow^{\#}$ exactly as their concrete counterparts, except that the update for the memory is now a weak update and
variables can evaluate to any value in $\sigma^{\#}(\addr)$.

\begin{lem}[Preservation of soundness]
  $\:$

  \begin{itemize}
    \item Let $(C,\sigma,t)$ be a concrete configuration and $(C^{\#},\sigma^{\#},t^{\#})$ be an abstract configuration.
    \item Let all timestamps in $C$ and $\mathsf{Dom}(\sigma)$ be strictly less than $t$.
    \item Let $(C,\sigma,t)\lhd(\A{C},\A{\sigma},\A{t})$.
  \end{itemize}

  Then for all $e$, if $(e,C,\sigma,t)\Downarrow(V,\sigma',t')$, there exists $\A{V},\A{\sigma'},\A{t'}$ such that $(e,\A{C},\A{\sigma},\A{t})\A{\Downarrow}(\A{V},\A{\sigma'},\A{t'})$ and $(V,\sigma',t')\lhd(\A{V},\A{\sigma'},\A{t'})$.
  Likewise, if $(e,C,\sigma,t)\rightsquigarrow(e',C',\sigma',t')$, there exists $\A{C'},\A{\sigma'},\A{t'}$ such that $(e,\A{C},\A{\sigma},\A{t})\rightsquigarrow(e',\A{C'},\A{\sigma'},\A{t'})$ and $(C',\sigma',t')\lhd(\A{C'},\A{\sigma'},\A{t'})$.
\end{lem}

\begin{lem}[Equivalence preserves soundness]
  $\:$

  \begin{itemize}
    \item Let $(C,\sigma,t)$ and $(C',\sigma',t')$ be concrete configurations and $(C^{\#},\sigma^{\#},t^{\#})$ be an abstract configuration.
    \item Let $(C,\sigma,t)\equiv(C',\sigma',t')$ and $(C,\sigma,t)\lhd(\A{C},\A{\sigma},\A{t})$.
  \end{itemize}

  Then $(C',\sigma',t')\lhd(\A{C},\A{\sigma},\A{t})$.
\end{lem}

\begin{thm}[Abstract linking]
  We want to compute sets $\tilde{R^{\circ}}^{\#}$ and $\tilde{R^{*}}^{\#}$ satisfying
  \[
    \Resolved{\link{e_1}{e_2}}(C,\sigma,t)\ovbar{\subseteq}^{\#} \tilde{R^{\circ}}^{\#}
    \quad\wedge\quad
    \Reach{\link{e_1}{e_2}}(C,\sigma,t)\ovbar{\subseteq}^{\#} \tilde{R^{*}}^{\#}
  \]

  \begin{itemize}
    \item Given ${R^{\circ}}^{\#}$ and ${R^{*}}^{\#}$ that satisfies $\Resolved{e_1}(C,\sigma,t)\ovbar{\subseteq}^{\#} {R^{\circ}}^{\#}$ and $\Reach{e_1}(C,\sigma,t)\ovbar{\subseteq}^{\#} {R^{*}}^{\#}$,
    \item Let $\A{E}=\{(\A{C_{0}},\A{\sigma_{0}},\A{t'})|\exists \A{C},\A{\sigma},\A{t}:(C,\sigma,t)\lhd(\A{C},\A{\sigma},\A{t})\wedge((e_{1},\A{C},\A{\sigma},\A{t}),(\A{C_{0}},\A{\sigma_{0}},\A{t'}))\in \A{R^{\circ}}\}$.
    \item Let $\A{R^{\circ}}(\A{C_{0}},\A{\sigma_{0}})=\{((e_{2},\A{C_{0}},\A{\sigma_{0}},\A{t_{0}}), (\inject{\A{C_{0}}}{\A{V}},\inject{\A{C_{0}}}{\A{\sigma}};\A{\sigma_{0}},\A{t}))|((e_{2},[],\varnothing,\A{t_{0}}),(\A{V},\A{\sigma},\A{t}))\in\A{\Resolved{e_{2}}}([],\varnothing,\A{t_{0}})\}$.
    \item Let $\A{R^{*}}(\A{C_{0}},\A{\sigma_{0}})=\{(e',\inject{\A{C_{0}}}{\A{C}},\inject{\A{C_{0}}}{\A{\sigma}};\A{\sigma_{0}},\A{t})|(e',\A{C},\A{\sigma},\A{t})\in\Reach{e_{2}}([],\varnothing,\A{t_{0}})\}$.
  \end{itemize}

  We have:
  \[
    \A{\sembracket{e_{2}}}(\A{C_{0}},\A{\sigma_{0}},\A{t_{0}})=\mathsf{lfp}(\lambda (\A{R^{\circ}}, \A{R^{*}}).\A{\mathcal{F}}(\A{R^{\circ}}\cup \A{R^{\circ}}(\A{C_{0}},\A{\sigma_{0}}), \A{R^{*}}\cup \A{R^{*}}(\A{C_{0}},\A{\sigma_{0}})))
  \]

  Thus, if we pick some $(\A{C},\A{\sigma},\A{t})$ satisfying $(C,\sigma,t)\lhd(\A{C},\A{\sigma},\A{t})$:
  \[
    \Resolved{\link{e_1}{e_2}}(C,\sigma,t)\A{\ovbar{\subseteq}}
    \A{R^{\circ}}\cup\bigcup_{(\A{C_{0}},\A{\sigma_{0}},\A{t'})\in \A{E}}{(\A{\Resolved{e_2}}(\A{C_{0}},\A{\sigma_{0}},\A{t_{0}})\cup\underbrace{\{((\link{e_1}{e_2}, \A{C}, \A{\sigma}, \A{t}), (\A{V},\A{\sigma'},\A{t'}))|(e_{2},\A{C_{0}},\A{\sigma_{0}},\A{t_{0}})\A{\Downarrow}(\A{V},\A{\sigma'},\A{t'})\}}_{\text{The final evaluation}})}
  \]
  \begin{align*}
    \Reach{\link{e_1}{e_2}}(C,\sigma,t)\A{\ovbar{\subseteq}}\{(\link{e_1}{e_2},\A{C},\A{\sigma},\A{t})\}\cup \A{R^{*}}\cup\bigcup_{(\A{C_{0}},\A{\sigma_{0}},\A{t'})\in \A{E}}{\A{\Reach{e_2}}(\A{C_{0}},\A{\sigma_{0}},\A{t_{0}})}
  \end{align*}
\end{thm}

\begin{thm}[Finiteness of time implies finiteness of abstraction]
  If $\ATime$ is finite,
  \[
    \forall e,\A{C},\A{\sigma},\A{t}: |\A{\Resolved{e}}(\A{C},\A{\sigma},\A{t})|<\infty\wedge|\A{\Reach{e}}(\A{C},\A{\sigma},\A{t})|<\infty
  \]
\end{thm}

\printbibliography
\end{document}
%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:
