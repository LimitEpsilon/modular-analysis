%! TEX program = xelatex
\documentclass{article}
\usepackage{geometry}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
}
\usepackage{setspace} % setstretch

\usepackage{graphicx}
\usepackage{kotex}
\usepackage{csquotes}
\usepackage{tabularray}
\UseTblrLibrary{booktabs}
\UseTblrLibrary{counter}

\usepackage{biblatex}
\addbibresource{citations.bib}

%%% Math settings
\usepackage{amssymb,amsmath,amsthm,mathtools} % Before unicode-math
\usepackage[math-style=TeX,bold-style=TeX]{unicode-math}
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{lem}{Lemma}[section]
\newtheorem{thm}{Theorem}[section]

%%% Font settings
\setmainfont{Libertinus Serif}
\setsansfont{Libertinus Sans}[Scale=MatchUppercase]
\setmonofont{JuliaMono}[Scale=MatchLowercase]
\setmathfont{Libertinus Math} % Before set*hangulfont
\setmathfont{TeX Gyre Pagella Math}[range={\lbrace,\rbrace},Scale=1.1]
\setmainhangulfont{Noto Serif CJK KR}
\setsanshangulfont[BoldFont={* Bold}]{KoPubWorld Dotum.ttf}
\setmonohangulfont{D2Coding}

%%% PL constructs
\usepackage{ebproof}
\ebproofset{left label template=\textsc{[\inserttext]}}

% For simplebnf
\newfontfamily{\fallbackfont}{EB Garamond}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\usepackage{newunicodechar}
\newunicodechar{⩴}{\textfallback{⩴}}

\usepackage{simplebnf}
\RenewDocumentCommand\SimpleBNFDefEq{}{\ensuremath{⩴}}

% because of simplebnf
\newcommand*{\vbar}{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{⩴}}
\newcommand*{\ortype}{\mathrel{|}}
\newcommand*{\cons}{::}

% for complement
\newcommand{\loverbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
\newcommand*{\Expr}{\text{Expr}}
\newcommand*{\ExprVar}{\text{ExprVar}}
\newcommand*{\Module}{\text{Module}}
\newcommand*{\ModVar}{\text{ModVar}}
\newcommand*{\Time}{\mathbb{T}}
\newcommand*{\ATime}{\mathbb{T}^{\#}}
\newcommand*{\Ctx}[1]{\text{Ctx}\:{#1}}
\newcommand*{\Value}[1]{\text{Val}\:{#1}}
\newcommand*{\Mem}[1]{\text{Mem}\:{#1}}
\newcommand*{\AMem}[1]{\text{Mem}^{\#}\:{#1}}
\newcommand*{\link}[2]{{#1}\mathtt{!}{#2}}
\newcommand*{\Stuck}[1]{\underline{#1}^{\times}}
\newcommand*{\Resolved}[1]{\underline{#1}^{\circ}}
\newcommand*{\sembracket}[1]{\lBrack{#1}\rBrack}
\newcommand*{\fin}[2]{{#1}\xrightarrow{\text{fin}}{#2}}
\newcommand*{\addr}{\mathsf{addr}}
\newcommand*{\tick}{\mathsf{tick}}
\newcommand*{\modctx}{\mathsf{ctx}}
\newcommand*{\mapinject}{\mathsf{map\_inject}}
\newcommand*{\inject}[2]{{#1}\langle{#2}\rangle}
\newcommand*{\deletepre}{\mathsf{delete\_prefix}}
\newcommand*{\deletemap}{\mathsf{delete\_map}}
\newcommand*{\delete}{\mathsf{delete}}
\newcommand*{\filter}{\mathsf{filter}}
\newcommand*{\Let}{\mathtt{let}}
\newcommand*{\doubleplus}{+\kern-1.3ex+\kern0.8ex}
\newcommand*{\mdoubleplus}{\ensuremath{\mathbin{+\mkern-10mu+}}}

\title{Semantics for Modular Analysis}
\author{Joonhyup Lee}
\date{}
\begin{document}
\maketitle

\section{Abstract Syntax}

In this section we define the abstract syntax for a simple language that captures the essence of modules and linking.
The language is basically an extension of untyped lambda calculus with modules and the linking operator.

\begin{bnfgrammar}
  $x$ : \in \ExprVar
  ;;
  $M$ : \in \ModVar
  ;;
  $e$ : \in \Expr
  ;;
  $e$ ::= $x$ : identifier, expression
  | $\lambda x.e$ : function
  | $e$ $e$ : application
  | $\link{e}{e}$ : linked expression
  | $\varepsilon$ : empty module
  | $M$ : identifier, module
  | \texttt{let} $x$ $e$ $e$ : let-binding, expression
  | \texttt{let} $M$ $e$ $e$ : let-binding, module
\end{bnfgrammar}

\subsection{Rationale for the design of the simple language}

There are no recursive modules, first-class modules, or functors in the simple language that is defined.
Also, note that the nonterminals for the modules and expressions are not separated. Why is this so?

The rationale for the exclusion of recursive modules/first-class modules/functors is because we want to enforce static scoping.
That is, we need to be able to statically determine where variables were bound when using them.
To enforce static scoping when function applications might return modules, we need to employ signatures to project the dynamically computed modules onto a statically known context.
Concretely, we need to define signatures $S$ where $\lambda M:>S.e$ statically resolves the context when $M$ is used in the body $e$, and $e:>S$ enforces that a dynamic computation is resolved into one static form.

The rationale for not separating modules and expressions in the syntax is because we want to utilize the linking operator to link both modules to expressions and modules to modules.
That is, we want expressions to be parsed as $(m_1!m_2)!e$.
$\link{m_1}{m_2}$ links a module with a module, and $(m_1!m_2)!e$ links a module with an expression.
Why this is convenient will be clear when we explain separate analysis; we want to link modules with modules as well as expressions.

\section{Big-Step Operational Semantics}

In this section we give the big-step operational semantics for the dynamic execution of the module language.
The big-step evaluation relation relates the initial state(memory and time) and configuration(the subexpression being evaluated, and the surrounding dynamic context) with the resulting state and value.

This relation is nonstandard in that the \emph{environment} that is often used to define closures in the call-by-value dynamics is not a finite map from variables to values.
Rather, the surrounding \emph{syntactic} context annotated with the \emph{binding times} for the variables serve as the environment.
To access the value of the variable $x$ from the context $C$, one has to read off the closest binding time from the context and look up the value bound at that time from the memory.
To access the exported context from the variable $M$, one has to look up the exported context from $C$, not from the memory.

This separation between where we store modules and where we store the evaluated values from expressions emphasizes the fact that \emph{where} the variables are bound is guided by syntax.
The only thing that is dynamic is \emph{when} the variables are bound, which is represented by the time component.

Now, we start by defining what we mean by \emph{time} and \emph{context}, which is the essence of our model.

\subsection{Time and Context}

We first define sets that are parametrized by our choice of the time domain, mainly the \emph{value}, \emph{memory}, and \emph{context} domains.
Also, we present the notational conventions used in this paper to represent members of each domain.

\begin{bnfgrammar}
  $t$ : \in \Time
  ;;
  $v$ : \in \Value{\Time}
  ;;
  $C$ : \in \Ctx{\Time}
  ;;
  $V$ : \in \Value{\Time}+\Ctx{\Time}
  ;;
  $\sigma$ : \in \Mem{\Time} \triangleq \fin{\Time}{\Value{\Time}}
  ;;
  $C$ ::= [] : hole
  | $\lambda x^{t}.C$ : function parameter binding
  | \texttt{let} $x^{t}$ $C$ : let expression binding
  | \texttt{let} $M$ $C$ $C$ : let module context binding
  ;;
  $v$ ::= $\langle \lambda x.e, C \rangle$ : closure
\end{bnfgrammar}

Above, there are no constraints placed upon the set $\Time$.
Now we give the conditions that the concrete time domain must satisfy.

\begin{definition}[Concrete time]
  $(\Time, \le, \tick)$ is a \emph{concrete time} when
  \begin{enumerate}
    \item $(\Time, \le)$ is a total order.
    \item $\tick\in\Ctx{\Time}\rightarrow\Mem{\Time}\rightarrow\Time\rightarrow\ExprVar\rightarrow\Value{\Time}\rightarrow\Time$ gives a strictly larger timestamp. That is,
          \[\forall C\in\Ctx{\Time}, \sigma\in\Mem{\Time},t\in\Time,x\in\ExprVar,v\in\Value{\Time}: t < \tick\:C\:\sigma\:t\:x\:v.\]
          $\tick$ updates the timestamp when $v$ is bound to $x$ under the context $C$ and state $(\sigma, t)$.
  \end{enumerate}
\end{definition}

Now for the auxiliary operators that is used when defining the evaluation relation.
We first define the plugin operator for the dynamic context.
\[
  C_{1}[C_{2}]\triangleq
  \begin{cases}
    C_{2}                           & (C_{1}=[])                       \\
    \lambda x^{t}.C'[C_{2}]         & (C_{1}=\lambda x^{t}.C')         \\
    \mathtt{let}\:x^{t}\:C'[C_{2}]  & (C_{1}=\mathtt{let}\:x^{t}\:C')  \\
    \mathtt{let}\:M\:C'\:C''[C_{2}] & (C_{1}=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]

Next, the function that extracts the address for an $\ExprVar$ must be defined.
\[
  \addr(C,x)\triangleq
  \begin{cases}
    \bot         & (C=[])                                                           \\
    \bot         & (C=\lambda x'^{t}.C'\wedge x'\neq x\wedge \addr(C',x)=\bot)      \\
    \bot         & (C=\mathtt{let}\:x'^{t}C'\wedge x'\neq x\wedge \addr(C',x)=\bot) \\
    t            & (C=\lambda x'^{t}.C'\wedge x'= x\wedge \addr(C',x)=\bot)         \\
    t            & (C=\mathtt{let}\:x'^{t}C'\wedge x'= x\wedge \addr(C',x)=\bot)    \\
    t'           & (C=\lambda x'^{t}.C'\wedge \addr(C',x)=t')                       \\
    t'           & (C=\mathtt{let}\:x'^{t}\:C'\wedge \addr(C',x)=t')                \\
    \addr(C'',x) & (C=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]
Finally, the function that looks up the dynamic context bound to a module variable $M$ must be defined.
\[
  \modctx(C,M)\triangleq
  \begin{cases}
    \bot           & (C=[])                                                             \\
    C'             & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'= M\wedge\modctx(C'',M)=\bot) \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge\modctx(C'',M)\neq\bot)          \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'\neq M)                       \\
    \modctx(C',M)  & (C=\lambda x^{t}.C')                                               \\
    \modctx(C',M)  & (C=\mathtt{let}\:x^{t}\:C')
  \end{cases}
\]

\subsection{The Evaluation Relation}

Now we are in a position to define the big-step evaluation relation.
The relation $\Downarrow$ relates $(e,C,\sigma,t)\in\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time$ with
$(V,\sigma,t)\in(\Value{\Time}+\Ctx{\Time})\times\Mem{\Time}\times\Time$.
Note that we constrain whether the evaluation relation returns $v\in\Value{\Time}$(when the expression being evaluated is not a module) or $C\in\Ctx{\Time}$ by the definition of the relation.

\[
  \begin{prooftree}
    \hypo{t_{x}=\addr(C,x)}
    \hypo{\sigma(t_{x}) = v}
    \infer[left label=ExprVar]2{
    (x, C, \sigma, t)
    \Downarrow
    (v, \sigma, t)
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \infer[left label=Fn]0{
    (\lambda x.e, C, \sigma, t)
    \Downarrow
    (\langle\lambda x.e, C\rangle, \sigma, t)
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \sigma_{\lambda}, t_{\lambda}) \\
        (e_{2}, C, \sigma_{\lambda}, t_{\lambda})
        \Downarrow
        (v, \sigma_{a}, t_{a})                                                            \\
        (e_{\lambda}, C_{\lambda}[\lambda x^{t_{a}}.[]], \sigma_{a}[t_{a}\mapsto v], \tick\:C\:\sigma_{a}\:t_{a}\:x\:v)
        \Downarrow
        (v', \sigma',t')
      \end{matrix}
    }
    \infer[left label={App}]1{
    (e_{1}\:e_{2}, C, \sigma, t)
    \Downarrow
    (v', \sigma',t')
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (C', \sigma', t') \\
        (e_{2}, C', \sigma', t')
        \Downarrow
        (V, \sigma'', t'')
      \end{matrix}
    }
    \infer[left label=Linking]1{
    (\link{e_{1}}{e_{2}}, C, \sigma, t)
    \Downarrow
    (V, \sigma'', t'')
    }
  \end{prooftree}
\]
Note that we do not constrain whether $v$ or $C$ is returned by $e_{2}$ in the linking case.
That is, linking may return either values or modules.

\[
  \begin{prooftree}
    \infer[left label=Empty]0{
    (\varepsilon, C, \sigma, t)
    \Downarrow
    (C, \sigma, t)
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{C'=\modctx(C,M)}
    \infer[left label=ModVar]1{
    (M, C, \sigma, t)
    \Downarrow
    (C', \sigma, t)
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (v, \sigma', t') \\
        (e_{2}, C[\mathtt{let}\:x^{t'}\:[]], \sigma'[t'\mapsto v], \tick\:C\:\sigma'\:t'\:x\:v)
        \Downarrow
        (C', \sigma'', t'')
      \end{matrix}
    }
    \infer[left label=LetE]1{
    (\mathtt{let}\:x\:e_1\:e_2, C, \sigma, t)
    \Downarrow
    (C', \sigma'', t'')
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (C', \sigma', t') \\
        (e_{2}, C[\mathtt{let}\:M\:C'\:[]], \sigma', t')
        \Downarrow
        (C'', \sigma'', t'')
      \end{matrix}
    }
    \infer[left label=LetM]1{
    (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \sigma, t)
    \Downarrow
    (C'', \sigma'', t'')
    }
  \end{prooftree}
\]

The equivalence of the evaluation relation with a reference interpreter is formalized in Coq.

\section{Collecting Semantics}

To describe what happens when an expression $e$ is excecuted under the context $C$, memory $\sigma$ and initial time $t$, we need to collect all \emph{reachable states} starting from $(e,C,\sigma,t)$ and all values that are returned by the reachable states.
We first define the reachability relation $\rightsquigarrow$.

\[
  \begin{prooftree}
    \infer[left label={Refl}]0{
    (e, C, \sigma, t)
    \rightsquigarrow
    (e, C, \sigma, t)
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \rightsquigarrow
        (e',C',\sigma',t')
      \end{matrix}
    }
    \infer[left label={AppL}]1{
    (e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e',C', \sigma',t')
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \sigma_{\lambda}, t_{\lambda}) \\
        (e_{2}, C, \sigma_{\lambda}, t_{\lambda})
        \rightsquigarrow
        (e', C', \sigma', t')
      \end{matrix}
    }
    \infer[left label={AppR}]1{
    (e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e', C', \sigma',t')
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (\langle\lambda x.e_{\lambda}, C_{\lambda}\rangle, \sigma_{\lambda}, t_{\lambda}) \\
        (e_{2}, C, \sigma_{\lambda}, t_{\lambda})
        \Downarrow
        (v, \sigma_{a}, t_{a})                                                            \\
        (e_{\lambda}, C_{\lambda}[\lambda x^{t_{a}}.[]], \sigma_{a}[t_{a}\mapsto v], \tick\:C\:\sigma_{a}\:t_{a}\:x\:v)
        \rightsquigarrow
        (e', C', \sigma',t')
      \end{matrix}
    }
    \infer[left label={AppBody}]1{
    (e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e', C', \sigma',t')
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \rightsquigarrow
        (e', C', \sigma', t')
      \end{matrix}
    }
    \infer[left label=LinkL]1{
    (\link{e_{1}}{e_{2}}, C, \sigma, t)
    \rightsquigarrow
    (e', C', \sigma', t')
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (C', \sigma', t') \\
        (e_{2}, C', \sigma', t')
        \rightsquigarrow
        (e'', C'', \sigma'', t'')
      \end{matrix}
    }
    \infer[left label=LinkR]1{
    (\link{e_{1}}{e_{2}}, C, \sigma, t)
    \rightsquigarrow
    (e'', C'', \sigma'', t'')
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \rightsquigarrow
        (e', C', \sigma', t')
      \end{matrix}
    }
    \infer[left label=LetEL]1{
    (\mathtt{let}\:x\:e_1\:e_2, C, \sigma, t)
    \rightsquigarrow
    (e', C', \sigma', t')
    }
  \end{prooftree}\quad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (v, \sigma', t') \\
        (e_{2}, C[\mathtt{let}\:x^{t'}\:[]], \sigma'[t'\mapsto v], \tick\:C\:\sigma'\:t'\:x\:v)
        \rightsquigarrow
        (e'', C'', \sigma'', t'')
      \end{matrix}
    }
    \infer[left label=LetER]1{
    (\mathtt{let}\:x\:e_1\:e_2, C, \sigma, t)
    \rightsquigarrow
    (e'', C'', \sigma'', t'')
    }
  \end{prooftree}
\]

\[
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \rightsquigarrow
        (e', C', \sigma', t')
      \end{matrix}
    }
    \infer[left label=LetML]1{
    (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e', C', \sigma', t')
    }
  \end{prooftree}\qquad
  \begin{prooftree}
    \hypo{
      \begin{matrix}
        (e_{1}, C, \sigma, t)
        \Downarrow
        (C', \sigma', t') \\
        (e_{2}, C[\mathtt{let}\:M\:C'\:[]], \sigma', t')
        \rightsquigarrow
        (e'', C'', \sigma'', t'')
      \end{matrix}
    }
    \infer[left label=LetMR]1{
    (\mathtt{let}\:M\:e_{1}\:e_{2}, C, \sigma, t)
    \rightsquigarrow
    (e'', C'', \sigma'', t'')
    }
  \end{prooftree}
\]

We want to enable separate analysis without making any assumptions on the free variables.
That is, there may be stuck states because the value of free variables are not known in the given context.
Since we want to collect the most precise information that describes the execution of the program, we have to collect both the stuck and resolved states.

\begin{definition}[Reachable stuck states]
  \[
    \Stuck{e}(C,\sigma,t)\triangleq\{(e',C',\sigma,t')|(e,C,\sigma,t)\rightsquigarrow(e',C',\sigma',t')\wedge\forall V,\sigma'',t'':\lnot((e',C'\sigma',t')\Downarrow(V,\sigma'',t''))\}
  \]
\end{definition}

\begin{definition}[Reachable resolved states]
  \[
    \Resolved{e}(C,\sigma,t)\triangleq\{((e',C',\sigma',t'),(V,\sigma'',t''))|(e,C,\sigma,t)\rightsquigarrow(e',C',\sigma',t')\wedge(e',C'\sigma',t')\Downarrow(V,\sigma'',t'')\}
  \]
\end{definition}

\begin{definition}[Collecting semantics]
  The semantics for an expression $e$ under context $C$, memory $\sigma$ and time $t$ is:
  \[
    \sembracket{e}(C,\sigma,t)\triangleq(\Resolved{e}(C,\sigma,t),\Stuck{e}(C,\sigma,t))
  \]
\end{definition}

To justify separate analysis, we first decompose the collecting semantics of the linking expression into a composition of the semantics of the left and right expressions.
\begin{lem}[Separation of linking, resolved part]
  \[
    \Resolved{\link{e_1}{e_2}}(C,\sigma,t)=
    \Resolved{e_1}(C,\sigma,t)\cup\bigcup_{(e_1,C,\sigma,t)\Downarrow(C',\sigma',t')}{(\Resolved{e_2}(C',\sigma',t')\cup\underbrace{\{((\link{e_1}{e_2}, C, \sigma, t), (V,\sigma'',t''))|(e_{2},C',\sigma',t')\Downarrow(V,\sigma'',t'')\}}_{\text{The final evaluation}})}
  \]
\end{lem}

\begin{lem}[Separation of linking, stuck part]
  $\:$

  \begin{itemize}
    \item Let $E\triangleq\{(C',\sigma',t')|(e_{1},C,\sigma,t)\Downarrow(C',\sigma',t')\}$(exported configurations).
  \end{itemize}
  \[
    \Stuck{\link{e_1}{e_2}}(C,\sigma,t)= \Stuck{e_1}(C,\sigma,t)\cup\bigcup_{(C',\sigma',t')\in E}{\Stuck{e_2}(C',\sigma',t')}\cup \underbrace{\{(\link{e_1}{e_2}, C, \sigma, t)|\forall (C',\sigma',t')\in E:(e_{2},C',\sigma',t')\in\Stuck{e_{2}}(C',\sigma',t')\}}_{\text{When there is no context that resolves }e_{2}}
  \]
\end{lem}

Now we only need a way to calculate $\sembracket{e_{2}}(C',\sigma',t')$ by utilizing the separately calculated $\sembracket{e_{2}}([],\varnothing,t_{0})$.
The problem here is that when we calculate the two modules separately, we cannot enforce the order of the time component of each component.
The order is important, because the \emph{equivalence} of the concrete semantics depends on the fact that the $\tick$ function always generates a fresh timestamp larger than the times in the context and in the memory.
The notion of equivalence between concrete configurations and the notion of soundness between the concrete and abstract configurations is essential in developing a formal guarantee that our modular separate analysis does generate some sound abstract state.

\begin{definition}[Domain of a configuration]
  We define the domain of a configuration given by $C, \sigma, t$ to be
  \[
    \mathsf{Dom}(C,\sigma,t)\triangleq\{t'|t'\in C\lor t'\in\mathsf{Dom}(\sigma)\lor t' = t\}
  \]
\end{definition}

\begin{definition}[Equivalence between concrete configurations]
  $\:$

  \begin{itemize}
    \item Let $(\Time,\le,\tick)$ and $(\Time',\le',\tick')$ be two concrete times.
    \item Let $(C,\sigma,t)$ be a configuration in the first time domain and $(C',\sigma',t')$ be a configuration in the second time domain.
  \end{itemize}
  The two configurations are equivalent if there exists a strictly increasing function $f\in\mathsf{Dom}(C,\sigma,t)\rightarrow\mathsf{Dom}(C',\sigma',t')$ that translates $(C,\sigma,t)$ into $(C',\sigma',t')$.
  \[
    (C,\sigma,t)\equiv(C',\sigma',t')\triangleq\exists f\in\mathsf{Dom}(C,\sigma,t)\rightarrow\mathsf{Dom}(C',\sigma',t'): f\text{ strictly increases}\wedge f(C)= C' \wedge f(t) = t' \wedge f\circ\sigma = \sigma'\circ f
  \]

  Furthermore, we extend the definition of $\equiv$ to a relation between $(\Value{\Time}+\Ctx{\Time})\times\Mem{\Time}\times\Time$ and $(\Value{\Time'}+\Ctx{\Time'})\times\Mem{\Time'}\times\Time'$ to mean that
  \[
    (V,\sigma,t)\equiv(V',\sigma',t')\triangleq
    \begin{cases}
      x=x'\wedge e=e'\wedge (C,\sigma,t)\equiv(C',\sigma',t') & (V=\langle\lambda x.e,C\rangle\wedge V'=\langle\lambda x'.e',C'\rangle) \\
      (C,\sigma,t)\equiv(C',\sigma',t')                       & (V=C\wedge V'=C')                                                       \\
      \text{False}                                            & (\text{otherwise})
    \end{cases}
  \]
\end{definition}

We can prove that this relation indeed defines an equivalence relation, since such a function $f$ automatically becomes a bijection between $\mathsf{Dom}(C,\sigma,t)$ and $\mathsf{Dom}(C',\sigma',t')$.

\begin{lem}[Preservation of equivalence]
  $\:$

  \begin{itemize}
    \item Let $(\Time,\le,\tick)$ and $(\Time',\le',\tick')$ be two concrete times.
    \item Let $(C,\sigma,t)$ be a configuration in the first time domain and $(C',\sigma',t')$ be a configuration in the second time domain.
    \item Let all timestamps in $C$ and $\sigma$ be strictly less than $t$.
    \item Let $(C,\sigma,t)\equiv (C',\sigma',t')$.
  \end{itemize}

  Then for all $e$, if $(e,C,\sigma,t)\Downarrow(V,\sigma'',t'')$, there exists $V',\sigma''',t'''$ such that $(e,C',\sigma',t')\Downarrow(V',\sigma''',t''')$ and $(V,\sigma'',t'')\equiv(V',\sigma''',t''')$.
  Likewise, if $(e,C,\sigma,t)\rightsquigarrow(e',C'',\sigma'',t'')$, there exists $C''',\sigma''',t'''$ such that $(e,C',\sigma',t')\rightsquigarrow(e',C''',\sigma''',t''')$ and $(C'',\sigma'',t'')\equiv(C''',\sigma''',t''')$.
\end{lem}

Now we need to define a concrete time on $\Time+\Time'$, when the first time domain exports $C',\sigma'$ to the second time domain.
What we want to prove that is: $(C',\sigma',t')\equiv(C',\sigma',t_{0})$, when the first configuration is in $\Time$ and the second configuration is in $\Time+\Time'$, with $t_{0}$ being the initial time in $\Time'$.
Then the reachable states from $(e_{2},C',\sigma',t_{0})$ under the added domain are equivalent to the reachable states from $(e_{2},C',\sigma',t')$.
Thus, because we can obtain a subset of the reachable states from $(e_{2},C',\sigma',t_{0})$ by simply \emph{injecting} $C'$ and $\sigma'$ into the reachable states obtained from $\sembracket{e_{2}}([],\varnothing,t_{0})$, we can compute a set \textit{equivalent to} $\sembracket{e_{2}}(C',\sigma',t')$ starting from the \emph{separately analyzed} results.

Before elaborating on how to link the time domains, we need to define the injection and deletion operators that inject the exported context into the separately analyzed results.
The notation for injecting $C_{1}$ into $C_{2}$ is $\inject{C_{1}}{C_{2}}$, similar to the plugin operator defined above.

\[
  \mapinject(C_{1},C_{2})\triangleq
  \begin{cases}
    []                                                          & (C_{2}=[])                \\
    \lambda x^{t}. \mapinject(C_{1},C')                         & (C_{2}=\lambda x^{t}. C') \\
    \Let\:x^{t}\:\mapinject(C_{1},C')                           & (C_{2}=\Let\:x^{t}\:C')   \\
    \Let\:M\:C_{1}[\mapinject(C_{1},C')]\:\mapinject(C_{1},C'') & (C_{2}=\Let\:M\:C'\:C'')
  \end{cases}
\]

\[
  \inject{C_{1}}{C_{2}}\triangleq C_{1}[\mapinject(C_{1},C_{2})]
\]
We extend the injection operator to map over all closures in a memory so that $\inject{C}{\sigma}$ can be defined naturally.

\[
  \deletepre(C_{1},C_{2})\triangleq
  \begin{cases}
    \deletepre(C_{1}',C_{2}') & ((C_{1},C_{2})=(\lambda x^{t}.C_{1}',\lambda x^{t}.C_{2}')) \\
    \deletepre(C_{1}',C_{2}') & ((C_{1},C_{2})=(\Let\: x^{t}\:C_{1}',\Let\:x^{t}\:C_{2}'))  \\
    \deletepre(C_{1}',C_{2}') & ((C_{1},C_{2})=(\Let\:M\:C'\:C_{1}',\Let\:M\:C'\:C_{2}'))   \\
    C_{2}                     & (\text{otherwise})
  \end{cases}
\]

\[
  \deletemap(C_{1},C_{2})\triangleq
  \begin{cases}
    []                                                                     & (C_{2}=[])               \\
    \lambda x^{t}.\deletemap(C_{1},C')                                     & (C_{2}=\lambda x^{t}.C') \\
    \Let\:x^{t}\:\deletemap(C_{1},C')                                      & (C_{2}=\Let\:x^{t}\:C')  \\
    \Let\:M\:\deletemap(C_{1},\deletepre(C_{1},C'))\:\deletemap(C_{1},C'') & (C_{2}=\Let\:M\:C'\:C'')
  \end{cases}
\]

\[
  \delete(C_{1},C_{2})\triangleq \deletemap(C_{1},\deletepre(C_{1},C_{2}))
\]
The deletion operation has the expected property that $\delete(C,\inject{C}{C'})=C'$.

Finally, before delving into the definition of the linked time domain, we need to define a filter function that filters the context and memory by membership in each time domain.

\[
  \filter(C,\Time)\triangleq
  \begin{cases}
    []                                             & (C=[])                                   \\
    \lambda x^{t}.\filter(C',\Time)                & (C=\lambda x^{t}.C'\wedge t\in\Time)     \\
    \Let\:x^{t}\:\filter(C',\Time)                 & (C=\Let\:x^{t}\:C'\wedge t\in\Time)      \\
    \Let\:M\:\filter(C',\Time)\:\filter(C'',\Time) & (C=\Let\:M\:C'\:C'')                     \\
    \filter(C',\Time)                              & (C=\lambda x^{t}.C'\wedge t\not\in\Time) \\
    \filter(C',\Time)                              & (C=\Let\:x^{t}\:C'\wedge t\not\in\Time)
  \end{cases}
\]

\[
  \filter(\sigma,\Time)\triangleq
  \lambda t\in\Time.\mathsf{let}\:\langle\lambda x.e,C\rangle\coloneq\sigma(t)\:\mathsf{in}\:\langle\lambda x.e,\filter(C,\Time)\rangle
\]

\begin{lem}[Linking of time domains]
  $\:$

  \begin{itemize}
    \item Let $(\Time,\le,\tick)$ and $(\Time',\le',\tick')$ be two concrete times.
    \item Let $C_{0}\in\Ctx{\Time}$ be the injected context.
    \item Define the $\le_{+}$ order by
          \[
            t \le_{+} t' \triangleq
            \begin{cases}
              t \le t'     & (t,t'\in\Time)          \\
              t \le' t'    & (t,t'\in\Time')         \\
              \text{True}  & (t\in\Time,t'\in\Time') \\
              \text{False} & (t\in\Time',t'\in\Time)
            \end{cases}
          \]
    \item Define the $\tick_{+}$ function so that the timestamps produced from the \emph{injected} context and state are exactly the timestamps produced before injection.
          \[
            \tick_{+}(C,\sigma,t,x,v)\triangleq
            \begin{cases}
              \tick(\filter(C,\Time),\filter(\sigma,\Time),t,x,\filter(v,\Time))                                            & (t\in\Time)  \\
              \tick'(\filter(\delete(C_0,C),\Time'),\filter(\delete(C_0,\sigma),\Time'),t,x,\filter(\delete(C_0,v),\Time')) & (t\in\Time')
            \end{cases}
          \]
  \end{itemize}

  Then $(\Time+\Time',\le_{+},\tick_{+})$ is a concrete time.
\end{lem}

\begin{lem}[Preservation of timestamps under linked time]
  $\:$

  \begin{itemize}
    \item Let $(\Time,\le,\tick)$ and $(\Time',\le',\tick')$ be two concrete times.
    \item Let $C_{0}\in\Ctx{\Time}$ be the injected context.
    \item Let $\sigma_{0}\in\Mem{\Time}$ be the injected memory, and let
          \[
            \sigma;\sigma_{0}\triangleq\lambda t.
            \begin{cases}
              \sigma(t)     & (t\in\Time') \\
              \sigma_{0}(t) & (t\in\Time)
            \end{cases}
          \]
          for $\sigma\in\Mem{\Time'}$.
  \end{itemize}

  Now, if $(e,C,\sigma,t)\Downarrow(V,\sigma',t')$ under $\Time'$, then
  $(e,\inject{C_0}{C},\inject{C_0}{\sigma};\sigma_{0},t)\Downarrow(\inject{C_0}{V},\inject{C_0}{\sigma};\sigma_0,t')$ under $\Time+\Time'$.

  Likewise, if $(e,C,\sigma,t)\rightsquigarrow(e',C',\sigma',t')$ under $\Time'$, then
  $(e,\inject{C_0}{C},\inject{C_0}{\sigma};\sigma_{0},t)\rightsquigarrow(e',\inject{C_0}{C'},\inject{C_0}{\sigma};\sigma_0,t')$ under $\Time+\Time'$.
\end{lem}

\begin{definition}[Subset to an equivalent set]
  $\:$

  \begin{itemize}
    \item $A\loverbar{\subseteq}B$ in the context when $A,B\in(\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time)$ is defined as
          \[
            (e,C,\sigma,t)\in A\Rightarrow \exists C',\sigma',t' : (C,\sigma,t)\equiv(C',\sigma',t')\wedge(e,C',\sigma',t')\in B
          \]
    \item $A\loverbar{\subseteq}B$ in the context when $A,B\in(\Expr\times\Ctx{\Time}\times\Mem{\Time}\times\Time)\times(\Value{\Time}\times\Mem{\Time}\times\Time)$ is defined as
          \begin{align*}
            ((e,C,\sigma,t),(V,\sigma',t'))\in A\Rightarrow \exists C',\sigma'',t'',V',\sigma''',t''' : & (C,\sigma,t)\equiv(C',\sigma'',t'')\wedge(V,\sigma',t')\equiv(V',\sigma''',t''')\wedge \\
                                                                                                        & ((e,C',\sigma'',t''),(V',\sigma''',t'''))\in B
          \end{align*}
  \end{itemize}
\end{definition}

\begin{thm}[Separate analysis] We want to compute $\sembracket{\link{e_{1}}{e_{2}}}(C,\sigma,t)$.
  $\:$

  \begin{itemize}
    \item Given $R$ and $S$ that satisfies $\Resolved{e_{1}}(C,\sigma,t)\loverbar{\subseteq} R$ and $\Stuck{e_{1}}(C,\sigma,t)\loverbar{\subseteq} S$,
    \item Let $E\triangleq\{(C_{0},\sigma_{0},t'')|\exists C',\sigma',t':(C,\sigma,t)\equiv(C',\sigma',t')\wedge((e_{1},C',\sigma',t'),(C_{0},\sigma_{0},t''))\in R\}$(exported configurations).
    \item Let $R(C_{0},\sigma_{0})\triangleq\{((e_{2},C_{0},\sigma_{0},t_{0}), (\inject{C_{0}}{V},\inject{C_{0}}{\sigma};\sigma_{0},t))|((e_{2},[],\varnothing,t_{0}),(V,\sigma,t))\in\Resolved{e_{2}}([],\varnothing,t_{0})\}$(separate resolved).
    \item Let $S(C_{0},\sigma_{0})\triangleq\{(e,\inject{C_{0}}{C},\inject{C_{0}}{\sigma};\sigma_{0},t)|(e,C,\sigma,t)\in\Stuck{e_{2}}([],\varnothing,t_{0})\}$(separate stuck).
    \item Let ${S}_{\rightsquigarrow}(C_{0},\sigma_{0})\triangleq\{(e',C',\sigma',t')|\exists(e,C,\sigma,t)\in S(C_{0},\sigma_{0}):(e,C,\sigma,t)\rightsquigarrow(e',C',\sigma',t')\}$.
    \item Let $\tilde{R}(C_{0},\sigma_{0})\triangleq\{((e',C',\sigma',t'), (V,\sigma'',t''))|(e',C',\sigma',t')\in{S}_{\rightsquigarrow}(C_{0},\sigma_{0})\wedge(e',C',\sigma',t')\Downarrow(V,\sigma'',t'')\}$.
    \item Let $\tilde{S}(C_{0},\sigma_{0})\triangleq\{(e',C',\sigma',t')|(e',C',\sigma',t')\in S_{\rightsquigarrow}(C_{0},\sigma_{0})\wedge\forall V,\sigma'',t'':\lnot((e',C',\sigma',t')\Downarrow(V,\sigma'',t''))\}$.
  \end{itemize}

  We have:
  \[
    \Resolved{e_{2}}(C_{0},\sigma_{0},t_{0})=R(C_{0},\sigma_{0})\cup\tilde{R}(C_{0},\sigma_{0})
  \]
  \[
    \Stuck{e_{2}}(C_{0},\sigma_{0},t_{0})=\tilde{S}(C_{0},\sigma_{0})
  \]

  Thus:
  \[
    \Resolved{\link{e_1}{e_2}}(C,\sigma,t)\loverbar{\subseteq}
    R\cup\bigcup_{(C_{0},\sigma_{0},t')\in E}{(\Resolved{e_2}(C_{0},\sigma_{0},t_{0})\cup\underbrace{\{((\link{e_1}{e_2}, C, \sigma, t), (V,\sigma'',t''))|((e_{2},C_{0},\sigma_{0},t_{0}),(V,\sigma'',t''))\in\Resolved{e_{2}}(C_{0},\sigma_{0},t_{0})\}}_{\text{The final evaluation}})}
  \]
  \[
    \Stuck{\link{e_1}{e_2}}(C,\sigma,t)\loverbar{\subseteq}S\cup\bigcup_{(C_{0},\sigma_{0},t')\in E}{\Stuck{e_2}(C_{0},\sigma_{0},t_{0})}\cup \{(\link{e_1}{e_2}, C, \sigma, t)|\exists (C_{0},\sigma_{0},t')\in E:(e_{2},C_{0},\sigma_{0},t_{0})\in\Stuck{e_{2}}(C_{0},\sigma_{0},t_{0})\}
  \]
\end{thm}

\section{Abstract Semantics}



\begin{definition}[Soundness]
\end{definition}

\begin{lem}[Equivalence preserves soundness]
\end{lem}

\begin{lem}[Finiteness of time implies finiteness of abstraction]
\end{lem}

\printbibliography
\end{document}
%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:
