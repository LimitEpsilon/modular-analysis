%! TEX program = xelatex
\documentclass[acmsmall,screen,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

%%% Typesetting for listings
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}

%%% lstlisting coq style (inspired from a file of Assia Mahboubi)
\lstdefinelanguage{Coq}{
    % To insert blank lines, write %
    escapechar=\%,
    % Anything betweeen $ becomes LaTeX math mode
    mathescape=true,
    % Comments may or not include Latex commands
    texcl=false, 
    % Vernacular commands
    morekeywords=[1]{Section, Module, End, Require, Import, Export, Include,
        Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
        Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
        Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
        Morphism, Relation, Implicit, Arguments, Unset, Contextual,
        Strict, Prenex, Implicits, Inductive, CoInductive, Record,
        Structure, Canonical, Coercion, Context, Class, Global, Instance,
        Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
        Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
        Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
        Projections, inside, outside, Def},
    % Gallina
    morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
        match, with, end, as, in, return, let, if, is, then, else, for, of,
        nosimpl, when},
    % Sorts
    morekeywords=[3]{Type, Prop, Set, true, false, option},
    % Various tactics, some are std Coq subsumed by ssr, for the manual purpose
    morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
        intro, intros, generalize, rename, pattern, after, destruct,
        induction, using, refine, inversion, injection, rewrite, congr,
        unlock, compute, ring, field, fourier, replace, fold, unfold,
        change, cutrewrite, simpl, have, suff, wlog, suffices, without,
        loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
        symmetry, transitivity, auto, split, left, right, autorewrite},
    % Terminators
    morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
        assumption, solve, contradiction, discriminate},
    % Control
    morekeywords=[6]{do, last, first, try, idtac, repeat},
    % Comments delimiters, we do turn this off for the manual
    morecomment=[s]{(*}{*)},
    % Spaces are not displayed as a special character
    showstringspaces=false,
    % String delimiters
    morestring=[b]",
    morestring=[d],
    % Size of tabulations
    tabsize=3,
    % Enables ASCII chars 128 to 255
    extendedchars=false,
    % Case sensitivity
    sensitive=true,
    % Automatic breaking of long lines
    breaklines=false,
    % Default style fors listings
    basicstyle=\small,
    % Position of captions is bottom
    captionpos=b,
    % flexible columns
    columns=[l]flexible,
    % Style for (listings') identifiers
    identifierstyle={\ttfamily\color{black}},
    % Style for declaration keywords
    keywordstyle=[1]{\ttfamily\color{dkviolet}},
    % Style for gallina keywords
    keywordstyle=[2]{\ttfamily\color{dkgreen}},
    % Style for sorts keywords
    keywordstyle=[3]{\ttfamily\color{ltblue}},
    % Style for tactics keywords
    keywordstyle=[4]{\ttfamily\color{dkblue}},
    % Style for terminators keywords
    keywordstyle=[5]{\ttfamily\color{dkred}},
    %Style for iterators
    %keywordstyle=[6]{\ttfamily\color{dkpink}},
    % Style for strings
    stringstyle=\ttfamily,
    % Style for comments
    commentstyle={\ttfamily\color{dkgreen}},
    %moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
    literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
    %    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
    %
}[keywords,comments,strings]

%%% Citation style
\citestyle{acmauthoryear}

%%% Math settings
\usepackage{mathtools}
\theoremstyle{acmdefinition}
\newtheorem*{notation*}{Notation}

%%% PL constructs
\usepackage{galois}
\usepackage{ebproof}
\ebproofset{left label template=\textsc{[\inserttext]}}
\ebproofset{center=false}

%%% Custom commands
\newcommand*{\vbar}{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{â©´}}
\newcommand*{\ortype}{\mathrel{|}}
\newcommand*{\cons}{::}
\newcommand*{\pset}{\mathcal{P}}
\newcommand*{\preall}[2][black]{\prescript{\textcolor{#1}{\forall}}{}{#2}}
\newcommand*{\prexists}[2][black]{\prescript{\textcolor{#1}{\exists}}{}{#2}}

\def\ovbarw{1.2mu}
\def\ovbarh{1}
\def\equivadjust{-1em}
\newcommand*{\ovbar}[1]{\mkern \ovbarw\overline{\mkern-\ovbarw{\smash{#1}\scalebox{1}[\ovbarh]{\vphantom{i}}}\mkern-\ovbarw}\mkern \ovbarw}
\newcommand*{\A}[1]{\overset{\,_{\mbox{\Large .}}}{#1}}
\newcommand*{\Abs}[1]{{#1}^{\#}}
\newcommand*{\Expr}{\mathsf{Expr}}
\newcommand*{\ExprVar}{\mathsf{Var}}
\newcommand*{\Module}{\mathsf{Module}}
\newcommand*{\ModVar}{\mathsf{ModVar}}
\newcommand*{\modid}{d}
\newcommand*{\Time}{\mathbb{T}}
\newcommand*{\ATime}{\A{\Time}}
\newcommand*{\ctx}{\sigma}
\newcommand*{\Ctx}{\mathsf{Ctx}}
\newcommand*{\Value}{\mathsf{Val}}
\newcommand*{\Mem}{\mathsf{Mem}}
\newcommand*{\Sig}{\mathsf{Sig}}
\newcommand*{\mem}{m}
\newcommand*{\Trace}{\mathsf{Trace}}
\newcommand*{\AMem}{\A{\mathsf{Mem}}}
\newcommand*{\Config}{\mathsf{Config}}
\newcommand*{\config}{c}
\newcommand*{\Right}{\mathsf{Right}}
\newcommand*{\rightst}{r}
\newcommand*{\texteq}[1]{\stackrel{\mathclap{\tiny\normalfont\mbox{#1}}}{=}}
\newcommand*{\State}{\mathsf{State}}
\newcommand*{\AState}{\A{\mathsf{State}}}
\newcommand*{\Outcome}{\mathsf{Outcome}}
\newcommand*{\Tick}{\mathsf{Tick}}
\newcommand*{\lfp}{\mathsf{lfp}}
\newcommand*{\Step}{\mathsf{Step}}
\newcommand*{\semarrow}{\hookrightarrow}
\newcommand*{\asemarrow}{\A{\hookrightarrow}}
\newcommand*{\synlink}{\rtimes}
\newcommand*{\semlink}{\mathbin{\rotatebox[origin=c]{180}{$\propto$}}}
\newcommand*{\link}[2]{{#1}\rtimes{#2}}
\newcommand*{\mt}{\mathsf{emp}}
\newcommand*{\valid}{\checkmark}
\newcommand*{\Path}{\mathsf{Path}}
\newcommand*{\equivalent}{\sim}

\newcommand*{\doubleplus}{\ensuremath{\mathbin{+\mkern-3mu+}}}
\newcommand*{\project}{\text{\texttt{:>} }}
\newcommand*{\sembracket}[1]{\lBrack{#1}\rBrack}
\newcommand*{\fin}[2]{{#1}\xrightarrow{\text{fin}}{#2}}
\newcommand*{\addr}{\mathsf{addr}}
\newcommand*{\tick}{\mathsf{tick}}
\newcommand*{\modctx}{\mathsf{ctx}}
\newcommand*{\inject}[2]{{#2}\langle{#1}\rangle}
\newcommand*{\delete}[2]{{#2}{\langle{#1}\rangle}^{-1}}
\newcommand*{\filter}{\mathsf{filter}}
\newcommand*{\Let}{\mathtt{let}}

\title{A Syntax-Guided Framework for Modular Analysis}
\author{Joonhyup Lee}
\begin{document}
\maketitle
\section{Introduction}
We make the following observations:
\begin{itemize}
  \item Most code that static analyzers deal with is \emph{open code} that uses external values.
  \item Those external values are defined in a different \emph{scope} from the code of interest.
  \item The different scopes are organized in term of \emph{modules}.
  \item The modules are interfaced through \emph{module names}.
\end{itemize}
Therefore, experts who write realistic analyzers are immediately faced with the problem of \emph{closing} open code.
Especially, in the case when external values are not defined in the same language, the semantics of such values must be \emph{modelled}, either by the analysis expert or by the user of the analyzer.
Since we cannot possibly model all such cases in one try, attempts to close open code must be a never-ending race of fractional advances.

If we force the analyzers to output results only in the fortunate case that all external values has already been modelled, we end up unnecessarily recomputing each time we fail to close completely.
We claim that this is undesirable.
The analyzer, upon meeting an open term, may just ``cache'' what has been computed already and ``pick up'' from there when that open term is resolved.
The problem is: can we model such a computation {mathematically}?
Therefore, we aim to define semantics for terms that have been fractionally closed, and prove that \emph{closing} the \emph{fractionally closed semantics} is equal to the \emph{closed semantics}.

\subsection{Separate Static Analyis}
To illustrate what we mean by the ``fractionally closed semantics'', we first give a concrete example.
\begin{center}
  \begin{tabular}{ccc}
    \begin{minipage}{0.3\linewidth}
      \begin{lstlisting}[language=Coq]
(* Module M *)
let x = 1
%
%
%
    \end{lstlisting}
    \end{minipage} &
    \begin{minipage}{0.3\linewidth}
      \begin{lstlisting}[language=Coq]
(* Module F *)
let fix fact n =
  if n <= 0 then 1
  else n * fact (n - 1)
    \end{lstlisting}
    \end{minipage}      &
    \begin{minipage}{0.3\linewidth}
      \begin{lstlisting}[language=Coq]
(* Client code *)
Include M
Include F
(F.fact 100) + M.x
    \end{lstlisting}
    \end{minipage}
  \end{tabular}
\end{center}

Above, we have a piece of code that adds an integer \texttt{x} exported by the module \texttt{M} to the result of $100!$.
Given this program, a compiler that supports separate compilation produces object files that can be linked with different implementations of the module \texttt{M}.
What we desire is some sort of semantic object for static analyzers that corresponds to such object files.
Since object files represent programs with unresolved variable references, we say that they are fractionally closed.

Defining separate analysis results and linking allows discussion for a wide variety of cases.
Say that the client code is analyzed with \emph{only} assuming the implementation for \texttt{F.fact}.
Thus, the analysis result, if well defined, will contain the information that the unresolved variable \texttt{M.x} must be added to $100!$.
Later, when the full implementation of the modules are known, we simply link what was missing with the separate analysis results.

Such an approach is useful in two ways:

\noindent\textbf{Rely-guarantee}

When the client code is linked with another implementation of \texttt{F}, check whether \texttt{fact} is changed, and if it is not changed, simply inject the rest into the analysis results.

\noindent\textbf{Incrementality}

If the implementation of \texttt{x} is changed, it will not trigger re-analysis of the whole program.

\section{Uncovering Modularity in Operational Semantics}
First we introduce our model language.
The language is an extension of untyped lambda calculus with modules and the linking construct.
\begin{figure}[h!]
  \footnotesize
  \centering
  \begin{tabular}{rrcll}
    Identifiers & $x,\modid$ & $\in$         & $\ExprVar$                                                             \\
    Expression  & $e$        & $\rightarrow$ & $x$ $\vbar$ $\lambda x.e$ $\vbar$ $e$ $e$ & untyped $\lambda$-calculus \\
                &            & $\vbar$       & $\link{e}{e}$                             & linked expression          \\
                &            & $\vbar$       & $\varepsilon$                             & empty module               \\
                &            & $\vbar$       & $\modid$                                  & module identifier          \\
                &            & $\vbar$       & $\Let$ $x$ $e$ $e$                        & expression binding         \\
                &            & $\vbar$       & $\Let$ $\modid$ $e$ $e$                   & module binding             \\
  \end{tabular}
  \caption{Abstract syntax of the simple module language.}
  \label{fig:syntax}
\end{figure}

The language is expressive enough to encode simple imports and exports:
{ \footnotesize
\begin{align*}
  e_1          & \triangleq\text{\texttt{let x = 1 in }}\varepsilon                                                                                                   & (\text{module \texttt{M}})           \\
  e_2          & \triangleq\text{\texttt{let fact = fix }}\lambda\text{\texttt{fact.}}\lambda\text{\texttt{n.if0 n 1 (* n (fact (- n 1))) in }}\varepsilon            & (\text{module \texttt{F}})           \\
  e            & \triangleq(\text{\texttt{+ (F}}\synlink\text{\texttt{fact 100) (M}}\synlink\text{\texttt{x)}})                                                       & (\text{client code})                 \\
  e_{\synlink} & \triangleq(\text{\texttt{let M = }}e_1\text{\texttt{ in }}\varepsilon)\synlink(\text{\texttt{let F = }}e_2\text{\texttt{ in }}\varepsilon)\synlink e & (\text{whole program after linking})
\end{align*}}%
Above is how the example in the introduction is translated into the simple module language in Figure \ref{fig:syntax}, assuming that the definitions for arithmetic and the fixpoint combinator \texttt{fix} are given.

\subsection{Operational Semantics}
\begin{figure}[h!]
  \footnotesize
  \centering
  \begin{tabular}{rrcll}
    Environment/Context          & $\ctx$     & $\in$         & $\Ctx$                                                                 \\
    Value of expressions         & $v$        & $\in$         & $\Value \triangleq \ExprVar\times\Expr\times\Ctx$                      \\
    Value of expressions/modules & $V$        & $\in$         & $\Value+\Ctx$                                                          \\
    Configuration (left)         & $\config$  & $\in$         & $\Config\triangleq\Expr\times\Ctx$                                     \\
    Configuration (right)        & $\rightst$ & $\in$         & $\Right\triangleq\Config+\Value+\Ctx$                                  \\
    Context                      & $\ctx$     & $\rightarrow$ & []                                                & empty stack        \\
                                 &            & $\vbar$       & $(x,v)\cons \ctx$                                 & expression binding \\
                                 &            & $\vbar$       & $(\modid,\ctx)\cons \ctx$                         & module binding     \\
    Value of expressions         & $v$        & $\rightarrow$ & $\langle \lambda x.e, \ctx \rangle$               & closure
  \end{tabular}
  \caption{Definition of the semantic domains.}
  \label{fig:simpdom}
\end{figure}

\begin{figure}[t!]
  \scriptsize
  \begin{flushright}
    \fbox{$(e,\ctx)\semarrow V\text{ or }(e',\ctx')$}
  \end{flushright}
  \centering
  \vspace{0pt} % -0.75em}
  \[
    \begin{prooftree}
      \hypo{v=\ctx(x)}
      \infer[left label=ExprID]1{
      (x, \ctx)
      \semarrow
      v
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \infer[left label=Fn]0{
      (\lambda x.e, \ctx)
      \semarrow
      \langle\lambda x.e, \ctx\rangle
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \infer[left label={AppL}]0{
      (e_{1}\:e_{2}, \ctx)
      \semarrow
      (e_{1},\ctx)
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx)
          \semarrow
          \langle\lambda x.e_{\lambda}, \ctx_{\lambda}\rangle
        \end{matrix}
      }
      \infer[left label={AppR}]1{
      (e_{1}\:e_{2}, \ctx)
      \semarrow
      (e_{2}, \ctx)
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx)
          \semarrow
          \langle\lambda x.e_{\lambda}, \ctx_{\lambda}\rangle \\
          (e_{2}, \ctx)
          \semarrow
          v
        \end{matrix}
      }
      \infer[left label={AppBody}]1{
      (e_{1}\:e_{2}, \ctx)
      \semarrow
      (e_{\lambda}, (x, v)\cons \ctx_{\lambda})
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx)
          \semarrow
          \langle\lambda x.e_{\lambda}, \ctx_{\lambda}\rangle \\
          (e_{2}, \ctx)
          \semarrow
          v                                                   \\
          (e_{\lambda}, (x, v)\cons \ctx_{\lambda})
          \semarrow
          v'
        \end{matrix}
      }
      \infer[left label={App}]1{
      (e_{1}\:e_{2}, \ctx)
      \semarrow
      v'
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=LinkL]0{
      (\link{e_{1}}{e_{2}}, \ctx)
      \semarrow
      (e_{1}, \ctx)
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx)
          \semarrow
          \ctx'
        \end{matrix}
      }
      \infer[left label=LinkR]1{
      (\link{e_{1}}{e_{2}}, \ctx)
      \semarrow
      (e_{2}, \ctx')
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx)
          \semarrow
          \ctx' \\
          (e_{2}, \ctx')
          \semarrow
          V
        \end{matrix}
      }
      \infer[left label=Link]1{
      (\link{e_{1}}{e_{2}}, \ctx)
      \semarrow
      V
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=Empty]0{
      (\varepsilon, \ctx)
      \semarrow
      \ctx
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{\ctx'=\ctx(\modid)}
      \infer[left label=ModID]1{
      (\modid, \ctx)
      \semarrow
      \ctx'
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=LetEL]0{
      (\mathtt{let}\:x\:e_1\:e_2, \ctx)
      \semarrow
      (e_{1}, \ctx)
      }
    \end{prooftree}\quad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx)
          \semarrow
          v
        \end{matrix}
      }
      \infer[left label=LetER]1{
      (\mathtt{let}\:x\:e_1\:e_2, \ctx)
      \semarrow
      (e_{2}, (x, v)\cons \ctx)
      }
    \end{prooftree}\quad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx)
          \semarrow
          v \\
          (e_{2}, (x, v)\cons \ctx)
          \semarrow
          \ctx'
        \end{matrix}
      }
      \infer[left label=LetE]1{
      (\mathtt{let}\:x\:e_1\:e_2, \ctx)
      \semarrow
      \ctx'
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \infer[left label=LetML]0{
      (\mathtt{let}\:\modid\:e_{1}\:e_{2}, \ctx)
      \semarrow
      (e_{1}, \ctx)
      }
    \end{prooftree}\quad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx)
          \semarrow
          \ctx'
        \end{matrix}
      }
      \infer[left label=LetMR]1{
      (\mathtt{let}\:\modid\:e_{1}\:e_{2}, \ctx)
      \semarrow
      (e_{2}, (\modid, \ctx')\cons \ctx)
      }
    \end{prooftree}\quad
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx)
          \semarrow
          \ctx' \\
          (e_{2}, (\modid, \ctx')\cons \ctx)
          \semarrow
          \ctx''
        \end{matrix}
      }
      \infer[left label=LetM]1{
      (\mathtt{let}\:\modid\:e_{1}\:e_{2}, \ctx)
      \semarrow
      \ctx''
      }
    \end{prooftree}
  \]
  \caption{The concrete one-step transition relation.}
  \label{fig:simpreach}
\end{figure}
We present the operational semantics $\semarrow$ for our language.
The semantic domains are given in Figure \ref{fig:simpdom} and the operational semantics is defined in Figure \ref{fig:simpreach}.

Our semantics relate an element $\config$ of $\Config$ with an element $\rightst$ of $\Right$.
Note that $\ctx(x)$ pops the highest value that is associated with $x$ from the stack $\ctx$ and $\ctx(\modid)$ pops the highest context associated with $\modid$ from $\ctx$.
The relation $\semarrow$ is unorthodox in that unlike normal big-step operaional semantics, it relates a configuration not only to its final result but also to intermediate configurations of which its values are required to compute the final result.
Why it is defined as such is because defining a \emph{collecting semantics} becomes much simpler.

\subsection{Collecting Semantics}
To define a semantics that is computable, we must formulate the collecting semantics as a least fixed point of a monotonic function that maps an element of some CPO $\Trace$ to $\Trace$, when:
\[\Sigma\triangleq\Right\:+\:\semarrow\qquad\Trace\triangleq\pset(\Sigma)\]
The semantics of an expression $e$ starting from initial states in $C\subseteq\Ctx$ is the collection of $\config\semarrow\rightst$ and $\rightst$ derivable from initial configurations $(e,\ctx)$ with $\ctx\in C$.
Defining the transfer function is straightforward from the definition of the transition relation.

\begin{definition}[Transfer function]
  Given $A\subseteq\Sigma$, define:
  \[
    \mathsf{Step}(A)\triangleq
    \left\{\config\semarrow\rightst, \rightst\middle|
    \begin{prooftree}[center=true]
      \hypo{A'}\infer1{\config\semarrow\rightst}
    \end{prooftree}\text{ and }
    A'\subseteq A\text{ and }\config\in A
    \right\}
  \]
\end{definition}

The $\mathsf{Step}$ function is naturally monotonic, as a ``cache'' $A$ that remembers more about the intermediate proof tree will derive more results than a cache that remembers less.
In fact, we can prove that it is continuous, as it preserves the least upper bound of chains.
Now, because of Tarski's fixpoint theorem, we can formulate the collecting semantics in fixpoint form.
\begin{definition}[Collecting semantics]
  Given $e\in\Expr$ and $C\subseteq\Ctx$, define:
  \[
    \sembracket{e}C\triangleq\lfp(\lambda X.\mathsf{Step}(X)\cup\{(e,\ctx)|\ctx\in C\})
  \]
\end{definition}
Note that the above definition can be defined even when the $\ctx$ in $(e,\ctx)$ does not close $e$.
Then the collecting semantics will store the proof tree only up to the point the first free variable is evaluated.

\subsection{Semantic Linking}
Now we present a natural notion of \emph{semantic linking} that, given a (1) (possibly incomplete) proof tree of an expression $e$ under some initial context $\ctx_1$ and (2) some external context $\ctx_2$, gives the meaning of $e$ under the \emph{linked} context of $\ctx_1$ and $\ctx_2$.
Thus, it will be clear how analysis results obtained locally can be reused to obtain the meaning of the whole program, all at the level of the operational semantics.

We first define what it means to \emph{fill in the blanks} of an individual $r_2\in\Right$ with a $\ctx_1\in\Ctx$:
\[
  \inject{\ctx_{1}}{r_{2}}\triangleq
  \begin{cases}
    \ctx_1                                                         & r_{2}=[]                           \\
    (x, \inject{\ctx_1}{v})\cons\inject{\ctx_{1}}{\ctx}            & r_{2}=(x,v)\cons \ctx              \\
    (\modid, \inject{\ctx_{1}}{\ctx})\cons\inject{\ctx_{1}}{\ctx'} & r_{2}=(\modid,\ctx)\cons \ctx'     \\
    \langle\lambda x.e,\inject{\ctx_1}{\ctx}\rangle                & r_2=\langle\lambda x.e,\ctx\rangle \\
    (e,\inject{\ctx_1}{\ctx})                                      & r_2 = (e, \ctx)
  \end{cases}
\]
This does indeed ``fill in the blanks'', since:
\begin{lemma}[Fill in the Blanks]
  For all $\ctx_1,\ctx_2\in\Ctx$, for each expression variable $x$,
  \[
    \ctx_2(x)=v\Rightarrow\inject{\ctx_1}{\ctx_2}(x)=\inject{\ctx_1}{v}\text{ and }\ctx_2(x)=\bot\Rightarrow\inject{\ctx_1}{\ctx_2}(x)=\ctx_1(x)
  \]
  and for each module variable $\modid$,
  \[
    \ctx_2(\modid)=\ctx\Rightarrow\inject{\ctx_1}{\ctx_2}(d)=\inject{\ctx_1}{\ctx}\text{ and }\ctx_2(\modid)=\bot\Rightarrow\inject{\ctx_1}{\ctx_2}(\modid)=\ctx_1(\modid)
  \]
\end{lemma}
\begin{proof}[Sketch]
  Induction on $\ctx_2$.
\end{proof}

Moreover, filling in the blanks preserves the evaluation relation $\semarrow$.
\begin{lemma}[Injection Preserves $\semarrow$]\label{lem:injpreseval}
  For all $\config\in\Config$, $\rightst\in\Right$, $\ctx\in\Ctx$,
  \[\config\semarrow\rightst\Rightarrow\inject{\ctx}{\config}\semarrow\inject{\ctx}{\rightst}\]
\end{lemma}
\begin{proof}[Sketch]
  Induction on $\semarrow$.
\end{proof}

Thus, we can define $\rhd$ that injects a \emph{set} of contexts $C$ into an subset $A$ of $\Sigma$ and a semantic linking operation $\semlink$ that does the rest of the computation:
\begin{definition}[Injection]
  For $C\subseteq\Ctx$ and $A\subseteq\Sigma$, define:
  \[C\rhd A\triangleq\{\inject{\ctx}{\rightst}|\ctx\in C,\rightst\in A\}\cup\{\inject{\ctx}{\config}\semarrow\inject{\ctx}{\rightst}|\ctx\in C,\config\semarrow\rightst\in A\}\]
\end{definition}
\begin{definition}[Semantic Linking]
  For $C\subseteq\Ctx$ and $A\subseteq \Sigma$, define:
  \[C\semlink A\triangleq\lfp(\lambda X.\Step(X)\cup(C\rhd A))\]
\end{definition}

Thus we reach the main theorem that allows ``fractional closures'' to be soundly defined:
\begin{theorem}[Advance]
  For all $e\in\Expr$ and $C_1,C_2\subseteq\Ctx$,
  \[\sembracket{e}(C_1\rhd C_2)=C_1\semlink\sembracket{e}C_2\]
\end{theorem}
\begin{proof}
  Let $A$ be $\{(e,\ctx)|\ctx\in C_1\rhd C_2\}$, and let $B$ be $C_1\rhd\sembracket{e}C_2$.
  Note that $A\subseteq B$ by the definition of $\sembracket{e}C_2$.
  Also, let $X_A$ be $\lfp(\lambda X.\Step(X)\cup A)=\sembracket{e}(C_1\rhd C_2)$ and let $X_B$ be $\lfp(\lambda X.\Step(X)\cup B)=C_1\semlink\sembracket{e}C_2$.
  By Lemma \ref{lem:injpreseval}, we have that $B\subseteq X_A$.

  Then first, $X_A$ is a fixed point of $\lambda X.\Step(X)\cup B$, since:
  \[X_A=X_A\cup B=(\Step(X_A)\cup A)\cup B=\Step(X_A)\cup(A\cup B)=\Step(X_A)\cup B\]
  Then since $X_B$ is the least fixed point, $X_B\subseteq X_A$.

  Also, note that $X_B$ is a pre-fixed point of $\lambda X.\Step(X)\cup A$, since:
  \[\Step(X_B)\cup A\subseteq\Step(X_B)\cup B=X_B\]
  $\Trace$ is a complete lattice, so by Tarski's fixpoint theorem, $X_A$ is the least of all pre-fixed points of $\lambda X.\Step(X)\cup A$.
  Since $X_B$ is a pre-fixed point, $X_A\subseteq X_B$.

  Since $X_B\subseteq X_A$ and $X_A\subseteq X_B$, we have that $X_A=X_B$.
\end{proof}

\subsection{Skeleton of a Static Analysis}
We require a CPO $\Abs{\Trace}$ that is Galois connected with $\Trace$:
\[\Trace=\pset(\Sigma)\galois{\alpha}{\gamma}\Abs{\Trace}\]
and semantic operators $\Abs\Step$ and $\Abs\rhd$ that satisfies:
\[\Step\circ\gamma\subseteq\gamma\circ\Abs\Step\qquad\rhd\circ(\gamma,\gamma)\subseteq\gamma\circ\Abs\rhd\]
Then we define $\Abs{\sembracket{e}}$ and $\Abs\semlink$ as:
\[
  \Abs{\sembracket{e}}\Abs{C}\triangleq\lfp(\lambda\Abs{X}.\Abs\Step(\Abs{X})\Abs\cup\alpha\{(e,\ctx)|\ctx\in\gamma\Abs{C}\})\qquad
  \Abs{C}\Abs\semlink\Abs{A}\triangleq\lfp(\lambda\Abs{X}.\Abs\Step(\Abs{X})\Abs\cup(\Abs{C}\Abs\rhd\Abs{A}))
\]
which, by definition and Tarski's fixpoint theorem satisfies:
\[\sembracket{e}\circ\gamma\subseteq\gamma\circ\Abs{\sembracket{e}}\qquad\semlink\circ(\gamma,\gamma)\subseteq\gamma\circ\Abs\semlink\]
Then we can soundly approximate fractional specifications by:
\begin{align*}
  C_1\semlink\sembracket{e}C_2 & \subseteq C_1\semlink\gamma(\Abs{\sembracket{e}}\alpha(C_2))                 & (\because\sembracket{e}\subseteq\gamma\circ\Abs{\sembracket{e}}\circ\alpha\text{ and monotonicity of }\semlink) \\
                               & \subseteq \gamma(\alpha(C_1))\semlink\gamma(\Abs{\sembracket{e}}\alpha(C_2)) & (\because\text{id}\subseteq\gamma\circ\alpha\text{ and monotonicity of }\semlink)                               \\
                               & \subseteq\gamma(\alpha(C_1)\Abs\semlink\Abs{\sembracket{e}}\alpha(C_2))      & (\because\semlink\circ(\gamma,\gamma)\subseteq\gamma\circ\Abs\semlink)
\end{align*}
\section{Instrumented Semantics}
All that is left is to present an abstraction for the semantics in the previous section.
We need to abstract $C\subseteq\Ctx$ to finitely compute an overapproximation.
However, devising such an abstraction is not immediately obvious.

The problem is that closures bound in $\sigma\in\Ctx$ again contain contexts.
To break this recursive structure, we employ the common technique of introducing addresses and a memory.
Thus, we extend the operational semantics of the previous section to a sematics that involve choosing a \emph{time} domain $\Time$ to use as addresses.

\subsection{Semantic Domains}
\begin{figure}[h!]
  \footnotesize
  \centering
  \begin{tabular}{rrcll}
    Time                         & $t$        & $\in$         & $\Time$                                                                       \\
    Environment/Context          & $\ctx$     & $\in$         & $\Ctx$                                                                        \\
    Value of expressions         & $v$        & $\in$         & $\Value \triangleq\ExprVar\times\Expr\times\Ctx$                              \\
    Value of expressions/modules & $V$        & $\in$         & $\Value+\Ctx$                                                                 \\
    Memory                       & $\mem$     & $\in$         & $\Mem \triangleq \fin{\Time}{\Value}$                                         \\
    State                        & $s$        & $\in$         & $\State \triangleq \Ctx\times\Mem\times\Time$                                 \\
    Outcome                      & $o$        & $\in$         & $\Outcome \triangleq (\Value+\Ctx)\times\Mem\times\Time$                      \\
    Configuration (left)         & $\config$  & $\in$         & $\Config\triangleq\Expr\times\State$                                          \\
    Configuration (right)        & $\rightst$ & $\in$         & $\Right\triangleq\Config+\Outcome$                                            \\
    Context                      & $\ctx$     & $\rightarrow$ & []                                                       & empty stack        \\
                                 &            & $\vbar$       & $(x,t)\cons \ctx$                                        & expression binding \\
                                 &            & $\vbar$       & $(\modid,\ctx)\cons \ctx$                                & module binding     \\
    Value of expressions         & $v$        & $\rightarrow$ & $\langle \lambda x.e, \ctx \rangle$                      & closure
  \end{tabular}
  \caption{Definition of the instrumented semantic domains.}
  \label{fig:concdom}
\end{figure}

The domains for defining the operational semantics is extended to include the \emph{time} and \emph{memory}.
Compared with Figure \ref{fig:simpdom}, Figure \ref{fig:concdom} defines four more sets, $\Time$, $\Mem$, $\State$, and $\Outcome$.

Note that a heavy burden has been cast upon the \emph{time} component.
The time component is responsible for providing \emph{fresh} addresses to write to in the memory, and it is also an indicator of the execution \emph{history} up to that point.
Hence, the policy for incrementing the timestamps of states decides what events are recorded in the timestamps, and the abstraction of this policy must select what events are preserved in the abstract semantics.
We name this policy $\tick$ in our framework.
The \emph{type} of $\tick$ can be freely chosen, since it may choose to record any event that occurs during execution, but in this section we choose the type $\Time\rightarrow\Time$, the simplest possible option.

\subsection{Operational Semantics}
\begin{figure}[t!]
  \scriptsize
  \begin{flushright}
    \fbox{$(e,\ctx,\mem,t)\semarrow(V,\mem',t')\text{ or }(e',\ctx',\mem',t')$}
  \end{flushright}
  \centering
  \vspace{0pt} % -0.75em}
  \[
    \begin{prooftree}
      \hypo{t_{x}={\ctx}(x)}
      \hypo{v=\mem(t_{x})}
      \infer[left label=ExprID]2{
      (x, \ctx, \mem, t)
      \semarrow
      (v, \mem, t)
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \infer[left label=Fn]0{
      (\lambda x.e, \ctx, \mem, t)
      \semarrow
      (\langle\lambda x.e, \ctx\rangle, \mem, t)
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx, \mem, t)
          \semarrow
          (\langle\lambda x.e_{\lambda}, \ctx_{\lambda}\rangle, \mem_{\lambda}, t_{\lambda}) \\
          (e_{2}, \ctx, \mem_{\lambda}, t_{\lambda})
          \semarrow
          (v, \mem_{a}, t_{a})                                                               \\
          (e_{\lambda}, (x, \tick(t_{a}))\cons \ctx_{\lambda}, \mem_{a}[\tick(t_{a})\mapsto v], \tick(t_a))
          \semarrow
          (v', \mem',t')
        \end{matrix}
      }
      \infer[left label={App}]1{
      (e_{1}\:e_{2}, \ctx, \mem, t)
      \semarrow
      (v', \mem',t')
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx, \mem, t)
          \semarrow
          (\ctx', \mem', t') \\
          (e_{2}, \ctx', \mem', t')
          \semarrow
          (V, \mem'', t'')
        \end{matrix}
      }
      \infer[left label=Link]1{
      (\link{e_{1}}{e_{2}}, \ctx, \mem, t)
      \semarrow
      (V, \mem'', t'')
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \infer[left label=Empty]0{
      (\varepsilon, \ctx, \mem, t)
      \semarrow
      (\ctx, \mem, t)
      }
    \end{prooftree}\qquad
    \begin{prooftree}
      \hypo{\ctx'={\ctx}(\modid)}
      \infer[left label=ModID]1{
      (\modid, \ctx, \mem, t)
      \semarrow
      (\ctx', \mem, t)
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx, \mem, t)
          \semarrow
          (v, \mem', t') \\
          (e_{2}, (x, \tick(t'))\cons \ctx, \mem'[\tick(t')\mapsto v], \tick(t'))
          \semarrow
          (\ctx', \mem'', t'')
        \end{matrix}
      }
      \infer[left label=LetE]1{
      (\mathtt{let}\:x\:e_1\:e_2, \ctx, \mem, t)
      \semarrow
      (\ctx', \mem'', t'')
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \ctx, \mem, t)
          \semarrow
          (\ctx', \mem', t') \\
          (e_{2}, (\modid, \ctx')\cons \ctx, \mem', t')
          \semarrow
          (\ctx'', \mem'', t'')
        \end{matrix}
      }
      \infer[left label=LetM]1{
      (\mathtt{let}\:\modid\:e_{1}\:e_{2}, \ctx, \mem, t)
      \semarrow
      (\ctx'', \mem'', t'')
      }
    \end{prooftree}
  \]
  \caption{Excerpt of the concrete instrumented semantics, corresponding to the big-step evaluation rules.}
  \label{fig:concreach}
\end{figure}

An excerpt of the instrumented operational semantics is given in Figure \ref{fig:concreach}.
One must first note that there is a problem with the definition of $\semarrow$ as it is.
There are no restrictions on $\tick$ and the states $(\ctx,\mem,t)$, thus a write to the address $\tick(t)$ may overwrite an existing value that may be used for future computations.
Thus, $\tick(t)\not\in\mathsf{supp}(\ctx,\mem)$ must be guaranteed, when $\mathsf{supp}(\ctx,\mem)$ is the set of timestamps reachable from $(\ctx,\mem)$.
To enforce this invariant upon all \emph{valid} concrete executions defined by the relation $\semarrow$, we enforce that there be a \emph{total order} on $\Time$.
Then our criteria can be guaranteed by first enforcing that $\ctx\le t$ and $\mem\le t$, where $\ctx\le t$ means that all timestamps in $\ctx$ are bound by $t$, and $\mem\le t$ means that all timestamps allocated in the memory are bound by $t$.

Then the criteria that $\tick(t)$ must be fresh is formalized by demanding that:
\[t < \tick(t)\]
This condition is not as restrictive as it seems, as we can conversely think of a $\tick$ generating fresh timestamps as \emph{inducing} a total order on $\Time$.
Now, to allow only such valid transitions, we define:
\[
  \State\triangleq\{(\ctx,\mem,t)|\ctx\le t\text{ and }\mem\le t\}\qquad
  \Outcome\triangleq\{(V,\mem,t)|V\le t\text{ and }\mem\le t\}
\]
as the set of valid states that enable $\tick$ to generate fresh timestamps.
It is almost trivial that the set $\Config\times\Right$ is closed under the inductive definition of $\semarrow$.
That is,
\begin{lemma}[Valid States Transition to Valid States]
  For all $\config\in\Config$, if $\config\semarrow\rightst$ according to the inductive rules, $\rightst\in\Right$.
\end{lemma}
\begin{proof}[Sketch]
  Induction on $\semarrow$.
\end{proof}

\subsection{Collecting Semantics}
The definition for the collecting semantics of the language is identical to the collecting semantics in the previous section.
That is, when we write:
\[\Sigma\triangleq\Right\:+\:\semarrow\qquad\Trace\triangleq\pset(\Sigma)\]
\begin{definition}[Transfer function]
  Given $A\subseteq \Sigma$, define
  \[
    \mathsf{Step}(A)\triangleq
    \left\{\config\semarrow\rightst, \rightst\middle|
    \begin{prooftree}[center=true]
      \hypo{A'}\infer1{\config\semarrow\rightst}
    \end{prooftree}\text{ and }
    A'\subseteq A\text{ and }\config\in A
    \right\}
  \]
\end{definition}
and
\begin{definition}[Collecting semantics]
  Given $e\in\Expr$ and $S\subseteq\State$, define:
  \[
    \sembracket{e}S\triangleq\lfp(\lambda X.\mathsf{Step}(X)\cup\{(e,s)|s\in S\})
  \]
\end{definition}
\subsection{Semantic Linking}
Now we need to define an injection operation that fills in the blanks of a $o\texteq{let}(V,\mem,t)\in\Outcome$ with a $s\texteq{let}(\ctx',\mem',t')\in\State$.
Recall the definition for injection in the semantics without memory.
$\inject{\ctx}{V}$ enables access to values that were previously not available in $V$ by filling in the bottom of the stack with $\ctx$.
Thus, we must mimic this by filling in all contexts in $r$ with the context part of $s$.
Also, to retain all information stored in the memory, the memory part of $r$ must be merged with the memory of $s$.

It is at this point that a problem occurs.
When merging the two memories $\mem$ and $\mem'$, we may encounter overlapping addresses.
Thus, we must require that all reachable addresses from $(\ctx,\mem)$ does not overlap with reachable addresses in $(\ctx',\mem')$.
Then again, this requirement may be lifted if we allow linking of semantics that use \emph{different} time domains as addresses.
Note that we can only \emph{read} values from $\ctx$ in $\inject{\ctx}{V}$; we should preserve addresses that were used in $s$ before injection and never allow writing to those addresses.
Thus, in this section we first define $\inject{s_1}{r_2}$, when $s_1$ uses $\Time_1$ and $r_2$ uses $\Time_2$.
Then $\inject{s_1}{r_2}$ must live in a version of $\Outcome$ that uses $\Time_1+\Time_2$.

\subsubsection{Linking the Semantic Domains}
Assume that we have two concrete time domains $(\Time_1,\le_1,\tick_1)$ and $(\Time_2,\le_2,\tick_2)$.
We first need to define what it means to link the time domains.
\[
  \Time_{\semlink}\triangleq\Time_1+\Time_2\quad
  \le_{\semlink}\triangleq\text{lexicographic order}\quad
  \tick_{\semlink}(t)\triangleq
  \begin{cases}
    \tick_1(t) & t\in\Time_1 \\
    \tick_2(t) & t\in\Time_2
  \end{cases}
\]

\begin{notation*}
  All sets with the subscript $i(i=1,2)$ is assumed to be using $\Time_i$ as timestamps, and all sets with the subscript $\semlink$ is assumed to be using $\Time_{\semlink}$ as timestamps.
\end{notation*}
Then we can define different versions of semantic operators.
\begin{definition}[Versions of $\semarrow$, $\Step$]$\:$

  \begin{enumerate}
    \item $\semarrow_1$, $\semarrow_2$, $\semarrow_{\semlink}$ are the same as $\semarrow$ except that each use $(\Time_1,\tick_1)$, $(\Time_2,\tick_1)$, $(\Time_{\semlink},\tick_{\semlink})$.
    \item $\Step_1$, $\Step_2$, $\Step_{\semlink}$ are the same as $\Step$ except that each use $\semarrow_1$, $\semarrow_2$, $\semarrow_{\semlink}$.
  \end{enumerate}
\end{definition}

\subsubsection{Injection and Linking}
Now we define injection between $s_1\texteq{let}(\ctx_1,\mem_1,t_1)\in\State_1$ and $o_2\texteq{let}(V_2,\mem_2,t_2)\in\Outcome_2$:
\[
  \begin{array}{cc}
    \inject{\ctx_{1}}{V_{2}}\triangleq
    \begin{cases}
      \ctx_1                                                         & V_{2}=[]                               \\
      (x, t)\cons\inject{\ctx_{1}}{\ctx}                             & V_{2}=(x,t)\cons \ctx                  \\
      (\modid, \inject{\ctx_{1}}{\ctx})\cons\inject{\ctx_{1}}{\ctx'} & V_{2}=(\modid,\ctx)\cons \ctx'         \\
      \langle\lambda x.e,\inject{\ctx_1}{\ctx_2}\rangle              & V_{2}=\langle\lambda x.e,\ctx_2\rangle
    \end{cases} &
    \begin{array}{l}
      \inject{\ctx_1}{\mem_2}\triangleq
      \displaystyle\bigcup_{t\in\mathsf{dom}(\mem_2)}\{t\mapsto\inject{\ctx_1}{\mem_2(t)}\} \\ \\
      \inject{s_1}{o_2}\triangleq
      (\inject{\ctx_1}{V_2},\mem_1\cup\inject{\ctx_1}{\mem_2},t_2)
    \end{array}
  \end{array}
\]

As is expected, injecting $s_1$ into $o_2$ involves injecting $\ctx_1$ in every context in $o_2$ and merging the memories.
This definition is exactly what we were searching for, since it respects all requirements laid out in the introduction to this section.
First, $\inject{s_1}{o_2}\in\Outcome_{\semlink}$ with respect to the ordering $\le_{\semlink}$.
Also, if we define $\inject{s_1}{(e,s_2)}\triangleq(e,\inject{s_1}{s_2})$, we can show that injection preserves valid transitions.
\begin{lemma}[Injection Preserves $\semarrow$]
  For all $s_1\in\State_1$, $\config_2\in\Config_2$, $\rightst_2\in\Right_2$,
  \[\config_2\semarrow_2\rightst_2\Rightarrow\inject{s_1}{\config_2}\semarrow_{\semlink}\inject{s_1}{\rightst_2}\]
\end{lemma}
\begin{proof}[Sketch]
  Induction on $\semarrow_2$.
\end{proof}

Thus we can define $\rhd$ and $\semlink$ that satisfies the desired property.
\begin{definition}[Injection]
  For $S_1\subseteq\State_1$ and $A_2\subseteq\Sigma_2$, define:
  \[
    S_1\rhd A_2\triangleq\{\inject{s_1}{\rightst_2}|s_1\in S_1,\rightst_2\in A_2\}\cup\{\inject{s_1}{\config_2}\semarrow_{\semlink}\inject{s_1}{\rightst_2}|s_1\in S_1,\config_2\semarrow_2\rightst_2\in A_2\}
  \]
\end{definition}
\begin{definition}[Semantic Linking]
  For $S_1\subseteq\State_1$ and $A_2\subseteq\Sigma_2$, define:
  \[
    S_1\semlink A_2\triangleq\lfp(\lambda X.\Step_{\semlink}(X)\cup(S_1\rhd A_2))
  \]
\end{definition}
\begin{theorem}[Advance]
  For all $e\in\Expr$ and $S_1\subseteq\State_1$, $S_2\subseteq\State_2$,
  \[
    \sembracket{e}(S_1\rhd S_2)=S_1\semlink\sembracket{e}S_2
  \]
\end{theorem}

\section{Abstracting the Instrumented Semantics}
\subsection{Abstract Semantics}
\begin{figure}[h!]
  \footnotesize
  \centering
  \begin{tabular}{rrcll}
    Abstract Time                  & $\A{t}$        & $\in$         & $\A{\Time}$                                                                                      \\
    Environment/Context            & $\A{\ctx}$     & $\in$         & $\A{\Ctx}$                                                                                       \\
    Value of expressions           & $\A{v}$        & $\in$         & $\A{\Value} \triangleq \ExprVar\times\Expr\times\A{\Ctx}$                                        \\
    Value of expressions/modules   & $\A{V}$        & $\in$         & $\A{\Value}+\A{\Ctx}$                                                                            \\
    Abstract Memory                & $\A{\mem}$     & $\in$         & $\A{\Mem} \triangleq \fin{\A{\Time}}{\pset(\A{\Value})}$                                         \\
    Abstract State                 & $\A{s}$        & $\in$         & $\A{\State} \triangleq \A{\Ctx}\times\A{\Mem}\times\A{\Time}$                                    \\
    Abstract outcome               & $\A{o}$        & $\in$         & $\A{\Outcome} \triangleq(\A{\Value}+\A{\Ctx})\times\A{\Mem}\times\A{\Time}$                      \\
    Abstract configuration (left)  & $\A{\config}$  & $\in$         & $\A{\Config}\triangleq\Expr\times\A{\State}$                                                     \\
    Abstract configuration (right) & $\A{\rightst}$ & $\in$         & $\A{\Right}\triangleq\A{\Config}+\A{\Outcome}$                                                   \\
    Context                        & $\A{\ctx}$     & $\rightarrow$ & []                                                                          & empty stack        \\
                                   &                & $\vbar$       & $(x,\A{t})\cons \A{\ctx}$                                                   & expression binding \\
                                   &                & $\vbar$       & $(\modid,\A{\ctx})\cons \A{\ctx}$                                           & module binding     \\
    Value of expressions           & $\A{v}$        & $\rightarrow$ & $\langle \lambda x.e, \A{\ctx} \rangle$                                     & closure
  \end{tabular}
  \caption{Definition of the semantic domains in the abstract case.}
  \label{fig:absdom}
\end{figure}
Now we present a way to simply abstract the concrete semantics via an abstraction of the time component.
For this purpose, we choose an \emph{abstract time} domain $\A\Time$ that is connected to the concrete time domain via an auxiliary function $\A\alpha:\Time\rightarrow\A\Time$.
Since the policy to update the timestamp must also be compatible with respect to $\A\alpha$, we require:
\[\A\tick\in\A\Time\rightarrow\A\Time\qquad\A\alpha\circ\tick=\A\tick\circ\A\alpha\]

Then the operational semantics can be abstracted directly, with modifications only in the \emph{update} of the memory and \emph{reads} from the memory.
The memory update operation is now a weak update $\A{\mem}[\A{t}\A{\mapsto}\A{v}]$,
and a read from the memory returns a set of closures with abstract addresses, allowing transitions to any value within that set.
An excerpt for the abstract version of the operational semantics $\A\semarrow\subseteq\A{\Config}\times\A{\Right}$ is in Figure \ref{fig:absreach}.

\begin{figure}[t!]
  \scriptsize
  \begin{flushright}
    \fbox{$(e,\A{\ctx},\A\mem,\A{t})\A\semarrow(\A{V},\A{\mem'},\A{t'})\text{ or }(e',\A{\ctx'},\A{\mem'},\A{t'})$}
  \end{flushright}
  \vspace{0pt} % -0.75em}
  \[
    \begin{prooftree}
      \hypo{\A{t_x}=\A{\ctx}(x)}
      \hypo{\A{v}\in\A\mem(\A{t_x})}
      \infer[left label=ExprID]2{
      (x, \A{\ctx}, \A\mem, \A{t})
      \A\semarrow
      (\A{v}, \A\mem, \A{t})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{\ctx}, \A\mem, \A{t})
          \A\semarrow
          (\langle\lambda x.e_{\lambda}, \A{\ctx}_{\lambda}\rangle, \A\mem_{\lambda}, \A{t_\lambda}) \\
          (e_{2}, \A{\ctx}, \A\mem_{\lambda}, \A{t_\lambda})
          \A\semarrow
          (\A{v}, \A\mem_{a}, \A{t_a})                                                               \\
          (e_{\lambda}, (x, \A\tick(\A{t_a}))\cons \A{\ctx}_{\lambda}, \A\mem_{a}[\A\tick(\A{t_a})\A\mapsto \A{v}], \A\tick(\A{t_a}))
          \A\semarrow
          (\A{v'}, \A{\mem'},\A{t'})
        \end{matrix}
      }
      \infer[left label={App}]1{
      (e_{1}\:e_{2}, \A{\ctx}, \A\mem, \A{t})
      \A\semarrow
      (\A{v'}, \A{\mem'},\A{t'})
      }
    \end{prooftree}
  \]

  \[
    \begin{prooftree}
      \hypo{
        \begin{matrix}
          (e_{1}, \A{\ctx}, \A\mem, \A{t})
          \A\semarrow
          (\A{v}, \A{\mem'}, \A{t'}) \\
          (e_{2}, (x, \A\tick(\A{t'}))\cons \A{\ctx}, \A{\mem'}[\A\tick(\A{t'})\A\mapsto \A{v}], \A\tick(\A{t'}))
          \A\semarrow
          (\A{\ctx'}, \A{\mem''}, \A{t''})
        \end{matrix}
      }
      \infer[left label=LetE]1{
      (\mathtt{let}\:x\:e_1\:e_2, \A{\ctx}, \A\mem, \A{t})
      \A\semarrow
      (\A{\ctx'}, \A{\mem''}, \A{t''})
      }
    \end{prooftree}
  \]
  \caption{Excerpt of the abstract operational semantics, corresponding to the big-step evaluation rules that differ from the concrete version.}
  \label{fig:absreach}
\end{figure}

We note that the abstract semantics is a sound approximation of the concrete semantics in the operational sense, since if we extend $\A\alpha$ as:
\begin{align*}
  \A\alpha([])                             & \triangleq []                                               &  &  & \A\alpha(\mem)        & \triangleq\lambda\A{t}.\{\A\alpha(\mem(t))|\A\alpha(t)=\A{t}\} \\
  \A\alpha((x,t_x)\cons \ctx)              & \triangleq(x,\A\alpha(t_x))\cons\A\alpha(\ctx)              &  &  & \A\alpha(\ctx,\mem,t) & \triangleq(\A\alpha(\ctx),\A\alpha(\mem),\A\alpha(t))          \\
  \A\alpha((\modid,\ctx_\modid)\cons \ctx) & \triangleq(\modid,\A\alpha(\ctx_\modid))\cons\A\alpha(\ctx) &  &  & \A\alpha(v,\mem,t)    & \triangleq(\A\alpha(v),\A\alpha(\mem),\A\alpha(t))             \\
  \A\alpha(\langle\lambda x.e,\ctx\rangle) & \triangleq\langle\lambda x.e,\A\alpha(\ctx)\rangle          &  &  & \A\alpha(e,s)         & \triangleq (e,\A\alpha(s))
\end{align*}
We have:
\begin{lemma}[Operational Soundness]\label{lem:opsound}
  For all $\config\in\Config$ and $\rightst\in\Right$,
  \[\config\semarrow\rightst\Rightarrow\A\alpha(\config)\A\semarrow\A\alpha(\rightst)\]
\end{lemma}
\begin{proof}[Sketch]
  Induction on $\semarrow$.
\end{proof}

Then if we define:
\[\A\Sigma\triangleq\A\Right\:+\:\A\semarrow\qquad\Abs{\Trace}\triangleq\pset(\A\Sigma)\]
we can establish a Galois connection between $\Trace$ and $\Abs{\Trace}$.
The abstraction and concretization functions are given by:
\begin{definition}
  Define $\alpha:\Trace\rightarrow\Abs{\Trace}$ and $\gamma:\Abs{\Trace}\rightarrow \Trace$ by:
  \begin{align*}
    \alpha(A)       & \triangleq\{\A\alpha(\config)\asemarrow\A\alpha(\rightst)|\config\semarrow\rightst\in A\}\cup\{\A\alpha(\rightst)|\rightst\in A\}           \\
    \gamma(\Abs{A}) & \triangleq\{\config\semarrow\rightst|\A\alpha(\config)\asemarrow\A\alpha(\rightst)\in\Abs{A}\}\cup\{\rightst|\A\alpha(\rightst)\in\Abs{A}\}
  \end{align*}
\end{definition}

Then it is straightforward to see that:
\begin{lemma}[Galois Connection]
  $\Trace=\pset(\Sigma)\galois{\alpha}{\gamma}\Abs{\Trace}=\pset(\A\Sigma)$. That is:
  \[\forall A\in \Trace,\Abs{A}\in\Abs{\Trace}:\alpha(A)\subseteq\Abs{A}\Leftrightarrow A\subseteq\gamma(\Abs{A})\]
\end{lemma}
\begin{proof}[Sketch]
  Straightforward from the definitions of $\alpha$ and $\gamma$.
\end{proof}

The definition for the abstract semantics is naturally connected soundly with the collecting semantics.
\begin{definition}[Abstract transfer function]
  Given $\Abs{A}\subseteq\A{\Sigma}$, define:
  \[
    \Abs{\mathsf{Step}}(\Abs{A})\triangleq
    \left\{\A\config\A\semarrow\A\rightst, \A\rightst\middle|
    \begin{prooftree}[center=true]
      \hypo{\Abs{A'}}\infer1{\A\config\A\semarrow\A\rightst}
    \end{prooftree}\text{ and }
    \Abs{A'}\subseteq \Abs{A}\text{ and }\A\config\in\Abs{A}
    \right\}
  \]
\end{definition}
\begin{definition}[Abstract semantics]
  Given $e\in\Expr$ and $\Abs{S}\subseteq\A\State$, define:
  \[
    \Abs{\sembracket{e}}\Abs{S}\triangleq\lfp(\lambda \Abs{X}.\Abs{\mathsf{Step}}(\Abs{X})\cup\{(e,\A{s})|\A{s}\in \Abs{S}\})
  \]
\end{definition}
Then we can prove that:
\begin{theorem}[Soundness]
  For all $e\in\Expr$, $\sembracket{e}\circ\gamma\subseteq\gamma\circ\Abs{\sembracket{e}}$.
\end{theorem}
\begin{proof}
  By Lemma \ref{lem:opsound}, we have that $\alpha\circ\Step\subseteq\Abs\Step\circ\alpha$.
  Then by the fixpoint transfer theorem and Galois connection, we have our desired result.
\end{proof}

Now we can say that $\Abs{\sembracket{e}}\alpha(S)$ is a sound abstraction of $\sembracket{e}S$.
However, how can we make $\Abs{\sembracket{e}}\alpha(S)$ finitely computable?

Observe that even for infinite computations such as $\omega\:\omega$ when $\omega=\lambda x.x\:x$,
the shape of the \emph{context} is limited.
Each time an application occurs, a new address is allocated in the memory and that address is pushed into the context.
For the term $\omega\:\omega$, the context that is being modified is \emph{always} the empty context $[]$ that was stored in the memory as a closure $\langle\lambda x.x\:x,[]\rangle$.
Thus, the only part in the configuration that makes computations infinite is the domain of the memory.

Therefore, we may show that finitizing $\A\Time$ is enough to guarantee finite termination.
\begin{theorem}[Finiteness]
  For all $e\in\Expr$, if $\A\Time$ and $\Abs{S}\subseteq\A\State$ is finite, $\Abs{\sembracket{e}}\Abs{S}$ is finite.
\end{theorem}
\begin{proof}[Sketch]
  Given $\A{s}\in\Abs{S}$, we want to prove that there is some finite set $X$ satisfying:
  \[\forall \A\rightst\in\A\Right:(e,\A{s}){\A\semarrow}^*\A\rightst\Rightarrow\A\rightst\in X\]
  Note that $\A\rightst$ is of the form $(\langle\lambda x.e',\A{\ctx}\rangle,\A\mem,\A{t})$ or $(\A{\ctx},\A\mem,\A{t})$ or $(e',\A{\ctx},\A\mem,\A{t})$.
  Since there is a finite number of abstract timestamps, we only have to show that there is a finite number of \emph{shapes} of $\A\rightst$ that is stripped of the timestamps.
  This is proven in Coq (\texttt{Abstract.v}).
\end{proof}
\subsection{Abstract Linking}
\subsubsection{Linking the Semantic Domains}
As in the concrete semantics, we assume two abstract time domains $(\A\Time_1,\A\tick_1)$ and $(\A\Time_2,\A\tick_2)$ and define how the time domains should be linked.
Moreover, we need to define how the auxiliary abstraction functions $\A\alpha_1$ and $\A\alpha_2$ are linked.
\[
  \A\Time_{\semlink}\triangleq\A\Time_1+\A\Time_2\quad
  \A\tick_{\semlink}(\A{t})\triangleq
  \begin{cases}
    \A\tick_1(\A{t}) & \A{t}\in\A\Time_1 \\
    \A\tick_2(\A{t}) & \A{t}\in\A\Time_2
  \end{cases}\quad
  \A\alpha_{\semlink}(t)\triangleq
  \begin{cases}
    \A\alpha_1(t) & t\in\Time_1 \\
    \A\alpha_2(t) & t\in\Time_2
  \end{cases}
\]
\begin{notation*}
  All sets with the subscript $i(i=1,2)$ is assumed to be using $\Time_i$ as timestamps, and all sets with the subscript $\semlink$ is assumed to be using $\Time_{\semlink}$ as timestamps.
\end{notation*}
Then we can define different versions of semantic operators.
\begin{definition}[Versions of $\A\semarrow$, $\Abs\Step$]$\:$

  \begin{enumerate}
    \item $\A\semarrow_1$, $\A\semarrow_2$, $\A\semarrow_{\semlink}$ are the same as $\A\semarrow$ except that each use $(\A\Time_1,\A\tick_1)$, $(\A\Time_2,\A\tick_2)$, $(\A\Time_{\semlink},\A\tick_{\semlink})$.
    \item $\Abs\Step_1$, $\Abs\Step_2$, $\Abs\Step_{\semlink}$ are the same as $\Abs\Step$ except that each use $\A\semarrow_1$, $\A\semarrow_2$, $\A\semarrow_{\semlink}$.
  \end{enumerate}
\end{definition}

\subsubsection{Injection and Linking}
We define injection and linking in the abstract semantics in the same way as the concrete semantics.
Only the definition of $\inject{\A{\ctx}_1}{\A\mem_2}$ has to be adapted to account for the fact that $\A\mem_2(\A{t})$ is now a \emph{set} of closures.
This means that $\inject{\A{\ctx}_1}{\A\mem_2}$ must be defined as:
\[\inject{\A{\ctx}_1}{\A\mem_2}\triangleq\lambda\A{t}.\{\inject{\A{\ctx}_1}{\A{v}_2}|\A{v}_2\in\A\mem_2(\A{t})\}\]
Then we can show that:
\begin{lemma}[Injection Preserves $\A\semarrow$]
  For all $\A{s}_1\in\A\State_1$, $\A\config_2\in\A\Config_2$, $\A\rightst\in\A\Right_2$,
  \[\A\config_2\A\semarrow_2\A\rightst_2\Rightarrow\inject{\A{s}_1}{\A\config_2}\A\semarrow_{\semlink}\inject{\A{s}_1}{\A\rightst_2}\]
\end{lemma}
\begin{proof}[Sketch]
  Induction on $\A\semarrow_2$.
\end{proof}
and thus we can define:
\begin{definition}[Abstract Injection]
  For $\Abs{S}_1\subseteq\A\State_1$ and $\Abs{A}_2\subseteq\A{\Sigma}_2$, define:
  \[
    \Abs{S}_1\Abs\rhd\Abs{A}_2\triangleq\{\inject{\A{s}_1}{\A\rightst_2}|\A{s}_1\in\Abs{S}_1,\A\rightst_2\in\Abs{A}_2\}\cup\{\inject{\A{s}_1}{\A\config_2}\A\semarrow_{\semlink}\inject{\A{s}_1}{\A\rightst_2}|\A{s}_1\in\Abs{S}_1,\A\config_2\A\semarrow_2\A\rightst_2\in\Abs{A}_2\}
  \]
\end{definition}
\begin{definition}[Abstract Linking]
  For $\Abs{S}_1\subseteq\A\State_1$ and $\Abs{A}_2\subseteq\A{\Sigma}_2$, define:
  \[
    \Abs{S}_1\Abs\semlink\Abs{A}_2\triangleq\lfp(\lambda\Abs{X}.\Abs\Step_{\semlink}(\Abs{X})\cup(\Abs{S}_1\Abs\rhd\Abs{A}_2))
  \]
\end{definition}
so that the \emph{best possible result} is achieved:
\begin{theorem}[Abstract Advance]
  For all $e\in\Expr$ and $\Abs{S}_1\subseteq\A\State_1$, $\Abs{S}_2\subseteq\A\State_2$,
  \[
    \Abs{\sembracket{e}}(\Abs{S}_1\Abs\rhd\Abs{S}_2)=\Abs{S}_1\Abs\semlink\Abs{\sembracket{e}}\Abs{S}_2
  \]
\end{theorem}
\begin{corollary}[Correctness of $\Abs{\semlink}$]
  For all $e\in\Expr$ and $S_1\subseteq\State_1$, $S_2\subseteq\State_2$,
  \[S_1\semlink\sembracket{e}S_2\subseteq\gamma_{\semlink}(\alpha_1(S_1)\Abs\semlink\Abs{\sembracket{e}}\alpha_2(S_2))\]
\end{corollary}
\begin{proof}
  $\alpha_{\semlink}(S_1\rhd A_2)=\alpha_1(S_1)\Abs\rhd\alpha_2(A_2)$
  since $\alpha_{\semlink}(\inject{s_1}{r_2})=\inject{\alpha_1(s_1)}{\alpha_2(r_2)}$(induction on $r_2$). Thus:
  \begin{align*}
    S_1\semlink\sembracket{e}S_2 & =\sembracket{e}(S_1\rhd S_2)                                                   & (\because\text{Advance})                                                    \\
                                 & \subseteq\gamma_{\semlink}(\Abs{\sembracket{e}}\alpha_{\semlink}(S_1\rhd S_2)) & (\because\text{Galois connection})                                          \\
                                 & =\gamma_{\semlink}(\Abs{\sembracket{e}}(\alpha_1(S_1)\Abs\rhd\alpha_2(S_2)))   & (\because\alpha_{\semlink}(S_1\rhd A_2)=\alpha_1(S_1)\Abs\rhd\alpha_2(A_2)) \\
                                 & =\gamma_{\semlink}(\alpha_1(S_1)\Abs\semlink\Abs{\sembracket{e}}\alpha_2(S_2)) & (\because\text{Abstract advance})
  \end{align*}
\end{proof}
\section{How to Use the Separately Analyzed Results}
\subsection{Motivation}
Now that we have defined abstract linking that overapproximates concrete linking, let us try to use it to analyze the factorial example.
The theorem that we have to utilize is:
\[\sembracket{e}(S_1\rhd S_2)=S_1\semlink\sembracket{e}S_2\subseteq\gamma_{\semlink}(\alpha_1(S_1)\Abs\semlink\Abs{\sembracket{e}}\alpha_2(S_2))\]
In the factorial example, $e$ is the client code that adds $100!$ to \texttt{M.x}, $S_2$ is the context and memory including the module \texttt{F}, and $S_1$ is the piece of state that includes the module \texttt{M}.
By separately analyzing $\Abs{\sembracket{e}}\alpha_2(S_2)$ and linking $\alpha_1(S_1)$, we overapproximate $\sembracket{e}(S_1\rhd S_2)$.
But what is this $S_1\rhd S_2$ that is given as the initial state to $e$?

The concrete execution that is being modelled is that of the \emph{linked} program $e_{\synlink}$ under the initial state $\mt\texteq{let}\{([],\{\},0)\}$.
When $e_\synlink$ is executing under $\mt$, $e$ starts evaluation under what
{\small\[(\text{\texttt{let M = }}e_1\text{\texttt{ in }}\varepsilon)\synlink(\text{\texttt{let F = }}e_2\text{\texttt{ in }}\varepsilon)\]}%
evaluates to.
Call this $S$.
We expect that $S_1\rhd S_2=S$.
However, this is not true, since $S$ uses only one timestamp, yet $S_1\rhd S_2$ uses two versions.
Therefore, we want to define a notion of equivalence between states to make executions that use different timestamps compatible.

Moreover, note that $S$ will not be given in its concrete form directly, but will be given in its abstract form $\alpha(S)\subseteq\Abs{S}$, to ensure termination.
Thus, we also need to define a notion of equivalence between abstract states that concretizes to equivalent concrete states.

The definition of equivalence thus need to satisfy two desired properties, namely:
\begin{enumerate}
  \item If $\Abs{S}$ and $\Abs{S'}$ are equivalent, all $s\in\gamma(\Abs{S})$ must have an equivalent $s'\in\gamma'(\Abs{S'})$.
  \item If $s\in S$ and $s'\in S'$ are equivalent, $(e,s)$ and $(e,s')$ must step to equivalent states.
\end{enumerate}
These two properties ensure that if we find a $\Abs{S}_1$ such that ${\Abs{S}_1}\rhd{\Abs{S}_2}$ is \emph{equivalent} to $\Abs{S}$, linking $\Abs{S}_1$ with the cached results will overapproximate something \emph{equivalent} to the original execution.

\subsection{Definitions}
In this section, we assume a pair of semantics using $(\Time,\le,\ATime,\A\alpha)$ and $(\Time',\le',\A{\Time'},\A{\alpha'})$.

We first define what it means for two states $s\in\State$ and $s'\in\State'$ to be equivalent.
Recall that $s=(\ctx,\mem,t)$ and $s'=(\ctx',\mem',t')$ for some contexts $\ctx,\ctx'$, some memories $\mem,\mem'$, and some times $t,t'$.
The choice of $t$ and $t'$ is ``not special'' in the sense that as long as they are more recent than the contexts and memories, $\tick$ will continue producing fresh addresses.
Thus, the notion of equivalence is defined by how $\ctx$ and $\mem$ components ``look the same''.

Note that information in $\ctx$ and $\mem$ is only accessed through a sequence of names $x$ and $\modid$.
Thus, one may imagine access ``paths'' with names on the edges and reachable timestamps on the vertices as representing the way that $(\ctx,\mem)$ is \emph{viewed}.
Also, given a $\varphi\in\Time\rightarrow\Time'$, we can define how access paths that use timestamps in $\Time$ are translated to access paths in $\Time'$.
%The definitions are given in Figure \ref{fig:accpath}.
\begin{center}
  %\centering
  \begin{tabular}{rclrcrcl}
    $p$ & $\rightarrow$ & $\epsilon$                   & empty path     & $\qquad$ & $\varphi(\epsilon)$                   & \hspace{-2em} & $\triangleq\epsilon$                              \\
        & $|$           & $\xrightarrow{x}t\:p$        & address access & $\qquad$ & $\varphi(\xrightarrow{x}t\:p)$        & \hspace{-2em} & $\triangleq\xrightarrow{x}\varphi(t)\:\varphi(p)$ \\
        & $|$           & $\xrightarrow{\modid}p$      & module access  & $\qquad$ & $\varphi(\xrightarrow{\modid}p)$      & \hspace{-2em} & $\triangleq\xrightarrow{\modid}\varphi(p)$        \\
        & $|$           & $\xrightarrow{\lambda x.e}p$ & value access   & $\qquad$ & $\varphi(\xrightarrow{\lambda x.e}p)$ & \hspace{-2em} & $\triangleq\xrightarrow{\lambda x.e}\varphi(p)$
  \end{tabular}
  %\caption{Definition for access paths and how translation of timestamps are mapped over access paths.}
  %\label{fig:accpath}
\end{center}

From now on, we shall write $\Path$ for the set of access paths that use timestamps in $\Time$, and $\Path'$ for the set of access paths that use timestamps in $\Time'$.
Then given an access path, we can define a predicate $\valid\in(\Ctx+\Time)\times\Mem\times\Path\rightarrow\mathsf{Prop}$.
$\valid(r,\mem,p)$ is true iff starting from $r$, all accesses edges in $p$ are valid.
Likewise, we can define a predicate $\A\valid\in(\A\Ctx+\A\Time)\times\A\Mem\times\A\Path\rightarrow\mathsf{Prop}$.
$\A\valid(\A{r},\A\mem,\A{p})$ is true iff starting from $\A{r}$, all access edges in $\A{p}$ are valid.
The definitions for $\valid$, $\A\valid$ are given in Figure \ref{fig:valid}.
\begin{figure}[t!]
  \centering
  \begin{minipage}{0.4\linewidth}
    \footnotesize
    \[
      \begin{prooftree}
        \infer0{\valid(\_,\mem,\epsilon)}
      \end{prooftree}
    \]

    \[
      \begin{prooftree}
        \hypo{t=\ctx(x)\qquad\valid(t,\mem,p)}
        \infer1{\valid(\ctx,\mem,\xrightarrow{x}t\:p)}
      \end{prooftree}
    \]

    \[
      \begin{prooftree}
        \hypo{\ctx'=\ctx(\modid)\qquad\valid(\ctx',\mem,p)}
        \infer1{\valid(\ctx,\mem,\xrightarrow{\modid}p)}
      \end{prooftree}
    \]

    \[
      \begin{prooftree}
        \hypo{\langle\lambda x.e,{\ctx}\rangle=\mem(t)\qquad\valid(\ctx,\mem,p)}
        \infer1{\valid(t,\mem,\xrightarrow{\lambda x.e}p)}
      \end{prooftree}
    \]
  \end{minipage}
  \begin{minipage}{0.4\linewidth}
    \footnotesize
    \[
      \begin{prooftree}
        \infer0{\A\valid(\_,\A\mem,\epsilon)}
      \end{prooftree}
    \]

    \[
      \begin{prooftree}
        \hypo{\A{t}=\A\ctx(x)\qquad\A\valid(\A{t},\A\mem,\A{p})}
        \infer1{\A\valid(\A\ctx,\A\mem,\xrightarrow{x}\A{t}\:\A{p})}
      \end{prooftree}
    \]

    \[
      \begin{prooftree}
        \hypo{\A\ctx'=\A\ctx(\modid)\qquad\A\valid(\A\ctx',\A\mem,\A{p})}
        \infer1{\A\valid(\A\ctx,\A\mem,\xrightarrow{\modid}\A{p})}
      \end{prooftree}
    \]

    \[
      \begin{prooftree}
        \hypo{\langle\lambda x.e,{\A\ctx}\rangle\in\A\mem(\A{t})\qquad\A\valid(\A\ctx,\A\mem,\A{p})}
        \infer1{\A\valid(\A{t},\A\mem,\xrightarrow{\lambda x.e}\A{p})}
      \end{prooftree}
    \]
  \end{minipage}
  \caption{Definitions for the $\valid$ and $\A\valid$ predicates.}
  \label{fig:valid}
\end{figure}

Now we can give straightforward definitions of equivalence.
\begin{definition}[Equivalent Concrete States: $\equivalent$]
  Let $s=(\ctx,\mem,\_)\in\State$ and $s'=(\ctx',\mem',\_)\in\State'$.
  $s\equivalent s'$ ($s$ is equivalent to $s'$) iff $\exists\varphi\in\Time\rightarrow\Time',\varphi'\in\Time'\rightarrow\Time:$
  \begin{enumerate}
    \item $\forall p\in\Path:\valid(\ctx,\mem,p)\Rightarrow(\valid(\ctx',\mem',\varphi(p))\land p=\varphi'(\varphi(p)))$
    \item $\forall p'\in\Path':\valid(\ctx',\mem',p')\Rightarrow(\valid(\ctx,\mem,\varphi'(p'))\land p'=\varphi(\varphi'(p')))$
  \end{enumerate}
\end{definition}
\begin{definition}[Weakly Equivalent Abstract States]\label{def:weakequiv}
  Let $\A{s}=(\A{\ctx},\A\mem,\_)\in\AState$ and $\A{s'}=(\A{\ctx'},\A{\mem'},\_)\in\A{\State'}$.
  $\A{s}$ is weakly equivalent to $\A{s'}$ iff $\exists\A\varphi\in\ATime\rightarrow\A{\Time'},\A{\varphi'}\in\A{\Time'}\rightarrow\A\Time:$
  \begin{enumerate}
    \item $\forall\A{p}\in\A\Path:\A\valid(\A{\ctx},\A\mem,\A{p})\Rightarrow(\A\valid(\A{\ctx'},\A{\mem'},\A\varphi(\A{p}))\land\A{p}=\A{\varphi'}(\A\varphi(\A{p})))$
    \item $\forall\A{p'}\in\A{\Path'}:\A\valid(\A{\ctx'},\A{\mem'},\A{p'})\Rightarrow(\A\valid(\A{\ctx},\A{\mem},\A{\varphi'}(\A{p'}))\land\A{p'}=\A\varphi(\A{\varphi'}(\A{p'})))$
  \end{enumerate}
\end{definition}
The reason that the above definition is called ``weak equivalence'' is because it is not sufficient to guarantee equivalence after concretization.
Consider
\[
  \ctx=[(x,0)],\mem=\{0\mapsto\{\langle\lambda z.z,[(x,1)]\rangle,\langle\lambda z.z,[(y,2)]\rangle\},1\mapsto\{\langle\lambda z.z,[]\rangle\}\}
\]
and
\[
  \ctx'=[(x,0)],\mem'=\{0\mapsto\{\langle\lambda z.z,[(x,1);(y,2)]\rangle\},1\mapsto\{\langle\lambda z.z,[]\rangle\}\}
\]
They are weakly equivalent, yet their concretizations are not equivalent.
Thus, we need to strengthen the definition for abstract equivalence.

Before going into the definition, we introduce some terminology.
First, we say that two states are \emph{weakly equivalent by} $\A\varphi,\A{\varphi'}$ when $\A\varphi,\A{\varphi'}$ are the functions that translate between abstract timestamps in Definition \ref{def:weakequiv}.
Second, we say that $\A{t}$ is \emph{reachable from} $\A{s}$ when there is some valid access path $\A{p}$ from $\A{s}$ containing $\A{t}$.
Now we actually give the definition:
\begin{definition}[Equivalent Abstract States: $\A\equivalent$]
  Let $\A{s}=(\_,\A\mem,\_)\in\AState$ and $\A{s'}=(\_,\A{\mem'},\_)\in\A{\State'}$.
  $\A{s}\A\equivalent\A{s'}$ ($\A{s}$ is equivalent to $\A{s'}$) iff $\exists\A\varphi\in\ATime\rightarrow\A{\Time'},\A{\varphi'}\in\A{\Time'}\rightarrow\ATime:$
  \begin{enumerate}
    \item $\A{s}$ and $\A{s'}$ are weakly equivalent by $\A\varphi,\A{\varphi'}$.
    \item For each $\A{t}$ reachable from $\A{s}$ and for each $\langle\lambda x.e,\A{\ctx}\rangle\in\A\mem(\A{t})$, $\langle\lambda x.e,\prexists{\A{\ctx'}}\rangle\in\A{\mem'}(\A\varphi(\A{t}))$ such that $\A{\ctx}$, $\A{\ctx'}$ are weakly equivalent by $\A\varphi,\A{\varphi'}$ under the empty memory.
    \item The same holds for each $\A{t'}$ reachable from $\A{s'}$.
  \end{enumerate}
\end{definition}

We extend the definition of equivalence between elements of $\Right$ and $\Right'$ as the conjunction of the syntactic equality in the expression parts and the equivalence in the context and memory parts.
Then we can extend the definition of equivalence between $A\subseteq\Sigma$ and $A'\subseteq\Sigma'$ by requiring all elements $\config\semarrow\rightst,\rightst$ of $A$ to have an equivalent counterpart in $A'$, and vice versa.
Likewise, we can extend the definition for equivalent abstract states as well.

When $A\subseteq\Sigma$ and $A'\subseteq\Sigma'$ are equivalent, we override the symbol for equivalence between individual states and write $A\equivalent A'$.
When $\Abs{A}\subseteq\A{\Sigma}$ and $\Abs{A'}\subseteq\A{\Sigma'}$ are equivalent, we write $\Abs{A}\Abs\equivalent\Abs{A'}$.

\subsection{Propeties of Equivalence}
We first note that the relations $\equivalent$ and $\A\equivalent$ are actually equivalence relations.
That is, they are reflexive, transitive, and commutative.
We must also show that equivalence is well-behaved under the step relation and concretization.
That is, we must show that concretizing equivalent abstract states lead to equivalent states, and that equivalence preserves the step relation.
\begin{lemma}[Concretization Preserves Equivalence]\label{lem:concreteqiuv}
  Assume that each $\A{t},\A{t'}$ in $\ATime,\A{\Time'}$ corresponds to an infinite set of concrete timestamps.
  Then for all $\Abs{S}\subseteq\AState$ and $\Abs{S'}\subseteq\A{\State'}$,
  \[\Abs{S}\Abs\equivalent\Abs{S'}\Rightarrow\gamma(\Abs{S})\equivalent\gamma'(\Abs{S'})\]
\end{lemma}
\begin{proof}[Sketch]
  We want to prove:
  \[\forall s\in\State,\A{s'}\in\A{\State'}:\A\alpha(s)\A\equivalent\A{s'}\Rightarrow\exists s'\in\State':s\equivalent s'\land\A{\alpha'}(s')=\A{s'}\]
  If this is true, $\forall s\in\gamma(\Abs{S}):\exists s'\in\gamma(\Abs{S'}):s\equivalent s'$.
  Similarly, we have $\forall s'\in\gamma(\Abs{S'}):\exists s\in\gamma(\Abs{S}):s\equivalent s'$, so that $\gamma(\Abs{S})\equivalent\gamma'(\Abs{S'})$.

  This is proven in Coq (\texttt{ConcretEquivalence.v}).
\end{proof}
\begin{lemma}[Evaluation Preserves Equivalence]
  For all $\config\in\Config$, $\rightst\in\Right$, $\config'\in\Config'$,
  \[\config\semarrow\rightst\text{ and }\config\equivalent\config'\Rightarrow\exists\rightst':\config'\semarrow\rightst'\text{ and }\rightst\equivalent\rightst'\]
  Thus, if $S\subseteq\State$ and $S'\subseteq\State'$ are equivalent, $\sembracket{e}S\equivalent\sembracket{e}S'$.
\end{lemma}
\begin{proof}[Sketch]
  This is proven in Coq (\texttt{OperationalEquivalence.v}).
\end{proof}
Note that there is a caveat in Lemma \ref{lem:concreteqiuv}.
We have required that all partitions ${\A\alpha}^{-1}(\A{t})$ of $\Time$ to be infinite.
This is natural, since if an abstract address that concretizes to a finite set corresponds to an abstract address that concretizes to an infinite set, the concretization might no longer be equivalent.
This constraint is not as restrictive as it seems, as widely used abstractions such as \emph{k}-CFA already satisfy this criterion.

\subsection{How to Utilize Equivalence}
Here is a general outline that utilize abstract equivalence and abstract linking to overapproximate any initial state.
The goal is to overapproximate something equivalent to $\sembracket{e}\gamma(\Abs{S})$, when all abstract timestamps in $\Abs{S}$ correspond to infinitely many concrete timestamps.
\begin{description}
  \item[Step 1] Choose a finite set $\A\Time_2$ and a function $\A\tick_2\in\A\Time_2\rightarrow\A\Time_2$.
  \item[Step 2] Assume an initial condition $\Abs{S}_2$ and compute $\Abs{\sembracket{e}}\Abs{S}_2$.
  \item[Step 3] Choose a finite set $\A\Time_1$ and $\A\tick_1\in\A\Time_1\rightarrow\A\Time_1$.
  \item[Step 4] Find a $\Abs{S}_1$ such that $\Abs{S}_1\Abs\rhd\Abs{S}_2$ is equivalent to some \emph{superset} $\ovbar{\Abs{S}}$ of $\Abs{S}$.
  \item[Result] Then $\Abs{S}_1\Abs\semlink\Abs{\sembracket{e}}\Abs{S}_2$ overapproximates an equivalent superset of $\sembracket{e}\gamma(\Abs{S})$.
\end{description}
$\Abs{S}_1\Abs\semlink\Abs{\sembracket{e}}\Abs{S}_2$ overapproximates an equivalent superset of $\sembracket{e}\gamma(\Abs{S})$, since if we let:
\[\Time_{\semlink}\triangleq(\ATime_1+\ATime_2)\times\mathbb{Z}\quad\tick_{\semlink}(\A{t},n)\triangleq(\A\tick_{\semlink}(\A{t}),n+1)\quad\A\alpha_{\semlink}(\A{t},n)\triangleq\A{t}\]
we have a concrete time $\Time_{\semlink}$ that is connected to $\ATime_1+\ATime_2$ by $\A\alpha_{\semlink}$ such that all abstract timestamps correspond to infinitely many concrete timestamps.
Thus:
\begin{align*}
  \sembracket{e}\gamma(\Abs{S}) & \subseteq\sembracket{e}\gamma(\ovbar{\Abs{S}})                               & (\because\Abs{S}\subseteq\ovbar{\Abs{S}}\text{ and }\gamma\text{ monotonic}) \\
                                & \equivalent\sembracket{e}\gamma_{\semlink}(\Abs{S}_1\Abs\rhd\Abs{S}_2)       & (\because\gamma,\semarrow\text{ preserves equivalence})                      \\
                                & \subseteq\gamma_{\semlink}(\Abs{\sembracket{e}}(\Abs{S}_1\Abs\rhd\Abs{S}_2)) & (\because\text{Soundness})                                                   \\
                                & =\gamma_{\semlink}(\Abs{S}_1\Abs\semlink\Abs{\sembracket{e}}\Abs{S}_2)       & (\because\text{Abstract advance})
\end{align*}
%\begin{center}
%  \begin{tabular}{ccc}
%    \begin{minipage}{0.3\linewidth}
%      \begin{lstlisting}[language=Coq]
%(* Module F, case 1 *)
%let f g n = 
%  if n <= 0 then 0 
%  else g n
%%
%    \end{lstlisting}
%    \end{minipage} &
%    \begin{minipage}{0.3\linewidth}
%      \begin{lstlisting}[language=Coq]
%(* Module F, case 2 *)
%let f g n = 
%  if n <= 0 then 0 
%  else g (n - 1)
%%
%    \end{lstlisting}
%    \end{minipage} &
%    \begin{minipage}{0.3\linewidth}
%      \begin{lstlisting}[language=Coq]
%(* Client code *)
%Include F
%let fix g n =
%  n + f g (n - 1)
%let ret = g 3
%    \end{lstlisting}
%    \end{minipage}
%  \end{tabular}
%\end{center}
%Above, we have a piece of code that uses higher-order functions to parametrize the behavior of \texttt{g} over the implementation of \texttt{f}.
%In the first case, \texttt{g n} computes the sum from $0$ to $n$.
%In the second case, \texttt{g n} computes the sum of numbers with parity equal to the parity of $n$ in the range $[0,n]$.

%\begin{figure}[h!]
%  \centering
%  \begin{tabular}{rrr}
%    \multicolumn{1}{l}{Given an initial $(C_i,\mem_i)$:}                                                                                                                                                                                                                                     \\
%    \hline
%    $(e_1,\prexists[blue]{s_1})\semarrow\preall[orange]{r_1}\in\sembracket{e_1}S_1$        & $(e_2,\prexists[blue]{s_2})\semarrow\preall[orange]{r_2}\in\sembracket{e_2}S_2$ & $(e_\lambda,\prexists[blue]{s_\lambda})\semarrow\preall[orange]{r_\lambda}\in\sembracket{e_\lambda}S_\lambda$ \\
%    $(C_1,\mem_1)=\inject{\prexists[blue]{o_1}}{s_1}$                                      & $(C_2,\mem_{\lambda,2})=\inject{\prexists[blue]{o_2}}{s_2}$                     & $(C_\lambda,\mem_{a,\lambda})=\inject{\prexists[blue]{o_\lambda}}{s_\lambda}$                                 \\
%    $(\langle\lambda x.e_\lambda,C_{\lambda,1}\rangle,\mem_{\lambda,1})=\inject{o_1}{r_1}$ & $(v_a,\mem_{a,2})=\inject{o_2}{r_2}$                                            & $(v,\mem)=\inject{o_\lambda}{r_\lambda}$                                                                      \\
%    \\
%    \multicolumn{1}{l}{Such that:}                                                                                                                                                                                                                                                           \\
%    \hline
%    $(C_i,\mem_i)\equivalent[red](C_1,\mem_1)$                                             & $(C_1,\mem_{\lambda,1})$                                                        & \multicolumn{1}{l}{\hspace{\equivadjust}$\equivalent[red](C_2,\mem_{\lambda,2})$}                             \\
%                                                                                           & $(C_{\lambda,1},\mem_{\lambda,1})$                                              & \multicolumn{1}{l}{\hspace{\equivadjust}$\equivalent[red](\prexists[blue]{C_{\lambda,2}},\mem_{\lambda,2})$}  \\
%                                                                                           & $((x,\prexists[blue]{t})::C_{\lambda,2},\mem_{a,2}[t\mapsto v_a])$              & \multicolumn{1}{l}{\hspace{\equivadjust}$\equivalent[red](C_\lambda,\mem_{a,\lambda})$}
%  \end{tabular}
%  \caption{How the application $e_1\:e_2$ can be analyzed by composing pre-analyzed results. The table should be read column by column. $((e,\prexists{s})\semarrow\preall{r}\in A)P(s,r)$ means $(\exists s)(\forall r)((e,s)\semarrow r\in A\Rightarrow P(s,r))$}
%\end{figure}
\bibliographystyle{ACM-Reference-Format}
\bibliography{citations}
\end{document}
%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:
