%! TEX program = xelatex
\documentclass{article}
\usepackage{geometry}
\geometry{
 a4paper,
 total={170mm,257mm},
 left=20mm,
 top=20mm,
}
\usepackage{setspace} % setstretch

\usepackage{graphicx}
\usepackage{kotex}
\usepackage{csquotes}
\usepackage{tabularray}
\UseTblrLibrary{booktabs}
\UseTblrLibrary{counter}

\usepackage{biblatex}
\addbibresource{citations.bib}

%%% Math settings
\usepackage{amssymb,amsmath,mathtools} % Before unicode-math
\usepackage[math-style=TeX,bold-style=TeX]{unicode-math}
\newtheorem{clm}{Claim}[section]
\newtheorem{definition}{Definition}[section]

%%% Font settings
\setmainfont{Libertinus Serif}
\setsansfont{Libertinus Sans}[Scale=MatchUppercase]
\setmonofont{JuliaMono}[Scale=MatchLowercase]
\setmathfont{Libertinus Math} % Before set*hangulfont
\setmathfont{TeX Gyre Pagella Math}[range={\lbrace,\rbrace},Scale=1.1]
\setmainhangulfont{Noto Serif CJK KR}
\setsanshangulfont[BoldFont={* Bold}]{KoPubWorld Dotum.ttf}
\setmonohangulfont{D2Coding}

%%% PL constructs
\usepackage{ebproof}
\ebproofset{left label template=\textsc{[\inserttext]}}

% For simplebnf
\newfontfamily{\fallbackfont}{EB Garamond}
\DeclareTextFontCommand{\textfallback}{\fallbackfont}
\usepackage{newunicodechar}
\newunicodechar{⩴}{\textfallback{⩴}}

\usepackage{simplebnf}
\RenewDocumentCommand\SimpleBNFDefEq{}{\ensuremath{⩴}}

% because of simplebnf
\newcommand*{\vbar}{|}
\newcommand*{\finto}{\xrightarrow{\text{\textrm{fin}}}}
\newcommand*{\istype}{\mathrel{⩴}}
\newcommand*{\ortype}{\mathrel{|}}
\newcommand*{\cons}{::}

% for complement
\newcommand{\loverbar}[1]{\mkern 1.5mu\overline{\mkern-1.5mu#1\mkern-1.5mu}\mkern 1.5mu}
\newcommand*{\Expr}{\text{Expr}}
\newcommand*{\ExprVar}{\text{ExprVar}}
\newcommand*{\Module}{\text{Module}}
\newcommand*{\ModVar}{\text{ModVar}}
\newcommand*{\Time}{\mathbb{T}}
\newcommand*{\Ctx}[1]{\text{Ctx}\:{#1}}
\newcommand*{\Value}[1]{\text{Val}\:{#1}}
\newcommand*{\Mem}[1]{\text{Mem}\:{#1}}
\newcommand*{\link}[2]{{#1}\mathtt{!}{#2}}
\newcommand*{\sembracket}[1]{\lBrack{#1}\rBrack}
\newcommand*{\fin}[2]{{#1}\xrightarrow{\text{fin}}{#2}}
\newcommand*{\addr}{\mathsf{addr}}
\newcommand*{\tick}{\mathsf{tick}}
\newcommand*{\level}{\mathsf{level}}
\newcommand*{\modctx}{\mathsf{ctx}}
\newcommand*{\doubleplus}{+\kern-1.3ex+\kern0.8ex}
\newcommand*{\mdoubleplus}{\ensuremath{\mathbin{+\mkern-10mu+}}}

\title{Semantics for Modular Analysis}
\author{Joonhyup Lee}
\date{}
\begin{document}
\maketitle

\section{Abstract Syntax}

In this section we define the abstract syntax for a simple language that captures the essence of modules and linking.
The language is basically an extension of untyped lambda calculus with modules and the linking operator.

\begin{bnfgrammar}
  $x$ : \in \ExprVar
  ;;
  $M$ : \in \ModVar
  ;;
  $e$ : \in \Expr
  ;;
  $e$ ::= $x$ : identifier, expression
  | $\lambda x.e$ : function
  | $e$ $e$ : application
  | $\link{e}{e}$ : linked expression
  | $\varepsilon$ : empty module
  | $M$ : identifier, module
  | \texttt{let} $x$ $e$ $e$ : let-binding, expression
  | \texttt{let} $M$ $e$ $e$ : let-binding, module
\end{bnfgrammar}

\subsection{Rationale for the design of the simple language}

There are no recursive modules, first-class modules, or functors in the simple language that is defined.
Also, note that the nonterminals for the modules and expressions are not separated. Why is this so?

The rationale for the exclusion of recursive modules/first-class modules/functors is because we want to enforce static scoping.
That is, we need to be able to statically determine where variables were bound when using them.
To enforce static scoping when function applications might return modules, we need to employ signatures to project the dynamically computed modules onto a statically known context.
Concretely, we need to define signatures $S$ where $\lambda M:>S.e$ statically resolves the context when $M$ is used in the body $e$, and $e:>S$ enforces that a dynamic computation is resolved into one static form.

The rationale for not separating modules and expressions in the syntax is because we want to utilize the linking operator to link both modules to expressions and modules to modules.
That is, we want expressions to be parsed as $(m_1!m_2)!e$.
$\link{m_1}{m_2}$ links a module with a module, and $(m_1!m_2)!e$ links a module with an expression.
Why this is convenient will be clear when we explain separate analysis; we want to link modules with modules as well as expressions.

\section{Big-Step Operational Semantics}

In this section we give the big-step operational semantics for the dynamic execution of the module language.
The big-step evaluation relation relates the initial state(memory and time) and configuration(the subexpression being evaluated, and the surrounding dynamic context) with the resulting state and value.

This relation is nonstandard in that the \emph{environment} that is often used to define closures in the call-by-value dynamics is not a finite map from variables to values.
Rather, the surrounding \emph{syntactic} context annotated with the \emph{binding times} for the variables together with the memory serves as the environment.
To access the value of the variable $x$ from the context $C$, one has to read off the closest binding time from the context and look up the value bound at that time from the memory.
To access the exported context from the variable $M$, one has to look up the exported context from $C$, not from the memory.

This separation between where we store modules and where we store the evaluated values from expressions emphasizes the fact that \emph{where} the variables are bound is guided by syntax.
The only thing that is dynamic is \emph{when} the variables are bound, which is represented by the time component.

Now, we start by defining what we mean by \emph{time} and \emph{context}, which is the essence of our model.

\subsection{Time and Context}

We first define sets that are parametrized by our choice of the time domain, mainly the \emph{value}, \emph{memory}, and \emph{context} domains.
Below, the $\Time$ set may be any arbitrary set.
Later, we constrain $\Time$ to meet the constraint that $\tick$ always give fresh timestamps.

\begin{bnfgrammar}
  $t$ : \in \Time
  ;;
  $v$ : \in \Value{\Time}
  ;;
  $C$ : \in \Ctx{\Time}
  ;;
  $\sigma$ : \in \Mem{\Time} \triangleq \fin{\Time}{\Value{\Time}}
  ;;
  $C$ ::= [] : hole
  | $\lambda x^{t}.C$ : function parameter binding
  | \texttt{let} $x^{t}$ $C$ : let expression binding
  | \texttt{let} $M$ $C$ $C$ : let module context binding
  ;;
  $v$ ::= $\langle \lambda x.e, C \rangle$ : closure
\end{bnfgrammar}

Now we give the conditions that the concrete time domain must satisfy.

\begin{definition}
  
\end{definition}

We define the plugin operator for the dynamic context.
\[
  C_{1}[C_{2}]\triangleq
  \begin{cases}
    C_{2}                           & (C_{1}=[])                       \\
    \lambda x^{t}.C'[C_{2}]         & (C_{1}=\lambda x^{t}.C')         \\
    \mathtt{let}\:x^{t}\:C'[C_{2}]  & (C_{1}=\mathtt{let}\:x^{t}\:C')  \\
    \mathtt{let}\:M\:C'\:C''[C_{2}] & (C_{1}=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]

Now, for the operational semantics, the functions that extract information about the binding times from the dynamic context must be defined.
The first function to be defined is the $\level$ function, which returns the list of binding times counted from the hole upwards.
\[
  \level(C) \triangleq
  \begin{cases}
    \mathsf{nil}              & (C=[])                                           \\
    \level(C')\mdoubleplus[t] & (C=\lambda x^{t}.C'\lor \mathtt{let\:}x^{t}\:C') \\
    \level(C'')               & (C=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]
Also, the function that calculates the address from the dynamic context $C$ and variable $x$ must be defined.
Note that $\mathsf{nil}$ is used as the null address, which should never be accessed.
\[
  \addr(C,x)\triangleq
  \begin{cases}
    \mathsf{nil}       & (C=[])                                                                   \\
    \mathsf{nil}       & (C=\lambda x'^{t}.C'\wedge x'\neq x\wedge \addr(C',x)=\mathsf{nil})      \\
    \mathsf{nil}       & (C=\mathtt{let}\:x'^{t}C'\wedge x'\neq x\wedge \addr(C',x)=\mathsf{nil}) \\
    [t]                & (C=\lambda x'^{t}.C'\wedge x'= x\wedge \addr(C',x)=\mathsf{nil})         \\
    [t]                & (C=\mathtt{let}\:x'^{t}C'\wedge x'= x\wedge \addr(C',x)=\mathsf{nil})    \\
    p \mdoubleplus [t] & (C=\lambda x'^{t}.C'\wedge \addr(C',x)=p\neq\mathsf{nil})                \\
    p \mdoubleplus [t] & (C=\mathtt{let}\:x'^{t}\:C'\wedge \addr(C',x)=p\neq\mathsf{nil})         \\
    \addr(C'',x)       & (C=\mathtt{let}\:M\:C'\:C'')
  \end{cases}
\]
Finally, the function that looks up the dynamic context bound to a module variable $M$ must be defined.
Note that this function returns $\bot$ when the module $M$ is not found.
\[
  \modctx(C,M)\triangleq
  \begin{cases}
    \bot           & (C=[])                                                             \\
    C'             & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'= M\wedge\modctx(C'',M)=\bot) \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge\modctx(C'',M)\neq\bot)          \\
    \modctx(C'',M) & (C=\mathtt{let}\:M'\:C'\:C''\wedge M'\neq M)                       \\
    \modctx(C',M)  & (C=\lambda x^{t}.C')                                               \\
    \modctx(C',M)  & (C=\mathtt{let}\:x^{t}\:C')
  \end{cases}
\]

Now we are in a position to define the big-step evaluation relation.

\begin{prooftree*}
  \hypo{p_{x}=\addr(C,x)}
  \hypo{p_{x}\neq\mathsf{nil}}
  \infer[left label=ExprVar]2{
  (x, C), (\sigma, t)
  \Downarrow
  \sigma(p_{x}), (\sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \infer[left label=Fn]0{
  (\lambda x.e, C), (\sigma, t)
  \Downarrow
  (\lambda x.e, C), (\sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (e_{1}, C), (\sigma, t)
      \Downarrow
      (\lambda x.e_{\lambda}, C_{\lambda}), (\sigma_{\lambda}, t_{\lambda}) \\
      (e_{2}, C), (\sigma_{\lambda}, t_{\lambda})
      \Downarrow
      (v, C_{a}), (\sigma_{a}, t_{a})                                       \\
      (e_{\lambda}, C_{\lambda}[\lambda x^{t_{a}}.[]]), (\sigma_{a}[t_{a}::\level(C_{\lambda})\mapsto(v, C_{a})], t_{a} + 1)
      \Downarrow
      (v', C'), (\sigma',t')
    \end{matrix}
  }
  \infer[left label={App}]1{
  (e_{1}\:e_{2}, C), (\sigma, t)
  \Downarrow
  (v',C'), (\sigma',t')
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (m, C), (\sigma, t)
      \Downarrow
      C', (\sigma', t') \\
      (e, C'), (\sigma', t')
      \Downarrow
      (v, C''), (\sigma'', t'')
    \end{matrix}
  }
  \infer[left label=Linking]1{
  (\link{m}{e}, C), (\sigma, t)
  \Downarrow
  (v, C''), (\sigma'', t'')
  }
\end{prooftree*}

\begin{prooftree*}
  \infer[left label=Empty]0{
  (\varepsilon, C), (\sigma, t)
  \Downarrow
  C, (\sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{C'=\modctx(C,M)}
  \hypo{C'\neq\bot}
  \infer[left label=ModVar]2{
  (M, C), (\sigma, t)
  \Downarrow
  C', (\sigma, t)
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (e, C), (\sigma, t)
      \Downarrow
      (v, C'), (\sigma', t') \\
      (m, C[\mathtt{let}\:x^{t'}\:[]]), (\sigma_{v}[t'::\level(C)\mapsto(v,C')], t'+1)
      \Downarrow
      C'', (\sigma'', t'')
    \end{matrix}
  }
  \infer[left label=LetE]1{
  (\mathtt{let}\:x\:e\:m,C), (\sigma, t)
  \Downarrow
  C'', (\sigma'', t'')
  }
\end{prooftree*}

\begin{prooftree*}
  \hypo{
    \begin{matrix}
      (m_{1}, C), (\sigma, t)
      \Downarrow
      C', (\sigma', t') \\
      (m_{2}, C[\mathtt{let}\:M\:C'\:[]]), (\sigma'[t'::\level(C')\mapsto(p', C')], t'+1)
      \Downarrow
      C'', (\sigma'', t'')
    \end{matrix}
  }
  \infer[left label=LetM]1{
  (\mathtt{let}\:M\:m_{1}\:m_{2}, C), (\sigma, t)
  \Downarrow
  C'', (\sigma'', t'')
  }
\end{prooftree*}

To 

\section{Collecting Semantics}

Now we make the semantics of a module $m$ and the semantics of an expression $e$ explicit.

\printbibliography
\end{document}
%%% Local Variables: 
%%% coding: utf-8
%%% mode: latex
%%% TeX-engine: xetex
%%% End:
